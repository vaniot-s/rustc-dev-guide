<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Guide to Rustc Development</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about-this-guide.html">About this guide</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="part-1-intro.html"><strong aria-hidden="true">1.</strong> Part 1: Building, debugging, and contributing to Rustc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler-team.html"><strong aria-hidden="true">1.1.</strong> About the compiler team</a></li><li class="chapter-item "><a href="building/how-to-build-and-run.html"><strong aria-hidden="true">1.2.</strong> How to Build and Run the Compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building/suggested.html"><strong aria-hidden="true">1.2.1.</strong> Suggested Workflows</a></li><li class="chapter-item "><a href="building/bootstrapping.html"><strong aria-hidden="true">1.2.2.</strong> Bootstrapping</a></li><li class="chapter-item "><a href="building/build-install-distribution-artifacts.html"><strong aria-hidden="true">1.2.3.</strong> Distribution artifacts</a></li><li class="chapter-item "><a href="building/compiler-documenting.html"><strong aria-hidden="true">1.2.4.</strong> Documenting Compiler</a></li><li class="chapter-item "><a href="building/ctags.html"><strong aria-hidden="true">1.2.5.</strong> ctags</a></li></ol></li><li class="chapter-item "><a href="tests/intro.html"><strong aria-hidden="true">1.3.</strong> The compiler testing framework</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/running.html"><strong aria-hidden="true">1.3.1.</strong> Running tests</a></li><li class="chapter-item "><a href="tests/adding.html"><strong aria-hidden="true">1.3.2.</strong> Adding new tests</a></li><li class="chapter-item "><a href="compiletest.html"><strong aria-hidden="true">1.3.3.</strong> Using compiletest + commands to control test execution</a></li></ol></li><li class="chapter-item "><a href="walkthrough.html"><strong aria-hidden="true">1.4.</strong> Walkthrough: a typical contribution</a></li><li class="chapter-item "><a href="bug-fix-procedure.html"><strong aria-hidden="true">1.5.</strong> Bug Fix Procedure</a></li><li class="chapter-item "><a href="implementing_new_features.html"><strong aria-hidden="true">1.6.</strong> Implementing new features</a></li><li class="chapter-item "><a href="stability.html"><strong aria-hidden="true">1.7.</strong> Stability attributes</a></li><li class="chapter-item "><a href="stabilization_guide.html"><strong aria-hidden="true">1.8.</strong> Stabilizing Features</a></li><li class="chapter-item "><a href="compiler-debugging.html"><strong aria-hidden="true">1.9.</strong> Debugging the Compiler</a></li><li class="chapter-item "><a href="profiling.html"><strong aria-hidden="true">1.10.</strong> Profiling the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="profiling/with_perf.html"><strong aria-hidden="true">1.10.1.</strong> with the linux perf tool</a></li></ol></li><li class="chapter-item "><a href="conventions.html"><strong aria-hidden="true">1.11.</strong> Coding conventions</a></li><li class="chapter-item "><a href="crates-io.html"><strong aria-hidden="true">1.12.</strong> crates.io Dependencies</a></li><li class="chapter-item "><a href="diagnostics.html"><strong aria-hidden="true">1.13.</strong> Emitting Errors and other Diagnostics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="diagnostics/lintstore.html"><strong aria-hidden="true">1.13.1.</strong> LintStore</a></li><li class="chapter-item "><a href="diagnostics/diagnostic-codes.html"><strong aria-hidden="true">1.13.2.</strong> Diagnostic Codes</a></li></ol></li><li class="chapter-item "><a href="ice-breaker/about.html"><strong aria-hidden="true">1.14.</strong> ICE-breaker teams</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ice-breaker/cleanup-crew.html"><strong aria-hidden="true">1.14.1.</strong> &quot;Cleanup Crew&quot; ICE-breakers</a></li><li class="chapter-item "><a href="ice-breaker/llvm.html"><strong aria-hidden="true">1.14.2.</strong> LLVM ICE-breakers</a></li></ol></li><li class="chapter-item "><a href="licenses.html"><strong aria-hidden="true">1.15.</strong> Licenses</a></li></ol></li><li class="chapter-item expanded "><a href="part-2-intro.html"><strong aria-hidden="true">2.</strong> Part 2: High-level Compiler Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">2.1.</strong> Overview of the Compiler</a></li><li class="chapter-item "><a href="compiler-src.html"><strong aria-hidden="true">2.2.</strong> The compiler source code</a></li><li class="chapter-item "><a href="query.html"><strong aria-hidden="true">2.3.</strong> Queries: demand-driven compilation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">2.3.1.</strong> The Query Evaluation Model in Detail</a></li><li class="chapter-item "><a href="queries/incremental-compilation.html"><strong aria-hidden="true">2.3.2.</strong> Incremental compilation</a></li><li class="chapter-item "><a href="queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">2.3.3.</strong> Incremental compilation In Detail</a></li><li class="chapter-item "><a href="incrcomp-debugging.html"><strong aria-hidden="true">2.3.4.</strong> Debugging and Testing</a></li><li class="chapter-item "><a href="queries/profiling.html"><strong aria-hidden="true">2.3.5.</strong> Profiling Queries</a></li><li class="chapter-item "><a href="salsa.html"><strong aria-hidden="true">2.3.6.</strong> Salsa</a></li></ol></li><li class="chapter-item "><a href="memory.html"><strong aria-hidden="true">2.4.</strong> Memory Management in Rustc</a></li><li class="chapter-item "><a href="parallel-rustc.html"><strong aria-hidden="true">2.5.</strong> Parallel Compilation</a></li></ol></li><li class="chapter-item expanded "><a href="part-3-intro.html"><strong aria-hidden="true">3.</strong> Part 3: Source Code Representations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustc-driver.html"><strong aria-hidden="true">3.1.</strong> The Rustc Driver and Interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustdoc.html"><strong aria-hidden="true">3.1.1.</strong> Rustdoc</a></li><li class="chapter-item "><a href="rustc-driver-interacting-with-the-ast.html"><strong aria-hidden="true">3.1.2.</strong> Ex: Type checking through rustc_interface</a></li><li class="chapter-item "><a href="rustc-driver-getting-diagnostics.html"><strong aria-hidden="true">3.1.3.</strong> Ex: Getting diagnostics through rustc_interface</a></li></ol></li><li class="chapter-item "><a href="syntax-intro.html"><strong aria-hidden="true">3.2.</strong> Syntax and the AST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="the-parser.html"><strong aria-hidden="true">3.2.1.</strong> Lexing and Parsing</a></li><li class="chapter-item "><a href="macro-expansion.html"><strong aria-hidden="true">3.2.2.</strong> Macro expansion</a></li><li class="chapter-item "><a href="name-resolution.html"><strong aria-hidden="true">3.2.3.</strong> Name resolution</a></li><li class="chapter-item "><a href="test-implementation.html"><strong aria-hidden="true">3.2.4.</strong> #[test] Implementation</a></li><li class="chapter-item "><a href="panic-implementation.html"><strong aria-hidden="true">3.2.5.</strong> Panic Implementation</a></li><li class="chapter-item "><a href="ast-validation.html"><strong aria-hidden="true">3.2.6.</strong> AST Validation</a></li><li class="chapter-item "><a href="feature-gate-ck.html"><strong aria-hidden="true">3.2.7.</strong> Feature Gate Checking</a></li></ol></li><li class="chapter-item "><a href="hir.html"><strong aria-hidden="true">3.3.</strong> The HIR (High-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lowering.html"><strong aria-hidden="true">3.3.1.</strong> Lowering AST to HIR</a></li><li class="chapter-item "><a href="hir-debugging.html"><strong aria-hidden="true">3.3.2.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="mir/index.html"><strong aria-hidden="true">3.4.</strong> The MIR (Mid-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/construction.html"><strong aria-hidden="true">3.4.1.</strong> HAIR and MIR construction</a></li><li class="chapter-item "><a href="mir/visitor.html"><strong aria-hidden="true">3.4.2.</strong> MIR visitor and traversal</a></li><li class="chapter-item "><a href="mir/passes.html"><strong aria-hidden="true">3.4.3.</strong> MIR passes: getting the MIR for a function</a></li></ol></li><li class="chapter-item "><a href="closure.html"><strong aria-hidden="true">3.5.</strong> Closure expansion</a></li></ol></li><li class="chapter-item expanded "><a href="part-4-intro.html"><strong aria-hidden="true">4.</strong> Part 4: Analysis</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ty.html"><strong aria-hidden="true">4.1.</strong> The ty module: representing types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">4.1.1.</strong> Generics and substitutions</a></li><li class="chapter-item "><a href="ty-fold.html"><strong aria-hidden="true">4.1.2.</strong> TypeFolder and TypeFoldable</a></li><li class="chapter-item "><a href="generic_arguments.html"><strong aria-hidden="true">4.1.3.</strong> Generic arguments</a></li></ol></li><li class="chapter-item "><a href="type-inference.html"><strong aria-hidden="true">4.2.</strong> Type inference</a></li><li class="chapter-item "><a href="traits/resolution.html"><strong aria-hidden="true">4.3.</strong> Trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/hrtb.html"><strong aria-hidden="true">4.3.1.</strong> Higher-ranked trait bounds</a></li><li class="chapter-item "><a href="traits/caching.html"><strong aria-hidden="true">4.3.2.</strong> Caching subtleties</a></li><li class="chapter-item "><a href="traits/specialization.html"><strong aria-hidden="true">4.3.3.</strong> Specialization</a></li><li class="chapter-item "><a href="traits/chalk.html"><strong aria-hidden="true">4.3.4.</strong> Chalk-based trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">4.3.4.1.</strong> Lowering to logic</a></li><li class="chapter-item "><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">4.3.4.2.</strong> Goals and clauses</a></li><li class="chapter-item "><a href="traits/canonical-queries.html"><strong aria-hidden="true">4.3.4.3.</strong> Canonical queries</a></li><li class="chapter-item "><a href="traits/lowering-module.html"><strong aria-hidden="true">4.3.4.4.</strong> Lowering module in rustc</a></li></ol></li></ol></li><li class="chapter-item "><a href="type-checking.html"><strong aria-hidden="true">4.4.</strong> Type checking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="method-lookup.html"><strong aria-hidden="true">4.4.1.</strong> Method Lookup</a></li><li class="chapter-item "><a href="variance.html"><strong aria-hidden="true">4.4.2.</strong> Variance</a></li><li class="chapter-item "><a href="opaque-types-type-alias-impl-trait.html"><strong aria-hidden="true">4.4.3.</strong> Opaque Types</a></li></ol></li><li class="chapter-item "><a href="pat-exhaustive-checking.html"><strong aria-hidden="true">4.5.</strong> Pattern and Exhaustiveness Checking</a></li><li class="chapter-item "><a href="borrow_check.html"><strong aria-hidden="true">4.6.</strong> The borrow checker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization.html"><strong aria-hidden="true">4.6.1.</strong> Tracking moves and initialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">4.6.1.1.</strong> Move paths</a></li></ol></li><li class="chapter-item "><a href="borrow_check/type_check.html"><strong aria-hidden="true">4.6.2.</strong> MIR type checker</a></li><li class="chapter-item "><a href="borrow_check/region_inference.html"><strong aria-hidden="true">4.6.3.</strong> Region inference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/region_inference/constraint_propagation.html"><strong aria-hidden="true">4.6.3.1.</strong> Constraint propagation</a></li><li class="chapter-item "><a href="borrow_check/region_inference/lifetime_parameters.html"><strong aria-hidden="true">4.6.3.2.</strong> Lifetime parameters</a></li><li class="chapter-item "><a href="borrow_check/region_inference/member_constraints.html"><strong aria-hidden="true">4.6.3.3.</strong> Member constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/placeholders_and_universes.html"><strong aria-hidden="true">4.6.3.4.</strong> Placeholders and universes</a></li><li class="chapter-item "><a href="borrow_check/region_inference/closure_constraints.html"><strong aria-hidden="true">4.6.3.5.</strong> Closure constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/error_reporting.html"><strong aria-hidden="true">4.6.3.6.</strong> Error reporting</a></li></ol></li><li class="chapter-item "><a href="borrow_check/two_phase_borrows.html"><strong aria-hidden="true">4.6.4.</strong> Two-phase-borrows</a></li></ol></li><li class="chapter-item "><a href="param_env.html"><strong aria-hidden="true">4.7.</strong> Parameter Environments</a></li></ol></li><li class="chapter-item expanded "><a href="part-5-intro.html"><strong aria-hidden="true">5.</strong> Part 5: From MIR to binaries</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/index.html"><strong aria-hidden="true">5.1.</strong> The MIR (Mid-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/optimizations.html"><strong aria-hidden="true">5.1.1.</strong> MIR optimizations</a></li><li class="chapter-item "><a href="mir/debugging.html"><strong aria-hidden="true">5.1.2.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="const-eval.html"><strong aria-hidden="true">5.2.</strong> Constant evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="miri.html"><strong aria-hidden="true">5.2.1.</strong> miri const evaluator</a></li></ol></li><li class="chapter-item "><a href="backend/monomorph.html"><strong aria-hidden="true">5.3.</strong> Monomorphization</a></li><li class="chapter-item "><a href="backend/lowering-mir.html"><strong aria-hidden="true">5.4.</strong> Lowering MIR</a></li><li class="chapter-item "><a href="backend/codegen.html"><strong aria-hidden="true">5.5.</strong> Code Generation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="backend/updating-llvm.html"><strong aria-hidden="true">5.5.1.</strong> Updating LLVM</a></li><li class="chapter-item "><a href="backend/debugging.html"><strong aria-hidden="true">5.5.2.</strong> Debugging LLVM</a></li><li class="chapter-item "><a href="backend/backend-agnostic.html"><strong aria-hidden="true">5.5.3.</strong> Backend Agnostic Codegen</a></li><li class="chapter-item "><a href="codegen/implicit-caller-location.html"><strong aria-hidden="true">5.5.4.</strong> Implicit Caller Location</a></li></ol></li><li class="chapter-item "><a href="profile-guided-optimization.html"><strong aria-hidden="true">5.6.</strong> Profile-guided Optimization</a></li><li class="chapter-item "><a href="sanitizers.html"><strong aria-hidden="true">5.7.</strong> Sanitizers Support</a></li><li class="chapter-item "><a href="debugging-support-in-rustc.html"><strong aria-hidden="true">5.8.</strong> Debugging Support in Rust Compiler</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="appendix/background.html">Appendix A: Background material</a></li><li class="chapter-item expanded affix "><a href="appendix/glossary.html">Appendix B: Glossary</a></li><li class="chapter-item expanded affix "><a href="appendix/code-index.html">Appendix C: Code Index</a></li><li class="chapter-item expanded affix "><a href="appendix/compiler-lecture.html">Appendix D: Compiler Lecture Series</a></li><li class="chapter-item expanded affix "><a href="appendix/bibliography.html">Appendix E: Bibliography</a></li><li class="chapter-item expanded affix "><a href="appendix/humorust.html">Appendix Z: HumorRust</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Guide to Rustc Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about-this-guide" id="about-this-guide">About this guide</a></h1>
<p>This guide is meant to help document how rustc – the Rust compiler –
works, as well as to help new contributors get involved in rustc
development.</p>
<p>There are six parts to this guide:</p>
<ol>
<li><a href="./part-1-intro.html">Building, Debugging, and Contributing to <code>rustc</code></a>: Contains information that should be useful no matter how
you are contributing, such as procedures for contribution, building the
compiler, etc.</li>
<li><a href="./part-2-intro.html">High-Level Compiler Architecture</a>: Discusses the high-level
architecture of the compiler and stages of the compile process.</li>
<li><a href="./part-3-intro.html">Source Code Representation</a>: Describes the process of taking raw source code from the user and
transforming it into various forms that the compiler can work with easily.</li>
<li><a href="./part-4-intro.html">Analysis</a>: discusses the analyses that the compiler uses to check various
properties of the code and inform later stages of the compile process (e.g., type checking).</li>
<li><a href="./part-5-intro.html">From MIR to Binaries</a>: How linked executable machine code is generated.</li>
<li><a href="./appendix/background.html">Appendices</a> at the end with useful reference information. There are a
few of these with different information, inluding a glossary.</li>
</ol>
<p>The Guide itself is of course open-source as well, and the sources can
be found at the <a href="https://github.com/rust-lang/rustc-dev-guide/">GitHub repository</a>. If you find any mistakes in the
guide, please file an issue about it, or even better, open a PR
with a correction!</p>
<h2><a class="header" href="#other-places-to-find-information" id="other-places-to-find-information">Other places to find information</a></h2>
<p>You might also find the following sites useful:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/">rustc API docs</a> -- rustdoc documentation for the compiler</li>
<li><a href="https://forge.rust-lang.org/">Forge</a> -- contains documentation about rust infrastructure, team procedures, and more</li>
<li><a href="https://github.com/rust-lang/compiler-team/">compiler-team</a> -- the home-base for the rust compiler team, with description
of the team procedures, active working groups, and the team calendar.</li>
</ul>
<h1><a class="header" href="#part-1-building-debugging-and-contributing-to-rustc" id="part-1-building-debugging-and-contributing-to-rustc">Part 1: Building, Debugging, and Contributing to <code>rustc</code></a></h1>
<p>This section of the rustc-dev-guide contains knowledge that should be useful to you
regardless of what part of the compiler you are working on. This includes both
technical info and tips (e.g. how to compile and debug the compiler) and info
about processes in the Rust project (e.g. stabilization and info about the
compiler team).</p>
<h1><a class="header" href="#about-the-compiler-team" id="about-the-compiler-team">About the compiler team</a></h1>
<p>rustc is maintained by the <a href="https://www.rust-lang.org/governance/teams/compiler">Rust compiler team</a>. The people who belong to
this team collectively work to track regressions and implement new features.
Members of the Rust compiler team are people who have made significant
contributions to rustc and its design.</p>
<h2><a class="header" href="#discussion" id="discussion">Discussion</a></h2>
<p>Currently the compiler team chats in 2 places:</p>
<ul>
<li>The <code>t-compiler</code> stream on <a href="https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler">the Zulip instance</a></li>
<li>The <code>compiler</code> channel on the <a href="https://discord.gg/rust-lang">rust-lang discord</a></li>
</ul>
<h2><a class="header" href="#expert-map" id="expert-map">Expert map</a></h2>
<p>If you're interested in figuring out who can answer questions about a
particular part of the compiler, or you'd just like to know who works on what,
check out our <a href="https://github.com/rust-lang/compiler-team/blob/master/content/experts/map.toml">experts directory</a>.
It contains a listing of the various parts of the compiler and a list of people
who are experts on each one.</p>
<h2><a class="header" href="#rust-compiler-meeting" id="rust-compiler-meeting">Rust compiler meeting</a></h2>
<p>The compiler team has a weekly meeting where we do triage and try to
generally stay on top of new bugs, regressions, and other things.
They are held on <a href="https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler">Zulip</a>. It works roughly as follows:</p>
<ul>
<li><strong>Review P-high bugs:</strong> P-high bugs are those that are sufficiently
important for us to actively track progress. P-high bugs should
ideally always have an assignee.</li>
<li><strong>Look over new regressions:</strong> we then look for new cases where the
compiler broke previously working code in the wild. Regressions are
almost always marked as P-high; the major exception would be bug
fixes (though even there we often <a href="./bug-fix-procedure.html">aim to give warnings first</a>).</li>
<li><strong>Check I-nominated issues:</strong> These are issues where feedback from
the team is desired.</li>
<li><strong>Check for beta nominations:</strong> These are nominations of things to
backport to beta.</li>
<li><strong>Possibly WG checking:</strong> A WG may give an update at this point, if there is
time.</li>
</ul>
<p>The meeting currently takes place on Thursdays at 10am Boston time
(UTC-4 typically, but daylight savings time sometimes makes things
complicated).</p>
<p>The meeting is held over a &quot;chat medium&quot;, currently on <a href="https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler">zulip</a>.</p>
<h2><a class="header" href="#team-membership" id="team-membership">Team membership</a></h2>
<p>Membership in the Rust team is typically offered when someone has been
making significant contributions to the compiler for some
time. Membership is both a recognition but also an obligation:
compiler team members are generally expected to help with upkeep as
well as doing reviews and other work.</p>
<p>If you are interested in becoming a compiler team member, the first
thing to do is to start fixing some bugs, or get involved in a working
group. One good way to find bugs is to look for
<a href="https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy">open issues tagged with E-easy</a>
or
<a href="https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-mentor">E-mentor</a>.</p>
<h3><a class="header" href="#r-rights" id="r-rights">r+ rights</a></h3>
<p>Once you have made a number of individual PRs to rustc, we will often
offer r+ privileges. This means that you have the right to instruct
&quot;bors&quot; (the robot that manages which PRs get landed into rustc) to
merge a PR
(<a href="https://buildbot2.rust-lang.org/homu/">here are some instructions for how to talk to bors</a>).</p>
<p>The guidelines for reviewers are as follows:</p>
<ul>
<li>You are always welcome to review any PR, regardless of who it is
assigned to.  However, do not r+ PRs unless:
<ul>
<li>You are confident in that part of the code.</li>
<li>You are confident that nobody else wants to review it first.
<ul>
<li>For example, sometimes people will express a desire to review a
PR before it lands, perhaps because it touches a particularly
sensitive part of the code.</li>
</ul>
</li>
</ul>
</li>
<li>Always be polite when reviewing: you are a representative of the
Rust project, so it is expected that you will go above and beyond
when it comes to the <a href="https://www.rust-lang.org/policies/code-of-conduct">Code of Conduct</a>.</li>
</ul>
<h3><a class="header" href="#high-five" id="high-five">high-five</a></h3>
<p>Once you have r+ rights, you can also be added to the <a href="https://github.com/rust-highfive">high-five</a>
rotation. high-five is the bot that assigns incoming PRs to
reviewers. If you are added, you will be randomly selected to review
PRs. If you find you are assigned a PR that you don't feel comfortable
reviewing, you can also leave a comment like <code>r? @so-and-so</code> to assign
to someone else — if you don't know who to request, just write <code>r? @nikomatsakis for reassignment</code> and @nikomatsakis will pick someone
for you.</p>
<p>Getting on the high-five list is much appreciated as it lowers the
review burden for all of us! However, if you don't have time to give
people timely feedback on their PRs, it may be better that you don't
get on the list.</p>
<h3><a class="header" href="#full-team-membership" id="full-team-membership">Full team membership</a></h3>
<p>Full team membership is typically extended once someone made many
contributions to the Rust compiler over time, ideally (but not
necessarily) to multiple areas. Sometimes this might be implementing a
new feature, but it is also important — perhaps more important! — to
have time and willingness to help out with general upkeep such as
bugfixes, tracking regressions, and other less glamorous work.</p>
<h1><a class="header" href="#how-to-build-and-run-the-compiler" id="how-to-build-and-run-the-compiler">How to Build and Run the Compiler</a></h1>
<p>The compiler is built using a tool called <code>x.py</code>. You will need to
have Python installed to run it. But before we get to that, if you're going to
be hacking on <code>rustc</code>, you'll want to tweak the configuration of the compiler.
The default configuration is oriented towards running the compiler as a user,
not a developer.</p>
<h2><a class="header" href="#get-the-source-code" id="get-the-source-code">Get the source code</a></h2>
<p>The very first step to work on <code>rustc</code> is to clone the repository:</p>
<pre><code class="language-bash">git clone https://github.com/rust-lang/rust.git
cd rust
</code></pre>
<h2><a class="header" href="#create-a-configtoml" id="create-a-configtoml">Create a config.toml</a></h2>
<p>To start, copy <a href="https://github.com/rust-lang/rust/blob/master/config.toml.example"><code>config.toml.example</code></a> to <code>config.toml</code>:</p>
<pre><code class="language-bash">cp config.toml.example config.toml
</code></pre>
<p>Then you will want to open up the file and change the following
settings (and possibly others, such as <code>llvm.ccache</code>):</p>
<pre><code class="language-toml">[llvm]
# Enables LLVM assertions, which will check that the LLVM bitcode generated
# by the compiler is internally consistent. These are particularly helpful
# if you edit `codegen`.
assertions = true

[rust]
# This will make your build more parallel; it costs a bit of runtime
# performance perhaps (less inlining) but it's worth it.
codegen-units = 0

# This enables full debuginfo and debug assertions. The line debuginfo is also
# enabled by `debuginfo-level = 1`. Full debuginfo is also enabled by
# `debuginfo-level = 2`. Debug assertions can also be enabled with
# `debug-assertions = true`. Note that `debug = true` will make your build
# slower, so you may want to try individually enabling debuginfo and assertions
# or enable only line debuginfo which is basically free.
debug = true
</code></pre>
<p>If you have already built <code>rustc</code>, then you may have to execute <code>rm -rf build</code> for subsequent
configuration changes to take effect. Note that <code>./x.py clean</code> will not cause a
rebuild of LLVM, so if your configuration change affects LLVM, you will need to
manually <code>rm -rf build/</code> before rebuilding.</p>
<h2><a class="header" href="#what-is-xpy" id="what-is-xpy">What is <code>x.py</code>?</a></h2>
<p><code>x.py</code> is the script used to orchestrate the tooling in the <code>rustc</code> repository.
It is the script that can build docs, run tests, and compile <code>rustc</code>.
It is the now preferred way to build <code>rustc</code> and it replaces the old makefiles
from before. Below are the different ways to utilize <code>x.py</code> in order to
effectively deal with the repo for various common tasks.</p>
<p>This chapter focuses on the basics to be productive, but
if you want to learn more about <code>x.py</code>, read its README.md
<a href="https://github.com/rust-lang/rust/blob/master/src/bootstrap/README.md">here</a>.</p>
<h2><a class="header" href="#bootstrapping" id="bootstrapping">Bootstrapping</a></h2>
<p>One thing to keep in mind is that <code>rustc</code> is a <em>bootstrapping</em>
compiler. That is, since <code>rustc</code> is written in Rust, we need to use an
older version of the compiler to compile the newer version. In
particular, the newer version of the compiler and some of the artifacts needed
to build it, such as <code>libstd</code> and other tooling, may use some unstable features
internally, requiring a specific version which understands these unstable
features.</p>
<p>The result is that compiling <code>rustc</code> is done in stages:</p>
<ul>
<li><strong>Stage 0:</strong> the stage0 compiler is usually (you can configure <code>x.py</code> to use
something else) the current <em>beta</em> <code>rustc</code> compiler and its associated dynamic
libraries (which <code>x.py</code> will download for you). This stage0 compiler is then
used only to compile <code>rustbuild</code>, <code>std</code>, and <code>rustc</code>. When compiling
<code>rustc</code>, this stage0 compiler uses the freshly compiled <code>std</code>.
There are two concepts at play here: a compiler (with its set of dependencies)
and its 'target' or 'object' libraries (<code>std</code> and <code>rustc</code>).
Both are staged, but in a staggered manner.</li>
<li><strong>Stage 1:</strong> the code in your clone (for new version) is then
compiled with the stage0 compiler to produce the stage1 compiler.
However, it was built with an older compiler (stage0), so to
optimize the stage1 compiler we go to next the stage.
<ul>
<li>In theory, the stage1 compiler is functionally identical to the
stage2 compiler, but in practice there are subtle differences. In
particular, the stage1 compiler itself was built by stage0 and
hence not by the source in your working directory: this means that
the symbol names used in the compiler source may not match the
symbol names that would have been made by the stage1 compiler.
This can be important when using dynamic linking (e.g., with
derives). Sometimes this means that some tests don't work when run
with stage1.</li>
</ul>
</li>
<li><strong>Stage 2:</strong> we rebuild our stage1 compiler with itself to produce
the stage2 compiler (i.e. it builds itself) to have all the <em>latest
optimizations</em>. (By default, we copy the stage1 libraries for use by
the stage2 compiler, since they ought to be identical.)</li>
<li><em>(Optional)</em> <strong>Stage 3</strong>: to sanity check our new compiler, we
can build the libraries with the stage2 compiler. The result ought
to be identical to before, unless something has broken.</li>
</ul>
<p>To read more about the bootstrap process, <a href="building/./bootstrapping.html">read this chapter</a>.</p>
<h2><a class="header" href="#building-the-compiler" id="building-the-compiler">Building the Compiler</a></h2>
<p>To build a compiler, run <code>./x.py build</code>. This will do the whole bootstrapping
process described above, producing a usable compiler toolchain from the source
code you have checked out. This takes a long time, so it is not usually what
you want to actually run (more on this later).</p>
<p>There are many flags you can pass to the build command of <code>x.py</code> that can be
beneficial to cutting down compile times or fitting other things you might
need to change. They are:</p>
<pre><code class="language-txt">Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre>
<p>For hacking, often building the stage 1 compiler is enough, but for
final testing and release, the stage 2 compiler is used.</p>
<p><code>./x.py check</code> is really fast to build the rust compiler.
It is, in particular, very useful when you're doing some kind of
&quot;type-based refactoring&quot;, like renaming a method, or changing the
signature of some function.</p>
<p><a name=command></a></p>
<p>Once you've created a config.toml, you are now ready to run
<code>x.py</code>. There are a lot of options here, but let's start with what is
probably the best &quot;go to&quot; command for building a local rust:</p>
<pre><code class="language-bash">./x.py build -i --stage 1 src/libstd
</code></pre>
<p>This may <em>look</em> like it only builds <code>libstd</code>, but that is not the case.
What this command does is the following:</p>
<ul>
<li>Build <code>libstd</code> using the stage0 compiler (using incremental)</li>
<li>Build <code>librustc</code> using the stage0 compiler (using incremental)
<ul>
<li>This produces the stage1 compiler</li>
</ul>
</li>
<li>Build <code>libstd</code> using the stage1 compiler (cannot use incremental)</li>
</ul>
<p>This final product (stage1 compiler + libs built using that compiler)
is what you need to build other rust programs (unless you use <code>#![no_std]</code> or
<code>#![no_core]</code>).</p>
<p>The command includes the <code>-i</code> switch which enables incremental compilation.
This will be used to speed up the first two steps of the process:
in particular, if you make a small change, we ought to be able to use your old
results to make producing the stage1 <strong>compiler</strong> faster.</p>
<p>Unfortunately, incremental cannot be used to speed up making the
stage1 libraries.  This is because incremental only works when you run
the <em>same compiler</em> twice in a row.  In this case, we are building a
<em>new stage1 compiler</em> every time. Therefore, the old incremental
results may not apply. <strong>As a result, you will probably find that
building the stage1 <code>libstd</code> is a bottleneck for you</strong> -- but fear not,
there is a (hacky) workaround.  See <a href="building/./suggested.html">the section on &quot;recommended
workflows&quot;</a> below.</p>
<p>Note that this whole command just gives you a subset of the full <code>rustc</code>
build. The <strong>full</strong> <code>rustc</code> build (what you get if you just say <code>./x.py build</code>) has quite a few more steps:</p>
<ul>
<li>Build <code>librustc</code> and <code>rustc</code> with the stage1 compiler.
<ul>
<li>The resulting compiler here is called the &quot;stage2&quot; compiler.</li>
</ul>
</li>
<li>Build <code>libstd</code> with stage2 compiler.</li>
<li>Build <code>librustdoc</code> and a bunch of other things with the stage2 compiler.</li>
</ul>
<p><a name=toolchain></a></p>
<h2><a class="header" href="#build-specific-components" id="build-specific-components">Build specific components</a></h2>
<p>Build only the libcore library</p>
<pre><code class="language-bash">./x.py build src/libcore
</code></pre>
<p>Build the libcore and libproc_macro library only</p>
<pre><code class="language-bash">./x.py build src/libcore src/libproc_macro
</code></pre>
<p>Build only libcore up to Stage 1</p>
<pre><code class="language-bash">./x.py build src/libcore --stage 1
</code></pre>
<p>Sometimes you might just want to test if the part you’re working on can
compile. Using these commands you can test that it compiles before doing
a bigger build to make sure it works with the compiler. As shown before
you can also pass flags at the end such as --stage.</p>
<h2><a class="header" href="#creating-a-rustup-toolchain" id="creating-a-rustup-toolchain">Creating a rustup toolchain</a></h2>
<p>Once you have successfully built <code>rustc</code>, you will have created a bunch
of files in your <code>build</code> directory. In order to actually run the
resulting <code>rustc</code>, we recommend creating rustup toolchains. The first
one will run the stage1 compiler (which we built above). The second
will execute the stage2 compiler (which we did not build, but which
you will likely need to build at some point; for example, if you want
to run the entire test suite).</p>
<pre><code class="language-bash">rustup toolchain link stage1 build/&lt;host-triple&gt;/stage1
rustup toolchain link stage2 build/&lt;host-triple&gt;/stage2
</code></pre>
<p>The <code>&lt;host-triple&gt;</code> would typically be one of the following:</p>
<ul>
<li>Linux: <code>x86_64-unknown-linux-gnu</code></li>
<li>Mac: <code>x86_64-apple-darwin</code></li>
<li>Windows: <code>x86_64-pc-windows-msvc</code></li>
</ul>
<p>Now you can run the <code>rustc</code> you built with. If you run with <code>-vV</code>, you
should see a version number ending in <code>-dev</code>, indicating a build from
your local environment:</p>
<pre><code class="language-bash">$ rustc +stage1 -vV
rustc 1.25.0-dev
binary: rustc
commit-hash: unknown
commit-date: unknown
host: x86_64-unknown-linux-gnu
release: 1.25.0-dev
LLVM version: 4.0
</code></pre>
<h2><a class="header" href="#other-xpy-commands" id="other-xpy-commands">Other <code>x.py</code> commands</a></h2>
<p>Here are a few other useful <code>x.py</code> commands. We'll cover some of them in detail
in other sections:</p>
<ul>
<li>Building things:
<ul>
<li><code>./x.py clean</code> – clean up the build directory (<code>rm -rf build</code> works too,
but then you have to rebuild LLVM)</li>
<li><code>./x.py build --stage 1</code> – builds everything using the stage 1 compiler,
not just up to <code>libstd</code></li>
<li><code>./x.py build</code> – builds the stage2 compiler</li>
</ul>
</li>
<li>Running tests (see the <a href="building/../tests/running.html">section on running tests</a> for
more details):
<ul>
<li><code>./x.py test --stage 1 src/libstd</code> – runs the <code>#[test]</code> tests from <code>libstd</code></li>
<li><code>./x.py test --stage 1 src/test/ui</code> – runs the <code>ui</code> test suite</li>
<li><code>./x.py test --stage 1 src/test/ui/const-generics</code> - runs all the tests in
the <code>const-generics/</code> subdirectory of the <code>ui</code> test suite</li>
<li><code>./x.py test --stage 1 src/test/ui/const-generics/const-types.rs</code> - runs
the single test <code>const-types.rs</code> from the <code>ui</code> test suite</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#cleaning-out-build-directories" id="cleaning-out-build-directories">Cleaning out build directories</a></h3>
<p>Sometimes you need to start fresh, but this is normally not the case.
If you need to run this then <code>rustbuild</code> is most likely not acting right and
you should file a bug as to what is going wrong. If you do need to clean
everything up then you only need to run one command!</p>
<pre><code class="language-bash">./x.py clean
</code></pre>
<h1><a class="header" href="#suggested-workflows" id="suggested-workflows">Suggested Workflows</a></h1>
<p>The full bootstrapping process takes quite a while. Here are three suggestions
to make your life easier.</p>
<h2><a class="header" href="#check-check-and-check-again" id="check-check-and-check-again">Check, check, and check again</a></h2>
<p>The first workflow, which is useful
when doing simple refactorings, is to run <code>./x.py check</code>
continuously. Here you are just checking that the compiler can
<strong>build</strong>, but often that is all you need (e.g., when renaming a
method). You can then run <code>./x.py build</code> when you actually need to
run tests.</p>
<p>In fact, it is sometimes useful to put off tests even when you are not
100% sure the code will work. You can then keep building up
refactoring commits and only run the tests at some later time. You can
then use <code>git bisect</code> to track down <strong>precisely</strong> which commit caused
the problem. A nice side-effect of this style is that you are left
with a fairly fine-grained set of commits at the end, all of which
build and pass tests. This often helps reviewing.</p>
<h2><a class="header" href="#incremental-builds-with---keep-stage" id="incremental-builds-with---keep-stage">Incremental builds with <code>--keep-stage</code>.</a></h2>
<p>Sometimes just checking
whether the compiler builds is not enough. A common example is that
you need to add a <code>debug!</code> statement to inspect the value of some
state or better understand the problem. In that case, you really need
a full build.  By leveraging incremental, though, you can often get
these builds to complete very fast (e.g., around 30 seconds). The only
catch is this requires a bit of fudging and may produce compilers that
don't work (but that is easily detected and fixed).</p>
<p>The sequence of commands you want is as follows:</p>
<ul>
<li>Initial build: <code>./x.py build -i --stage 1 src/libstd</code>
<ul>
<li>As <a href="building/suggested.html#command">documented above</a>, this will build a functional
stage1 compiler as part of running all stage0 commands (which include
building a <code>libstd</code> compatible with the stage1 compiler) as well as the
first few steps of the &quot;stage 1 actions&quot; up to &quot;stage1 (sysroot stage1)
builds libstd&quot;.</li>
</ul>
</li>
<li>Subsequent builds: <code>./x.py build -i --stage 1 src/libstd --keep-stage 1</code>
<ul>
<li>Note that we added the <code>--keep-stage 1</code> flag here</li>
</ul>
</li>
</ul>
<p>As mentioned, the effect of <code>--keep-stage 1</code> is that we just <em>assume</em> that the
old standard library can be re-used. If you are editing the compiler, this
is almost always true: you haven't changed the standard library, after
all.  But sometimes, it's not true: for example, if you are editing
the &quot;metadata&quot; part of the compiler, which controls how the compiler
encodes types and other states into the <code>rlib</code> files, or if you are
editing things that wind up in the metadata (such as the definition of
the MIR).</p>
<p><strong>The TL;DR is that you might get weird behavior from a compile when
using <code>--keep-stage 1</code></strong> -- for example, strange
<a href="building/../appendix/glossary.html#ice">ICEs</a> or other panics. In that case, you
should simply remove the <code>--keep-stage 1</code> from the command and
rebuild.  That ought to fix the problem.</p>
<p>You can also use <code>--keep-stage 1</code> when running tests. Something like this:</p>
<ul>
<li>Initial test run: <code>./x.py test -i --stage 1 src/test/ui</code></li>
<li>Subsequent test run: <code>./x.py test -i --stage 1 src/test/ui --keep-stage 1</code></li>
</ul>
<h2><a class="header" href="#building-with-system-llvm" id="building-with-system-llvm">Building with system LLVM</a></h2>
<p>By default, LLVM is built from source, and that can take significant amount of
time.  An alternative is to use LLVM already installed on your computer.</p>
<p>This is specified in the <code>target</code> section of <code>config.toml</code>:</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu]
llvm-config = &quot;/path/to/llvm/llvm-7.0.1/bin/llvm-config&quot;
</code></pre>
<p>We have observed the following paths before, which may be different from your system:</p>
<ul>
<li><code>/usr/bin/llvm-config-8</code></li>
<li><code>/usr/lib/llvm-8/bin/llvm-config</code></li>
</ul>
<p>Note that you need to have the LLVM <code>FileCheck</code> tool installed, which is used
for codegen tests. This tool is normally built with LLVM, but if you use your
own preinstalled LLVM, you will need to provide <code>FileCheck</code> in some other way.
On Debian-based systems, you can install the <code>llvm-N-tools</code> package (where <code>N</code>
is the LLVM version number, e.g. <code>llvm-8-tools</code>).  Alternately, you can specify
the path to <code>FileCheck</code> with the <code>llvm-filecheck</code> config item in <code>config.toml</code>
or you can disable codegen test with the <code>codegen-tests</code> item in <code>config.toml</code>.</p>
<h1><a class="header" href="#bootstrapping-the-compiler" id="bootstrapping-the-compiler">Bootstrapping the Compiler</a></h1>
<p>This subchapter is about the bootstrapping process.</p>
<p>When running <code>x.py</code> you will see output such as:</p>
<pre><code class="language-txt">Building stage0 std artifacts
Copying stage0 std from stage0
Building stage0 compiler artifacts
Copying stage0 rustc from stage0
Building LLVM for x86_64-apple-darwin
Building stage0 codegen artifacts
Assembling stage1 compiler
Building stage1 std artifacts
Copying stage1 std from stage1
Building stage1 compiler artifacts
Copying stage1 rustc from stage1
Building stage1 codegen artifacts
Assembling stage2 compiler
Uplifting stage1 std
Copying stage2 std from stage1
Generating unstable book md files
Building stage0 tool unstable-book-gen
Building stage0 tool rustbook
Documenting standalone
Building rustdoc for stage2
Documenting book redirect pages
Documenting stage2 std
Building rustdoc for stage1
Documenting stage2 whitelisted compiler
Documenting stage2 compiler
Documenting stage2 rustdoc
Documenting error index
Uplifting stage1 rustc
Copying stage2 rustc from stage1
Building stage2 tool error_index_generator
</code></pre>
<p>A deeper look into <code>x.py</code>'s phases can be seen here:</p>
<img alt="A diagram of the rustc compilation phases" src="building/../img/rustc_stages.svg" class="center" />
<p>Keep in mind this diagram is a simplification, i.e. <code>rustdoc</code> can be built at
different stages, the process is a bit different when passing flags such as
<code>--keep-stage</code>, or if there are non-host targets.</p>
<p>The following tables indicate the outputs of various stage actions:</p>
<table><thead><tr><th>Stage 0 Action</th><th>Output</th></tr></thead><tbody>
<tr><td><code>beta</code> extracted</td><td><code>build/HOST/stage0</code></td></tr>
<tr><td><code>stage0</code> builds <code>bootstrap</code></td><td><code>build/bootstrap</code></td></tr>
<tr><td><code>stage0</code> builds <code>libstd</code></td><td><code>build/HOST/stage0-std/TARGET</code></td></tr>
<tr><td>copy <code>stage0-std</code> (HOST only)</td><td><code>build/HOST/stage0-sysroot/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage0</code> builds <code>rustc</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-rustc/HOST</code></td></tr>
<tr><td>copy <code>stage0-rustc (except executable)</code></td><td><code>build/HOST/stage0-sysroot/lib/rustlib/HOST</code></td></tr>
<tr><td>build <code>llvm</code></td><td><code>build/HOST/llvm</code></td></tr>
<tr><td><code>stage0</code> builds <code>codegen</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-codegen/HOST</code></td></tr>
<tr><td><code>stage0</code> builds <code>rustdoc</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-tools/HOST</code></td></tr>
</tbody></table>
<p><code>--stage=0</code> stops here.</p>
<table><thead><tr><th>Stage 1 Action</th><th>Output</th></tr></thead><tbody>
<tr><td>copy (uplift) <code>stage0-rustc</code> executable to <code>stage1</code></td><td><code>build/HOST/stage1/bin</code></td></tr>
<tr><td>copy (uplift) <code>stage0-codegen</code> to <code>stage1</code></td><td><code>build/HOST/stage1/lib</code></td></tr>
<tr><td>copy (uplift) <code>stage0-sysroot</code> to <code>stage1</code></td><td><code>build/HOST/stage1/lib</code></td></tr>
<tr><td><code>stage1</code> builds <code>libstd</code></td><td><code>build/HOST/stage1-std/TARGET</code></td></tr>
<tr><td>copy <code>stage1-std</code> (HOST only)</td><td><code>build/HOST/stage1/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage1</code> builds <code>rustc</code></td><td><code>build/HOST/stage1-rustc/HOST</code></td></tr>
<tr><td>copy <code>stage1-rustc</code> (except executable)</td><td><code>build/HOST/stage1/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage1</code> builds <code>codegen</code></td><td><code>build/HOST/stage1-codegen/HOST</code></td></tr>
</tbody></table>
<p><code>--stage=1</code> stops here.</p>
<table><thead><tr><th>Stage 2 Action</th><th>Output</th></tr></thead><tbody>
<tr><td>copy (uplift) <code>stage1-rustc</code> executable</td><td><code>build/HOST/stage2/bin</code></td></tr>
<tr><td>copy (uplift) <code>stage1-sysroot</code></td><td><code>build/HOST/stage2/lib and build/HOST/stage2/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage2</code> builds <code>libstd</code> (except HOST?)</td><td><code>build/HOST/stage2-std/TARGET</code></td></tr>
<tr><td>copy <code>stage2-std</code> (not HOST targets)</td><td><code>build/HOST/stage2/lib/rustlib/TARGET</code></td></tr>
<tr><td><code>stage2</code> builds <code>rustdoc</code></td><td><code>build/HOST/stage2-tools/HOST</code></td></tr>
<tr><td>copy <code>rustdoc</code></td><td><code>build/HOST/stage2/bin</code></td></tr>
</tbody></table>
<p><code>--stage=2</code> stops here.</p>
<p>Note that the convention <code>x.py</code> uses is that:</p>
<ul>
<li>A &quot;stage N artifact&quot; is an artifact that is <em>produced</em> by the stage N compiler.</li>
<li>The &quot;stage (N+1) compiler&quot; is assembled from &quot;stage N artifacts&quot;.</li>
<li>A <code>--stage N</code> flag means build <em>with</em> stage N.</li>
</ul>
<p>In short, <em>stage 0 uses the stage0 compiler to create stage0 artifacts which
will later be uplifted to stage1</em>.</p>
<p>Every time any of the main artifacts (<code>std</code> and <code>rustc</code>) are compiled, two
steps are performed.
When <code>std</code> is compiled by a stage N compiler, that <code>std</code> will be linked to
programs built by the stage N compiler (including <code>rustc</code> built later
on). It will also be used by the stage (N+1) compiler to link against itself.
This is somewhat intuitive if one thinks of the stage (N+1) compiler as &quot;just&quot;
another program we are building with the stage N compiler. In some ways, <code>rustc</code>
(the binary, not the <code>rustbuild</code> step) could be thought of as one of the few
<code>no_core</code> binaries out there.</p>
<p>So &quot;stage0 std artifacts&quot; are in fact the output of the downloaded stage0
compiler, and are going to be used for anything built by the stage0 compiler:
e.g. <code>rustc</code> artifacts. When it announces that it is &quot;building stage1
std artifacts&quot; it has moved on to the next bootstrapping phase. This pattern
continues in latter stages.</p>
<p>Also note that building host <code>std</code> and target <code>std</code> are different based on the
stage (e.g. see in the table how stage2 only builds non-host <code>std</code> targets.
This is because during stage2, the host <code>std</code> is uplifted from the &quot;stage 1&quot;
<code>std</code> -- specifically, when &quot;Building stage 1 artifacts&quot; is announced, it is
later copied into stage2 as well (both the compiler's <code>libdir</code> and the
<code>sysroot</code>).</p>
<p>This <code>std</code> is pretty much necessary for any useful work with the compiler.
Specifically, it's used as the <code>std</code> for programs compiled by the newly compiled
compiler (so when you compile <code>fn main() { }</code> it is linked to the last <code>std</code>
compiled with <code>x.py build --stage 1 src/libstd</code>).</p>
<p>The <code>rustc</code> generated by the stage0 compiler is linked to the freshly-built
<code>libstd</code>, which means that for the most part only <code>std</code> needs to be cfg-gated,
so that <code>rustc</code> can use featured added to std immediately after their addition,
without need for them to get into the downloaded beta. The <code>libstd</code> built by the
<code>stage1/bin/rustc</code> compiler, also known as &quot;stage1 std artifacts&quot;, is not
necessarily ABI-compatible with that compiler.
That is, the <code>rustc</code> binary most likely could not use this <code>std</code> itself.
It is however ABI-compatible with any programs that the <code>stage1/bin/rustc</code>
binary builds (including itself), so in that sense they're paired.</p>
<p>This is also where <code>--keep-stage 1 src/libstd</code> comes into play. Since most
changes to the compiler don't actually change the ABI, once you've produced a
<code>libstd</code> in stage 1, you can probably just reuse it with a different compiler.
If the ABI hasn't changed, you're good to go, no need to spend the time
recompiling that <code>std</code>.
<code>--keep-stage</code> simply assumes the previous compile is fine and copies those
artifacts into the appropriate place, skipping the cargo invocation.</p>
<p>The reason we first build <code>std</code>, then <code>rustc</code>, is largely just
because we want to minimize <code>cfg(stage0)</code> in the code for <code>rustc</code>.
Currently <code>rustc</code> is always linked against a &quot;new&quot; <code>std</code> so it doesn't
ever need to be concerned with differences in std; it can assume that the std is
as fresh as possible.</p>
<p>The reason we need to build it twice is because of ABI compatibility.
The beta compiler has it's own ABI, and then the <code>stage1/bin/rustc</code> compiler
will produce programs/libraries with the new ABI.
We used to build three times, but because we assume that the ABI is constant
within a codebase, we presume that the libraries produced by the &quot;stage2&quot;
compiler (produced by the <code>stage1/bin/rustc</code> compiler) is ABI-compatible with
the <code>stage1/bin/rustc</code> compiler's produced libraries.
What this means is that we can skip that final compilation -- and simply use the
same libraries as the <code>stage2/bin/rustc</code> compiler uses itself for programs it
links against.</p>
<p>This <code>stage2/bin/rustc</code> compiler is shipped to end-users, along with the
<code>stage 1 {std,rustc}</code> artifacts.</p>
<h2><a class="header" href="#environment-variables" id="environment-variables">Environment Variables</a></h2>
<p>During bootstrapping, there are a bunch of compiler-internal environment
variables that are used. If you are trying to run an intermediate version of
<code>rustc</code>, sometimes you may need to set some of these environment variables
manually. Otherwise, you get an error like the following:</p>
<pre><code class="language-text">thread 'main' panicked at 'RUSTC_STAGE was not set: NotPresent', src/libcore/result.rs:1165:5
</code></pre>
<p>If <code>./stageN/bin/rustc</code> gives an error about environment variables, that
usually means something is quite wrong -- or you're trying to compile e.g.
<code>librustc</code> or <code>libstd</code> or something that depends on environment variables. In
the unlikely case that you actually need to invoke rustc in such a situation,
you can find the environment variable values by adding the following flag to
your <code>x.py</code> command: <code>--on-fail=print-env</code>.</p>
<h1><a class="header" href="#build-distribution-artifacts" id="build-distribution-artifacts">Build distribution artifacts</a></h1>
<p>You might want to build and package up the compiler for distribution.
You’ll want to run this command to do it:</p>
<pre><code class="language-bash">./x.py dist
</code></pre>
<h1><a class="header" href="#install-distribution-artifacts" id="install-distribution-artifacts">Install distribution artifacts</a></h1>
<p>If you’ve built a distribution artifact you might want to install it and
test that it works on your target system. You’ll want to run this command:</p>
<pre><code class="language-bash">./x.py install
</code></pre>
<p>Note: If you are testing out a modification to a compiler, you
might want to use it to compile some project.
Usually, you do not want to use ./x.py install for testing.
Rather, you should create a toolchain as discussed in
<a href="building/./how-to-build-and-run.html#creating-a-rustup-toolchain">here</a>.</p>
<p>For example, if the toolchain you created is called foo, you
would then invoke it with <code>rustc +foo ...</code> (where ... represents
the rest of the arguments).</p>
<h1><a class="header" href="#documenting-rustc" id="documenting-rustc">Documenting rustc</a></h1>
<p>You might want to build documentation of the various components
available like the standard library. There’s two ways to go about this.
You can run rustdoc directly on the file to make sure the HTML is
correct, which is fast. Alternatively, you can build the documentation
as part of the build process through x.py. Both are viable methods
since documentation is more about the content.</p>
<h2><a class="header" href="#document-everything" id="document-everything">Document everything</a></h2>
<pre><code class="language-bash">./x.py doc
</code></pre>
<h2><a class="header" href="#if-you-want-to-avoid-the-whole-stage-2-build" id="if-you-want-to-avoid-the-whole-stage-2-build">If you want to avoid the whole Stage 2 build</a></h2>
<pre><code class="language-bash">./x.py doc --stage 1
</code></pre>
<p>First the compiler and rustdoc get built to make sure everything is okay
and then it documents the files.</p>
<h2><a class="header" href="#document-specific-components" id="document-specific-components">Document specific components</a></h2>
<pre><code class="language-bash">./x.py doc src/doc/book
./x.py doc src/doc/nomicon
./x.py doc src/doc/book src/libstd
</code></pre>
<p>Much like individual tests or building certain components you can build only
the documentation you want.</p>
<h2><a class="header" href="#document-internal-rustc-items" id="document-internal-rustc-items">Document internal rustc items</a></h2>
<p>Compiler documentation is not built by default. To enable it, modify config.toml:</p>
<pre><code class="language-toml">[build]
compiler-docs = true
</code></pre>
<p>Note that when enabled,
documentation for internal compiler items will also be built.</p>
<h3><a class="header" href="#compiler-documentation" id="compiler-documentation">Compiler Documentation</a></h3>
<p>The documentation for the rust components are found at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/">rustc doc</a>.</p>
<h1><a class="header" href="#ctags" id="ctags">ctags</a></h1>
<p>One of the challenges with rustc is that the RLS can't handle it, since it's a
bootstrapping compiler. This makes code navigation difficult. One solution is to
use <code>ctags</code>.</p>
<p><code>ctags</code> has a long history and several variants. Exuberant Ctags seems to be
quite commonly distributed but it does not have out-of-box Rust support. Some
distributions seem to use <a href="https://github.com/universal-ctags/ctags">Universal Ctags</a>, which is a maintained fork
and does have built-in Rust support.</p>
<p>The following script can be used to set up Exuberant Ctags:
<a href="https://github.com/nikomatsakis/rust-etags">https://github.com/nikomatsakis/rust-etags</a>.</p>
<p><code>ctags</code> integrates into emacs and vim quite easily. The following can then be
used to build and generate tags:</p>
<pre><code class="language-console">$ rust-ctags src/lib* &amp;&amp; ./x.py build &lt;something&gt;
</code></pre>
<p>This allows you to do &quot;jump-to-def&quot; with whatever functions were around when
you last built, which is ridiculously useful.</p>
<h1><a class="header" href="#the-compiler-testing-framework" id="the-compiler-testing-framework">The compiler testing framework</a></h1>
<p>The Rust project runs a wide variety of different tests, orchestrated by
the build system (<code>x.py test</code>).  The main test harness for testing the
compiler itself is a tool called compiletest (located in the
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest"><code>src/tools/compiletest</code></a> directory). This section gives a brief
overview of how the testing framework is setup, and then gets into some
of the details on <a href="tests/./running.html">how to run tests</a> as well as <a href="tests/./adding.html">how to
add new tests</a>.</p>
<h2><a class="header" href="#compiletest-test-suites" id="compiletest-test-suites">Compiletest test suites</a></h2>
<p>The compiletest tests are located in the tree in the <a href="https://github.com/rust-lang/rust/tree/master/src/test"><code>src/test</code></a>
directory. Immediately within you will see a series of subdirectories
(e.g. <code>ui</code>, <code>run-make</code>, and so forth). Each of those directories is
called a <strong>test suite</strong> – they house a group of tests that are run in
a distinct mode.</p>
<p>Here is a brief summary of the test suites and what they mean. In some
cases, the test suites are linked to parts of the manual that give more
details.</p>
<ul>
<li><a href="tests/./adding.html#ui"><code>ui</code></a> – tests that check the exact
stdout/stderr from compilation and/or running the test</li>
<li><code>run-pass-valgrind</code> – tests that ought to run with valgrind</li>
<li><code>run-fail</code> – tests that are expected to compile but then panic
during execution</li>
<li><code>compile-fail</code> – tests that are expected to fail compilation.</li>
<li><code>parse-fail</code> – tests that are expected to fail to parse</li>
<li><code>pretty</code> – tests targeting the Rust &quot;pretty printer&quot;, which
generates valid Rust code from the AST</li>
<li><code>debuginfo</code> – tests that run in gdb or lldb and query the debug info</li>
<li><code>codegen</code> – tests that compile and then test the generated LLVM
code to make sure that the optimizations we want are taking effect.
See <a href="https://llvm.org/docs/CommandGuide/FileCheck.html">LLVM docs</a> for how to
write such tests.</li>
<li><code>assembly</code> – similar to <code>codegen</code> tests, but verifies assembly output
to make sure LLVM target backend can handle provided code.</li>
<li><code>mir-opt</code> – tests that check parts of the generated MIR to make
sure we are building things correctly or doing the optimizations we
expect.</li>
<li><code>incremental</code> – tests for incremental compilation, checking that
when certain modifications are performed, we are able to reuse the
results from previous compilations.</li>
<li><code>run-make</code> – tests that basically just execute a <code>Makefile</code>; the
ultimate in flexibility but quite annoying to write.</li>
<li><code>rustdoc</code> – tests for rustdoc, making sure that the generated files
contain the expected documentation.</li>
<li><code>*-fulldeps</code> – same as above, but indicates that the test depends
on things other than <code>libstd</code> (and hence those things must be built)</li>
</ul>
<h2><a class="header" href="#other-tests" id="other-tests">Other Tests</a></h2>
<p>The Rust build system handles running tests for various other things,
including:</p>
<ul>
<li>
<p><strong>Tidy</strong> – This is a custom tool used for validating source code
style and formatting conventions, such as rejecting long lines.
There is more information in the
<a href="tests/../conventions.html#formatting">section on coding conventions</a>.</p>
<p>Example: <code>./x.py test tidy</code></p>
</li>
<li>
<p><strong>Formatting</strong> – Rustfmt is integrated with the build system to enforce
uniform style across the compiler. In the CI, we check that the formatting
is correct. The formatting check is also automatically run by the Tidy tool
mentioned above.</p>
<p>Example: <code>./x.py fmt --check</code> checks formatting an exits with an error if
formatting is needed.</p>
<p>Example: <code>./x.py fmt</code> runs rustfmt on the codebase.</p>
<p>Example: <code>./x.py test tidy --bless</code> does formatting before doing
other tidy checks.</p>
</li>
<li>
<p><strong>Unit tests</strong> – The Rust standard library and many of the Rust packages
include typical Rust <code>#[test]</code> unittests.  Under the hood, <code>x.py</code> will run
<code>cargo test</code> on each package to run all the tests.</p>
<p>Example: <code>./x.py test src/libstd</code></p>
</li>
<li>
<p><strong>Doc tests</strong> – Example code embedded within Rust documentation is executed
via <code>rustdoc --test</code>.  Examples:</p>
<p><code>./x.py test src/doc</code> – Runs <code>rustdoc --test</code> for all documentation in
<code>src/doc</code>.</p>
<p><code>./x.py test --doc src/libstd</code> – Runs <code>rustdoc --test</code> on the standard
library.</p>
</li>
<li>
<p><strong>Link checker</strong> – A small tool for verifying <code>href</code> links within
documentation.</p>
<p>Example: <code>./x.py test src/tools/linkchecker</code></p>
</li>
<li>
<p><strong>Dist check</strong> – This verifies that the source distribution tarball created
by the build system will unpack, build, and run all tests.</p>
<p>Example: <code>./x.py test distcheck</code></p>
</li>
<li>
<p><strong>Tool tests</strong> – Packages that are included with Rust have all of their
tests run as well (typically by running <code>cargo test</code> within their
directory).  This includes things such as cargo, clippy, rustfmt, rls, miri,
bootstrap (testing the Rust build system itself), etc.</p>
</li>
<li>
<p><strong>Cargo test</strong> – This is a small tool which runs <code>cargo test</code> on a few
significant projects (such as <code>servo</code>, <code>ripgrep</code>, <code>tokei</code>, etc.) just to
ensure there aren't any significant regressions.</p>
<p>Example: <code>./x.py test src/tools/cargotest</code></p>
</li>
</ul>
<h2><a class="header" href="#testing-infrastructure" id="testing-infrastructure">Testing infrastructure</a></h2>
<p>When a Pull Request is opened on Github, <a href="https://dev.azure.com/rust-lang/rust/">Azure Pipelines</a> will automatically
launch a build that will run all tests on some configurations
(x86_64-gnu-llvm-6.0 linux. x86_64-gnu-tools linux, mingw-check linux). In
essence, it runs <code>./x.py test</code> after building for each of them.</p>
<p>The integration bot <a href="https://github.com/servo/homu">bors</a> is used for coordinating merges to the master
branch. When a PR is approved, it goes into a <a href="https://buildbot2.rust-lang.org/homu/queue/rust">queue</a> where merges are tested
one at a time on a wide set of platforms using Azure Pipelines (currently over
50 different configurations). Most platforms only run the build steps, some run
a restricted set of tests, only a subset run the full suite of tests (see
Rust's <a href="https://forge.rust-lang.org/release/platform-support.html#rust-platform-support">platform tiers</a>).</p>
<h2><a class="header" href="#testing-with-docker-images" id="testing-with-docker-images">Testing with Docker images</a></h2>
<p>The Rust tree includes <a href="https://www.docker.com/">Docker</a> image definitions for the platforms used on
Azure Pipelines in <a href="https://github.com/rust-lang/rust/tree/master/src/ci/docker">src/ci/docker</a>.  The script <a href="https://github.com/rust-lang/rust/blob/master/src/ci/docker/run.sh">src/ci/docker/run.sh</a> is used to build
the Docker image, run it, build Rust within the image, and run the tests.</p>
<blockquote>
<p>TODO: What is a typical workflow for testing/debugging on a platform that
you don't have easy access to?  Do people build Docker images and enter them
to test things out?</p>
</blockquote>
<h2><a class="header" href="#testing-on-emulators" id="testing-on-emulators">Testing on emulators</a></h2>
<p>Some platforms are tested via an emulator for architectures that aren't
readily available.  There is a set of tools for orchestrating running the
tests within the emulator.  Platforms such as <code>arm-android</code> and
<code>arm-unknown-linux-gnueabihf</code> are set up to automatically run the tests under
emulation on Travis.  The following will take a look at how a target's tests
are run under emulation.</p>
<p>The Docker image for <a href="https://github.com/rust-lang/rust/tree/master/src/ci/docker/armhf-gnu">armhf-gnu</a> includes <a href="https://www.qemu.org/">QEMU</a> to emulate the ARM CPU
architecture.  Included in the Rust tree are the tools <a href="https://github.com/rust-lang/rust/tree/master/src/tools/remote-test-client">remote-test-client</a>
and <a href="https://github.com/rust-lang/rust/tree/master/src/tools/remote-test-server">remote-test-server</a> which are programs for sending test programs and
libraries to the emulator, and running the tests within the emulator, and
reading the results.  The Docker image is set up to launch
<code>remote-test-server</code> and the build tools use <code>remote-test-client</code> to
communicate with the server to coordinate running tests (see
<a href="https://github.com/rust-lang/rust/tree/master/src/bootstrap/test.rs">src/bootstrap/test.rs</a>).</p>
<blockquote>
<p>TODO: What are the steps for manually running tests within an emulator?
<code>./src/ci/docker/run.sh armhf-gnu</code> will do everything, but takes hours to
run and doesn't offer much help with interacting within the emulator.</p>
<p>Is there any support for emulating other (non-Android) platforms, such as
running on an iOS emulator?</p>
<p>Is there anything else interesting that can be said here about running tests
remotely on real hardware?</p>
<p>It's also unclear to me how the wasm or asm.js tests are run.</p>
</blockquote>
<h2><a class="header" href="#crater" id="crater">Crater</a></h2>
<p><a href="https://github.com/rust-lang/crater">Crater</a> is a tool for compiling
and running tests for <em>every</em> crate on <a href="https://crates.io">crates.io</a> (and a
few on GitHub). It is mainly used for checking for extent of breakage when
implementing potentially breaking changes and ensuring lack of breakage by
running beta vs stable compiler versions.</p>
<h3><a class="header" href="#when-to-run-crater" id="when-to-run-crater">When to run Crater</a></h3>
<p>You should request a crater run if your PR makes large changes to the compiler
or could cause breakage. If you are unsure, feel free to ask your PR's reviewer.</p>
<h3><a class="header" href="#requesting-crater-runs" id="requesting-crater-runs">Requesting Crater Runs</a></h3>
<p>The rust team maintains a few machines that can be used for running crater runs
on the changes introduced by a PR. If your PR needs a crater run, leave a
comment for the triage team in the PR thread. Please inform the team whether
you require a &quot;check-only&quot; crater run, a &quot;build only&quot; crater run, or a
&quot;build-and-test&quot; crater run. The difference is primarily in time; the
conservative (if you're not sure) option is to go for the build-and-test run.
If making changes that will only have an effect at compile-time (e.g.,
implementing a new trait) then you only need a check run.</p>
<p>Your PR will be enqueued by the triage team and the results will be posted when
they are ready. Check runs will take around ~3-4 days, with the other two
taking 5-6 days on average.</p>
<p>While crater is really useful, it is also important to be aware of a few
caveats:</p>
<ul>
<li>
<p>Not all code is on crates.io! There is a lot of code in repos on GitHub and
elsewhere. Also, companies may not wish to publish their code. Thus, a
successful crater run is not a magically green light that there will be no
breakage; you still need to be careful.</p>
</li>
<li>
<p>Crater only runs Linux builds on x86_64. Thus, other architectures and
platforms are not tested. Critically, this includes Windows.</p>
</li>
<li>
<p>Many crates are not tested. This could be for a lot of reasons, including
that the crate doesn't compile any more (e.g. used old nightly features),
has broken or flaky tests, requires network access, or other reasons.</p>
</li>
<li>
<p>Before crater can be run, <code>@bors try</code> needs to succeed in building artifacts.
This means that if your code doesn't compile, you cannot run crater.</p>
</li>
</ul>
<h2><a class="header" href="#perf-runs" id="perf-runs">Perf runs</a></h2>
<p>A lot of work is put into improving the performance of the compiler and
preventing performance regressions. A &quot;perf run&quot; is used to compare the
performance of the compiler in different configurations for a large collection
of popular crates. Different configurations include &quot;fresh builds&quot;, builds
with incremental compilation, etc.</p>
<p>The result of a perf run is a comparison between two versions of the
compiler (by their commit hashes).</p>
<p>You should request a perf run if your PR may affect performance, especially
if it can affect performance adversely.</p>
<h2><a class="header" href="#further-reading" id="further-reading">Further reading</a></h2>
<p>The following blog posts may also be of interest:</p>
<ul>
<li>brson's classic <a href="https://brson.github.io/2017/07/10/how-rust-is-tested">&quot;How Rust is tested&quot;</a></li>
</ul>
<h1><a class="header" href="#running-tests" id="running-tests">Running tests</a></h1>
<p>You can run the tests using <code>x.py</code>. The most basic command – which
you will almost never want to use! – is as follows:</p>
<pre><code class="language-bash">./x.py test
</code></pre>
<p>This will build the full stage 2 compiler and then run the whole test
suite. You probably don't want to do this very often, because it takes
a very long time, and anyway bors / travis will do it for you. (Often,
I will run this command in the background after opening a PR that I
think is done, but rarely otherwise. -nmatsakis)</p>
<p>The test results are cached and previously successful tests are
<code>ignored</code> during testing. The stdout/stderr contents as well as a
timestamp file for every test can be found under <code>build/ARCH/test/</code>.
To force-rerun a test (e.g. in case the test runner fails to notice
a change) you can simply remove the timestamp file.</p>
<p>Note that some tests require a Python-enabled gdb. You can test if
your gdb install supports Python by using the <code>python</code> command from
within gdb. Once invoked you can type some Python code (e.g.
<code>print(&quot;hi&quot;)</code>) followed by return and then <code>CTRL+D</code> to execute it.
If you are building gdb from source, you will need to configure with
<code>--with-python=&lt;path-to-python-binary&gt;</code>.</p>
<h2><a class="header" href="#running-a-subset-of-the-test-suites" id="running-a-subset-of-the-test-suites">Running a subset of the test suites</a></h2>
<p>When working on a specific PR, you will usually want to run a smaller
set of tests, and with a stage 1 build. For example, a good &quot;smoke
test&quot; that can be used after modifying rustc to see if things are
generally working correctly would be the following:</p>
<pre><code class="language-bash">./x.py test --stage 1 src/test/{ui,compile-fail}
</code></pre>
<p>This will run the <code>ui</code> and <code>compile-fail</code> test suites,
and only with the stage 1 build. Of course, the choice of test suites
is somewhat arbitrary, and may not suit the task you are doing. For
example, if you are hacking on debuginfo, you may be better off with
the debuginfo test suite:</p>
<pre><code class="language-bash">./x.py test --stage 1 src/test/debuginfo
</code></pre>
<p>If you only need to test a specific subdirectory of tests for any
given test suite, you can pass that directory to <code>x.py test</code>:</p>
<pre><code class="language-bash">./x.py test --stage 1 src/test/ui/const-generics
</code></pre>
<p>Likewise, you can test a single file by passing its path:</p>
<pre><code class="language-bash">./x.py test --stage 1 src/test/ui/const-generics/const-test.rs
</code></pre>
<h3><a class="header" href="#run-only-the-tidy-script" id="run-only-the-tidy-script">Run only the tidy script</a></h3>
<pre><code class="language-bash">./x.py test tidy
</code></pre>
<h3><a class="header" href="#run-tests-on-the-standard-library" id="run-tests-on-the-standard-library">Run tests on the standard library</a></h3>
<pre><code class="language-bash">./x.py test src/libstd
</code></pre>
<h3><a class="header" href="#run-the-tidy-script-and-tests-on-the-standard-library" id="run-the-tidy-script-and-tests-on-the-standard-library">Run the tidy script and tests on the standard library</a></h3>
<pre><code class="language-bash">./x.py test tidy src/libstd
</code></pre>
<h3><a class="header" href="#run-tests-on-the-standard-library-using-a-stage-1-compiler" id="run-tests-on-the-standard-library-using-a-stage-1-compiler">Run tests on the standard library using a stage 1 compiler</a></h3>
<pre><code class="language-bash">&gt;   ./x.py test src/libstd --stage 1
</code></pre>
<p>By listing which test suites you want to run you avoid having to run
tests for components you did not change at all.</p>
<p><strong>Warning:</strong> Note that bors only runs the tests with the full stage 2
build; therefore, while the tests <strong>usually</strong> work fine with stage 1,
there are some limitations.</p>
<h2><a class="header" href="#running-an-individual-test" id="running-an-individual-test">Running an individual test</a></h2>
<p>Another common thing that people want to do is to run an <strong>individual
test</strong>, often the test they are trying to fix. As mentioned earlier,
you may pass the full file path to achieve this, or alternatively one
may invoke <code>x.py</code> with the <code>--test-args</code> option:</p>
<pre><code class="language-bash">./x.py test --stage 1 src/test/ui --test-args issue-1234
</code></pre>
<p>Under the hood, the test runner invokes the standard rust test runner
(the same one you get with <code>#[test]</code>), so this command would wind up
filtering for tests that include &quot;issue-1234&quot; in the name. (Thus
<code>--test-args</code> is a good way to run a collection of related tests.)</p>
<h2><a class="header" href="#editing-and-updating-the-reference-files" id="editing-and-updating-the-reference-files">Editing and updating the reference files</a></h2>
<p>If you have changed the compiler's output intentionally, or you are
making a new test, you can pass <code>--bless</code> to the test subcommand. E.g.
if some tests in <code>src/test/ui</code> are failing, you can run</p>
<pre><code class="language-text">./x.py test --stage 1 src/test/ui --bless
</code></pre>
<p>to automatically adjust the <code>.stderr</code>, <code>.stdout</code> or <code>.fixed</code> files of
all tests. Of course you can also target just specific tests with the
<code>--test-args your_test_name</code> flag, just like when running the tests.</p>
<h2><a class="header" href="#passing---pass-mode" id="passing---pass-mode">Passing <code>--pass $mode</code></a></h2>
<p>Pass UI tests now have three modes, <code>check-pass</code>, <code>build-pass</code> and
<code>run-pass</code>. When <code>--pass $mode</code> is passed, these tests will be forced
to run under the given <code>$mode</code> unless the directive <code>// ignore-pass</code>
exists in the test file. For example, you can run all the tests in
<code>src/test/ui</code> as <code>check-pass</code>:</p>
<pre><code class="language-bash">./x.py test --stage 1 src/test/ui --pass check
</code></pre>
<p>By passing <code>--pass $mode</code>, you can reduce the testing time. For each
mode, please see <a href="tests/./adding.html#tests-that-do-not-result-in-compile-errors">here</a>.</p>
<h2><a class="header" href="#using-incremental-compilation" id="using-incremental-compilation">Using incremental compilation</a></h2>
<p>You can further enable the <code>--incremental</code> flag to save additional
time in subsequent rebuilds:</p>
<pre><code class="language-bash">./x.py test --stage 1 src/test/ui --incremental --test-args issue-1234
</code></pre>
<p>If you don't want to include the flag with every command, you can
enable it in the <code>config.toml</code>:</p>
<pre><code class="language-toml">[rust]
incremental = true
</code></pre>
<p>Note that incremental compilation will use more disk space than usual.
If disk space is a concern for you, you might want to check the size
of the <code>build</code> directory from time to time.</p>
<h2><a class="header" href="#running-tests-manually" id="running-tests-manually">Running tests manually</a></h2>
<p>Sometimes it's easier and faster to just run the test by hand. Most tests are
just <code>rs</code> files, so you can do something like</p>
<pre><code class="language-bash">rustc +stage1 src/test/ui/issue-1234.rs
</code></pre>
<p>This is much faster, but doesn't always work. For example, some tests
include directives that specify specific compiler flags, or which rely
on other crates, and they may not run the same without those options.</p>
<h1><a class="header" href="#adding-new-tests" id="adding-new-tests">Adding new tests</a></h1>
<p><strong>In general, we expect every PR that fixes a bug in rustc to come
accompanied by a regression test of some kind.</strong> This test should fail
in master but pass after the PR. These tests are really useful for
preventing us from repeating the mistakes of the past.</p>
<p>To add a new test, the first thing you generally do is to create a
file, typically a Rust source file. Test files have a particular
structure:</p>
<ul>
<li>They should have some kind of
<a href="tests/adding.html#explanatory_comment">comment explaining what the test is about</a>;</li>
<li>next, they can have one or more <a href="tests/adding.html#header_commands">header commands</a>, which
are special comments that the test interpreter knows how to interpret.</li>
<li>finally, they have the Rust source. This may have various <a href="tests/adding.html#error_annotations">error
annotations</a> which indicate expected compilation errors or
warnings.</li>
</ul>
<p>Depending on the test suite, there may be some other details to be aware of:</p>
<ul>
<li>For <a href="tests/adding.html#ui">the <code>ui</code> test suite</a>, you need to generate reference output files.</li>
</ul>
<h2><a class="header" href="#what-kind-of-test-should-i-add" id="what-kind-of-test-should-i-add">What kind of test should I add?</a></h2>
<p>It can be difficult to know what kind of test to use. Here are some
rough heuristics:</p>
<ul>
<li>Some tests have specialized needs:
<ul>
<li>need to run gdb or lldb? use the <code>debuginfo</code> test suite</li>
<li>need to inspect LLVM IR or MIR IR? use the <code>codegen</code> or <code>mir-opt</code> test
suites</li>
<li>need to run rustdoc? Prefer a <code>rustdoc</code> test</li>
<li>need to inspect the resulting binary in some way? Then use <code>run-make</code></li>
</ul>
</li>
<li>For most other things, <a href="tests/adding.html#ui">a <code>ui</code> (or <code>ui-fulldeps</code>) test</a> is to be
preferred:
<ul>
<li><code>ui</code> tests subsume both run-pass, compile-fail, and parse-fail tests</li>
<li>in the case of warnings or errors, <code>ui</code> tests capture the full output,
which makes it easier to review but also helps prevent &quot;hidden&quot; regressions
in the output</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#naming-your-test" id="naming-your-test">Naming your test</a></h2>
<p>We have not traditionally had a lot of structure in the names of
tests.  Moreover, for a long time, the rustc test runner did not
support subdirectories (it now does), so test suites like
<a href="https://github.com/rust-lang/rust/tree/master/src/test/ui/"><code>src/test/ui</code></a> have a huge mess of files in them.  This is not
considered an ideal setup.</p>
<p>For regression tests – basically, some random snippet of code that
came in from the internet – we often name the test after the issue
plus a short description. Ideally, the test should be added to a
directory that helps identify what piece of code is being tested here
(e.g., <code>src/test/ui/borrowck/issue-54597-reject-move-out-of-borrow-via-pat.rs</code>)
If you've tried and cannot find a more relevant place,
the test may be added to <code>src/test/ui/issues/</code>.
Still, <strong>do include the issue number somewhere</strong>.</p>
<p>When writing a new feature, <strong>create a subdirectory to store your
tests</strong>. For example, if you are implementing RFC 1234 (&quot;Widgets&quot;),
then it might make sense to put the tests in a directory like
<code>src/test/ui/rfc1234-widgets/</code>.</p>
<p>In other cases, there may already be a suitable directory. (The proper
directory structure to use is actually an area of active debate.)</p>
<p><a name="explanatory_comment"></a></p>
<h2><a class="header" href="#comment-explaining-what-the-test-is-about" id="comment-explaining-what-the-test-is-about">Comment explaining what the test is about</a></h2>
<p>When you create a test file, <strong>include a comment summarizing the point
of the test at the start of the file</strong>. This should highlight which
parts of the test are more important, and what the bug was that the
test is fixing. Citing an issue number is often very helpful.</p>
<p>This comment doesn't have to be super extensive. Just something like
&quot;Regression test for #18060: match arms were matching in the wrong
order.&quot;  might already be enough.</p>
<p>These comments are very useful to others later on when your test
breaks, since they often can highlight what the problem is. They are
also useful if for some reason the tests need to be refactored, since
they let others know which parts of the test were important (often a
test must be rewritten because it no longer tests what is was meant to
test, and then it's useful to know what it <em>was</em> meant to test
exactly).</p>
<p><a name="header_commands"></a></p>
<h2><a class="header" href="#header-commands-configuring-rustc" id="header-commands-configuring-rustc">Header commands: configuring rustc</a></h2>
<p>Header commands are special comments that the test runner knows how to
interpret.  They must appear before the Rust source in the test. They
are normally put after the short comment that explains the point of
this test. For example, this test uses the <code>// compile-flags</code> command
to specify a custom flag to give to rustc when the test is compiled:</p>
<pre><code class="language-rust ignore">// Test the behavior of `0 - 1` when overflow checks are disabled.

// compile-flags: -Coverflow-checks=off

fn main() {
    let x = 0 - 1;
    ...
}
</code></pre>
<h3><a class="header" href="#ignoring-tests" id="ignoring-tests">Ignoring tests</a></h3>
<p>These are used to ignore the test in some situations, which means the test won't
be compiled or run.</p>
<ul>
<li><code>ignore-X</code> where <code>X</code> is a target detail or stage will ignore the
test accordingly (see below)</li>
<li><code>only-X</code> is like <code>ignore-X</code>, but will <em>only</em> run the test on that
target or stage</li>
<li><code>ignore-pretty</code> will not compile the pretty-printed test (this is
done to test the pretty-printer, but might not always work)</li>
<li><code>ignore-test</code> always ignores the test</li>
<li><code>ignore-lldb</code> and <code>ignore-gdb</code> will skip a debuginfo test on that
debugger.</li>
<li><code>ignore-gdb-version</code> can be used to ignore the test when certain gdb
versions are used</li>
</ul>
<p>Some examples of <code>X</code> in <code>ignore-X</code>:</p>
<ul>
<li>Architecture: <code>aarch64</code>, <code>arm</code>, <code>asmjs</code>, <code>mips</code>, <code>wasm32</code>, <code>x86_64</code>,
<code>x86</code>, ...</li>
<li>OS: <code>android</code>, <code>emscripten</code>, <code>freebsd</code>, <code>ios</code>, <code>linux</code>, <code>macos</code>,
<code>windows</code>, ...</li>
<li>Environment (fourth word of the target triple): <code>gnu</code>, <code>msvc</code>,
<code>musl</code>.</li>
<li>Pointer width: <code>32bit</code>, <code>64bit</code>.</li>
<li>Stage: <code>stage0</code>, <code>stage1</code>, <code>stage2</code>.</li>
</ul>
<h3><a class="header" href="#other-header-commands" id="other-header-commands">Other Header Commands</a></h3>
<p>Here is a list of other header commands. This list is not
exhaustive. Header commands can generally be found by browsing the
<code>TestProps</code> structure found in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs"><code>header.rs</code></a> from the compiletest
source.</p>
<ul>
<li><code>run-rustfix</code> for UI tests, indicates that the test produces
structured suggestions. The test writer should create a <code>.fixed</code>
file, which contains the source with the suggestions applied.
When the test is run, compiletest first checks that the correct
lint/warning is generated. Then, it applies the suggestion and
compares against <code>.fixed</code> (they must match). Finally, the fixed
source is compiled, and this compilation is required to succeed.
The <code>.fixed</code> file can also be generated automatically with the
<code>--bless</code> option, described in <a href="tests/./running.html#editing-and-updating-the-reference-files">this section</a>.</li>
<li><code>min-gdb-version</code> specifies the minimum gdb version required for
this test; see also <code>ignore-gdb-version</code></li>
<li><code>min-lldb-version</code> specifies the minimum lldb version required for
this test</li>
<li><code>rust-lldb</code> causes the lldb part of the test to only be run if the
lldb in use contains the Rust plugin</li>
<li><code>no-system-llvm</code> causes the test to be ignored if the system llvm is used</li>
<li><code>min-llvm-version</code> specifies the minimum llvm version required for
this test</li>
<li><code>min-system-llvm-version</code> specifies the minimum system llvm version
required for this test; the test is ignored if the system llvm is in
use and it doesn't meet the minimum version.  This is useful when an
llvm feature has been backported to rust-llvm</li>
<li><code>ignore-llvm-version</code> can be used to skip the test when certain LLVM
versions are used.  This takes one or two arguments; the first
argument is the first version to ignore.  If no second argument is
given, all subsequent versions are ignored; otherwise, the second
argument is the last version to ignore.</li>
<li><code>build-pass</code> for UI tests, indicates that the test is supposed to
successfully compile and link, as opposed to the default where the test is
supposed to error out.</li>
<li><code>compile-flags</code> passes extra command-line args to the compiler,
e.g. <code>compile-flags -g</code> which forces debuginfo to be enabled.</li>
<li><code>should-fail</code> indicates that the test should fail; used for &quot;meta
testing&quot;, where we test the compiletest program itself to check that
it will generate errors in appropriate scenarios. This header is
ignored for pretty-printer tests.</li>
<li><code>gate-test-X</code> where <code>X</code> is a feature marks the test as &quot;gate test&quot;
for feature X.  Such tests are supposed to ensure that the compiler
errors when usage of a gated feature is attempted without the proper
<code>#![feature(X)]</code> tag.  Each unstable lang feature is required to
have a gate test.</li>
</ul>
<p><a name="error_annotations"></a></p>
<h2><a class="header" href="#error-annotations" id="error-annotations">Error annotations</a></h2>
<p>Error annotations specify the errors that the compiler is expected to
emit. They are &quot;attached&quot; to the line in source where the error is
located.</p>
<ul>
<li><code>~</code>: Associates the following error level and message with the
current line</li>
<li><code>~|</code>: Associates the following error level and message with the same
line as the previous comment</li>
<li><code>~^</code>: Associates the following error level and message with the
previous line. Each caret (<code>^</code>) that you add adds a line to this, so
<code>~^^^^^^^</code> is seven lines up.</li>
</ul>
<p>The error levels that you can have are:</p>
<ol>
<li><code>ERROR</code></li>
<li><code>WARNING</code></li>
<li><code>NOTE</code></li>
<li><code>HELP</code> and <code>SUGGESTION</code>*</li>
</ol>
<p>* <strong>Note</strong>: <code>SUGGESTION</code> must follow immediately after <code>HELP</code>.</p>
<h2><a class="header" href="#revisions" id="revisions">Revisions</a></h2>
<p>Certain classes of tests support &quot;revisions&quot; (as of the time of this
writing, this includes compile-fail, run-fail, and
incremental, though incremental tests are somewhat
different). Revisions allow a single test file to be used for multiple
tests. This is done by adding a special header at the top of the file:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// revisions: foo bar baz
<span class="boring">}
</span></code></pre></pre>
<p>This will result in the test being compiled (and tested) three times,
once with <code>--cfg foo</code>, once with <code>--cfg bar</code>, and once with <code>--cfg baz</code>. You can therefore use <code>#[cfg(foo)]</code> etc within the test to tweak
each of these results.</p>
<p>You can also customize headers and expected error messages to a particular
revision. To do this, add <code>[foo]</code> (or <code>bar</code>, <code>baz</code>, etc) after the <code>//</code>
comment, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// A flag to pass in only for cfg `foo`:
//[foo]compile-flags: -Z verbose

#[cfg(foo)]
fn test_foo() {
    let x: usize = 32_u32; //[foo]~ ERROR mismatched types
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that not all headers have meaning when customized to a revision.
For example, the <code>ignore-test</code> header (and all &quot;ignore&quot; headers)
currently only apply to the test as a whole, not to particular
revisions. The only headers that are intended to really work when
customized to a revision are error patterns and compiler flags.</p>
<p><a name="ui"></a></p>
<h2><a class="header" href="#guide-to-the-ui-tests" id="guide-to-the-ui-tests">Guide to the UI tests</a></h2>
<p>The UI tests are intended to capture the compiler's complete output,
so that we can test all aspects of the presentation. They work by
compiling a file (e.g., <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/hello_world/main.rs"><code>ui/hello_world/main.rs</code></a>),
capturing the output, and then applying some normalization (see
below). This normalized result is then compared against reference
files named <code>ui/hello_world/main.stderr</code> and
<code>ui/hello_world/main.stdout</code>. If either of those files doesn't exist,
the output must be empty (that is actually the case for
<a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/hello_world/">this particular test</a>). If the test run fails, we will print out
the current output, but it is also saved in
<code>build/&lt;target-triple&gt;/test/ui/hello_world/main.stdout</code> (this path is
printed as part of the test failure message), so you can run <code>diff</code>
and so forth.</p>
<h3><a class="header" href="#tests-that-do-not-result-in-compile-errors" id="tests-that-do-not-result-in-compile-errors">Tests that do not result in compile errors</a></h3>
<p>By default, a UI test is expected <strong>not to compile</strong> (in which case,
it should contain at least one <code>//~ ERROR</code> annotation). However, you
can also make UI tests where compilation is expected to succeed, and
you can even run the resulting program. Just add one of the following
<a href="tests/adding.html#header_commands">header commands</a>:</p>
<ul>
<li><code>// check-pass</code> - compilation should succeed but skip codegen
(which is expensive and isn't supposed to fail in most cases)</li>
<li><code>// build-pass</code> – compilation and linking should succeed but do
not run the resulting binary</li>
<li><code>// run-pass</code> – compilation should succeed and we should run the
resulting binary</li>
</ul>
<h3><a class="header" href="#normalization" id="normalization">Normalization</a></h3>
<p>The normalization applied is aimed at eliminating output difference
between platforms, mainly about filenames:</p>
<ul>
<li>the test directory is replaced with <code>$DIR</code></li>
<li>all backslashes (<code>\</code>) are converted to forward slashes (<code>/</code>) (for Windows)</li>
<li>all CR LF newlines are converted to LF</li>
</ul>
<p>Sometimes these built-in normalizations are not enough. In such cases, you
may provide custom normalization rules using the header commands, e.g.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// normalize-stdout-test: &quot;foo&quot; -&gt; &quot;bar&quot;
// normalize-stderr-32bit: &quot;fn\(\) \(32 bits\)&quot; -&gt; &quot;fn\(\) \($$PTR bits\)&quot;
// normalize-stderr-64bit: &quot;fn\(\) \(64 bits\)&quot; -&gt; &quot;fn\(\) \($$PTR bits\)&quot;
<span class="boring">}
</span></code></pre></pre>
<p>This tells the test, on 32-bit platforms, whenever the compiler writes
<code>fn() (32 bits)</code> to stderr, it should be normalized to read <code>fn() ($PTR bits)</code>
instead. Similar for 64-bit. The replacement is performed by regexes using
default regex flavor provided by <code>regex</code> crate.</p>
<p>The corresponding reference file will use the normalized output to test both
32-bit and 64-bit platforms:</p>
<pre><code class="language-text">...
   |
   = note: source type: fn() ($PTR bits)
   = note: target type: u16 (16 bits)
...
</code></pre>
<p>Please see <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/transmute/main.rs"><code>ui/transmute/main.rs</code></a> and <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/transmute/main.stderr"><code>main.stderr</code></a> for a
concrete usage example.</p>
<p>Besides <code>normalize-stderr-32bit</code> and <code>-64bit</code>, one may use any target
information or stage supported by <code>ignore-X</code> here as well (e.g.
<code>normalize-stderr-windows</code> or simply <code>normalize-stderr-test</code> for unconditional
replacement).</p>
<h1><a class="header" href="#compiletest" id="compiletest"><code>compiletest</code></a></h1>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p><code>compiletest</code> is the main test harness of the Rust test suite.  It allows
test authors to organize large numbers of tests (the Rust compiler has many
thousands), efficient test execution (parallel execution is supported), and
allows the test author to configure behavior and expected results of both
individual and groups of tests.</p>
<p><code>compiletest</code> tests may check test code for success, for failure or in some
cases, even failure to compile.  Tests are typically organized as a Rust source
file with annotations in comments before and/or within the test code, which
serve to direct <code>compiletest</code> on if or how to run the test, what behavior to
expect, and more.  If you are unfamiliar with the compiler testing framework,
see <a href="./tests/intro.html">this chapter</a> for additional background.</p>
<p>The tests themselves are typically (but not always) organized into
&quot;suites&quot; – for example, <code>run-fail</code>,
a folder holding tests that should compile successfully,
but return a failure (non-zero status), <code>compile-fail</code>, a folder holding tests
that should fail to compile, and many more.  The various suites are defined in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/common.rs">src/tools/compiletest/src/common.rs</a> in the <code>pub enum Mode</code>
declaration.  And a very good introduction to the different suites of compiler
tests along with details about them can be found in <a href="./tests/adding.html">Adding new
tests</a>.</p>
<h2><a class="header" href="#adding-a-new-test-file" id="adding-a-new-test-file">Adding a new test file</a></h2>
<p>Briefly, simply create your new test in the appropriate location under
<a href="https://github.com/rust-lang/rust/tree/master/src/test">src/test</a>. No registration of test files is necessary as <code>compiletest</code>
will scan the <a href="https://github.com/rust-lang/rust/tree/master/src/test">src/test</a> subfolder recursively, and will execute any Rust
source files it finds as tests.  See <a href="./tests/adding.html"><code>Adding new tests</code></a>
for a complete guide on how to adding new tests.</p>
<h2><a class="header" href="#header-commands" id="header-commands">Header Commands</a></h2>
<p>Source file annotations which appear in comments near the top of the source
file <em>before</em> any test code are known as header commands.  These commands can
instruct <code>compiletest</code> to ignore this test, set expectations on whether it is
expected to succeed at compiling, or what the test's return code is expected to
be.  Header commands (and their inline counterparts, Error Info commands) are
described more fully
<a href="./tests/adding.html#header-commands-configuring-rustc">here</a>.</p>
<h3><a class="header" href="#adding-a-new-header-command" id="adding-a-new-header-command">Adding a new header command</a></h3>
<p>Header commands are defined in the <code>TestProps</code> struct in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a>.  At a high level, there are
dozens of test properties defined here, all set to default values in the
<code>TestProp</code> struct's <code>impl</code> block. Any test can override this default value by
specifying the property in question as header command as a comment (<code>//</code>) in
the test source file, before any source code.</p>
<h4><a class="header" href="#using-a-header-command" id="using-a-header-command">Using a header command</a></h4>
<p>Here is an example, specifying the <code>must-compile-successfully</code> header command,
which takes no arguments, followed by the <code>failure-status</code> header command,
which takes a single argument (which, in this case is a value of 1).
<code>failure-status</code> is instructing <code>compiletest</code> to expect a failure status of 1
(rather than the current Rust default of 101). The header command and
the argument list (if present) are typically separated by a colon:</p>
<pre><code class="language-rust ignore">// must-compile-successfully
// failure-status: 1

#![feature(termination_trait)]

use std::io::{Error, ErrorKind};

fn main() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    Err(Box::new(Error::new(ErrorKind::Other, &quot;returned Box&lt;Error&gt; from main()&quot;)))
}
</code></pre>
<h4><a class="header" href="#adding-a-new-header-command-property" id="adding-a-new-header-command-property">Adding a new header command property</a></h4>
<p>One would add a new header command if there is a need to define some test
property or behavior on an individual, test-by-test basis.  A header command
property serves as the header command's backing store (holds the command's
current value) at runtime.</p>
<p>To add a new header command property:
1. Look for the <code>pub struct TestProps</code> declaration in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a> and add the new public
property to the end of the declaration.
2. Look for the <code>impl TestProps</code> implementation block immediately following
the struct declaration and initialize the new property to its default
value.</p>
<h4><a class="header" href="#adding-a-new-header-command-parser" id="adding-a-new-header-command-parser">Adding a new header command parser</a></h4>
<p>When <code>compiletest</code> encounters a test file, it parses the file a line at a time
by calling every parser defined in the <code>Config</code> struct's implementation block,
also in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a> (note the <code>Config</code>
struct's declaration block is found in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/common.rs">src/tools/compiletest/src/common.rs</a>.  <code>TestProps</code>'s <code>load_from()</code>
method will try passing the current line of text to each parser, which, in turn
typically checks to see if the line begins with a particular commented (<code>//</code>)
header command such as <code>// must-compile-successfully</code> or <code>// failure-status</code>.
Whitespace after the comment marker is optional.</p>
<p>Parsers will override a given header command property's default value merely by
being specified in the test file as a header command or by having a parameter
value specified in the test file, depending on the header command.</p>
<p>Parsers defined in <code>impl Config</code> are typically named <code>parse_&lt;header_command&gt;</code>
(note kebab-case <code>&lt;header-command&gt;</code> transformed to snake-case
<code>&lt;header_command&gt;</code>).  <code>impl Config</code> also defines several 'low-level' parsers
which make it simple to parse common patterns like simple presence or not
(<code>parse_name_directive()</code>), header-command:parameter(s)
(<code>parse_name_value_directive()</code>), optional parsing only if a particular <code>cfg</code>
attribute is defined (<code>has_cfg_prefix()</code>) and many more.  The low-level parsers
are found near the end of the <code>impl Config</code> block; be sure to look through them
and their associated parsers immediately above to see how they are used to
avoid writing additional parsing code unnecessarily.</p>
<p>As a concrete example, here is the implementation for the
<code>parse_failure_status()</code> parser, in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a>:</p>
<pre><code class="language-diff">@@ -232,6 +232,7 @@ pub struct TestProps {
     // customized normalization rules
     pub normalize_stdout: Vec&lt;(String, String)&gt;,
     pub normalize_stderr: Vec&lt;(String, String)&gt;,
+    pub failure_status: i32,
 }

 impl TestProps {
@@ -260,6 +261,7 @@ impl TestProps {
             run_pass: false,
             normalize_stdout: vec![],
             normalize_stderr: vec![],
+            failure_status: 101,
         }
     }

@@ -383,6 +385,10 @@ impl TestProps {
             if let Some(rule) = config.parse_custom_normalization(ln, &quot;normalize-stderr&quot;) {
                 self.normalize_stderr.push(rule);
             }
+
+            if let Some(code) = config.parse_failure_status(ln) {
+                self.failure_status = code;
+            }
         });

         for key in &amp;[&quot;RUST_TEST_NOCAPTURE&quot;, &quot;RUST_TEST_THREADS&quot;] {
@@ -488,6 +494,13 @@ impl Config {
         self.parse_name_directive(line, &quot;pretty-compare-only&quot;)
     }

+    fn parse_failure_status(&amp;self, line: &amp;str) -&gt; Option&lt;i32&gt; {
+        match self.parse_name_value_directive(line, &quot;failure-status&quot;) {
+            Some(code) =&gt; code.trim().parse::&lt;i32&gt;().ok(),
+            _ =&gt; None,
+        }
+    }
</code></pre>
<h2><a class="header" href="#implementing-the-behavior-change" id="implementing-the-behavior-change">Implementing the behavior change</a></h2>
<p>When a test invokes a particular header command, it is expected that some
behavior will change as a result.  What behavior, obviously, will depend on the
purpose of the header command.  In the case of <code>failure-status</code>, the behavior
that changes is that <code>compiletest</code> expects the failure code defined by the
header command invoked in the test, rather than the default value.</p>
<p>Although specific to <code>failure-status</code> (as every header command will have a
different implementation in order to invoke behavior change) perhaps it is
helpful to see the behavior change implementation of one case, simply as an
example.  To implement <code>failure-status</code>, the <code>check_correct_failure_status()</code>
function found in the <code>TestCx</code> implementation block, located in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/runtest.rs">src/tools/compiletest/src/runtest.rs</a>,
was modified as per below:</p>
<pre><code class="language-diff">@@ -295,11 +295,14 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
     }

     fn check_correct_failure_status(&amp;self, proc_res: &amp;ProcRes) {
-        // The value the rust runtime returns on failure
-        const RUST_ERR: i32 = 101;
-        if proc_res.status.code() != Some(RUST_ERR) {
+        let expected_status = Some(self.props.failure_status);
+        let received_status = proc_res.status.code();
+
+        if expected_status != received_status {
             self.fatal_proc_rec(
-                &amp;format!(&quot;failure produced the wrong error: {}&quot;, proc_res.status),
+                &amp;format!(&quot;Error: expected failure status ({:?}) but received status {:?}.&quot;,
+                         expected_status,
+                         received_status),
                 proc_res,
             );
         }
@@ -320,7 +323,6 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
         );

         let proc_res = self.exec_compiled_test();
-
         if !proc_res.status.success() {
             self.fatal_proc_rec(&quot;test run failed!&quot;, &amp;proc_res);
         }
@@ -499,7 +501,6 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
                 expected,
                 actual
             );
-            panic!();
         }
     }
</code></pre>
<p>Note the use of <code>self.props.failure_status</code> to access the header command
property.  In tests which do not specify the failure status header command,
<code>self.props.failure_status</code> will evaluate to the default value of 101 at the
time of this writing.  But for a test which specifies a header command of, for
example, <code>// failure-status: 1</code>, <code>self.props.failure_status</code> will evaluate to
1, as <code>parse_failure_status()</code> will have overridden the <code>TestProps</code> default
value, for that test specifically.</p>
<h1><a class="header" href="#walkthrough-a-typical-contribution" id="walkthrough-a-typical-contribution">Walkthrough: a typical contribution</a></h1>
<p>There are <em>a lot</em> of ways to contribute to the rust compiler, including fixing
bugs, improving performance, helping design features, providing feedback on
existing features, etc. This chapter does not claim to scratch the surface.
Instead, it walks through the design and implementation of a new feature. Not
all of the steps and processes described here are needed for every
contribution, and I will try to point those out as they arise.</p>
<p>In general, if you are interested in making a contribution and aren't sure
where to start, please feel free to ask!</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The feature I will discuss in this chapter is the <code>?</code> Kleene operator for
macros. Basically, we want to be able to write something like this:</p>
<pre><code class="language-rust ignore">macro_rules! foo {
    ($arg:ident $(, $optional_arg:ident)?) =&gt; {
        println!(&quot;{}&quot;, $arg);

        $(
            println!(&quot;{}&quot;, $optional_arg);
        )?
    }
}

fn main() {
    let x = 0;
    foo!(x); // ok! prints &quot;0&quot;
    foo!(x, x); // ok! prints &quot;0 0&quot;
}
</code></pre>
<p>So basically, the <code>$(pat)?</code> matcher in the macro means &quot;this pattern can occur
0 or 1 times&quot;, similar to other regex syntaxes.</p>
<p>There were a number of steps to go from an idea to stable rust feature. Here is
a quick list.  We will go through each of these in order below. As I mentioned
before, not all of these are needed for every type of contribution.</p>
<ul>
<li><strong>Idea discussion/Pre-RFC</strong>  A Pre-RFC is an early draft or design discussion
of a feature. This stage is intended to flesh out the design space a bit and
get a grasp on the different merits and problems with an idea. It's a great
way to get early feedback on your idea before presenting it the wider
audience. You can find the original discussion <a href="https://internals.rust-lang.org/t/pre-rfc-at-most-one-repetition-macro-patterns/6557">here</a>.</li>
<li><strong>RFC</strong>  This is when you formally present your idea to the community for
consideration. You can find the RFC <a href="https://github.com/rust-lang/rfcs/pull/2298">here</a>.</li>
<li><strong>Implementation</strong> Implement your idea unstably in the compiler. You can
find the original implementation <a href="https://github.com/rust-lang/rust/pull/47752">here</a>.</li>
<li><strong>Possibly iterate/refine</strong> As the community gets experience with your
feature on the nightly compiler and in <code>libstd</code>, there may be additional
feedback about design choice that might be adjusted. This particular feature
went <a href="https://github.com/rust-lang/rust/pull/49719">through</a> a <a href="https://github.com/rust-lang/rust/pull/51336">number</a> of <a href="https://github.com/rust-lang/rust/pull/51587">iterations</a>.</li>
<li><strong>Stabilization</strong> When your feature has baked enough, a rust team member may
<a href="https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613">propose to stabilize it</a>. If there is consensus, this is done.</li>
<li><strong>Relax</strong> Your feature is now a stable rust feature!</li>
</ul>
<h2><a class="header" href="#pre-rfc-and-rfc" id="pre-rfc-and-rfc">Pre-RFC and RFC</a></h2>
<blockquote>
<p>NOTE: In general, if you are not proposing a <em>new</em> feature or substantial
change to rust or the ecosystem, you don't need to follow the RFC process.
Instead, you can just jump to <a href="walkthrough.html#impl">implementation</a>.</p>
<p>You can find the official guidelines for when to open an RFC <a href="https://github.com/rust-lang/rfcs#when-you-need-to-follow-this-process">here</a>.</p>
</blockquote>
<p>An RFC is a document that describes the feature or change you are proposing in
detail. Anyone can write an RFC; the process is the same for everyone,
including rust team members.</p>
<p>To open an RFC, open a PR on the
<a href="https://github.com/rust-lang/rfcs">rust-lang/rfcs</a> repo on GitHub. You can
find detailed instructions in the
<a href="https://github.com/rust-lang/rfcs#what-the-process-is">README</a>.</p>
<p>Before opening an RFC, you should do the research to &quot;flesh out&quot; your idea.
Hastily-proposed RFCs tend not to be accepted. You should generally have a good
description of the motivation, impact, disadvantages, and potential
interactions with other features.</p>
<p>If that sounds like a lot of work, it's because it is. But no fear! Even if
you're not a compiler hacker, you can get great feedback by doing a <em>pre-RFC</em>.
This is an <em>informal</em> discussion of the idea. The best place to do this is
internals.rust-lang.org. Your post doesn't have to follow any particular
structure.  It doesn't even need to be a cohesive idea. Generally, you will get
tons of feedback that you can integrate back to produce a good RFC.</p>
<p>(Another pro-tip: try searching the RFCs repo and internals for prior related
ideas. A lot of times an idea has already been considered and was either
rejected or postponed to be tried again later. This can save you and everybody
else some time)</p>
<p>In the case of our example, a participant in the pre-RFC thread pointed out a
syntax ambiguity and a potential resolution. Also, the overall feedback seemed
positive. In this case, the discussion converged pretty quickly, but for some
ideas, a lot more discussion can happen (e.g. see <a href="https://github.com/rust-lang/rfcs/pull/2457">this RFC</a> which
received a whopping 684 comments!). If that happens, don't be discouraged; it
means the community is interested in your idea, but it perhaps needs some
adjustments.</p>
<p>The RFC for our <code>?</code> macro feature did receive some discussion on the RFC thread
too.  As with most RFCs, there were a few questions that we couldn't answer by
discussion: we needed experience using the feature to decide. Such questions
are listed in the &quot;Unresolved Questions&quot; section of the RFC. Also, over the
course of the RFC discussion, you will probably want to update the RFC document
itself to reflect the course of the discussion (e.g. new alternatives or prior
work may be added or you may decide to change parts of the proposal itself).</p>
<p>In the end, when the discussion seems to reach a consensus and die down a bit,
a rust team member may propose to move to &quot;final comment period&quot; (FCP) with one
of three possible dispositions. This means that they want the other members of
the appropriate teams to review and comment on the RFC. More discussion may
ensue, which may result in more changes or unresolved questions being added. At
some point, when everyone is satisfied, the RFC enters the FCP, which is the
last chance for people to bring up objections. When the FCP is over, the
disposition is adopted. Here are the three possible dispositions:</p>
<ul>
<li><em>Merge</em>: accept the feature. Here is the proposal to merge for our <a href="https://github.com/rust-lang/rfcs/pull/2298#issuecomment-360582667"><code>?</code> macro
feature</a>.</li>
<li><em>Close</em>: this feature in its current form is not a good fit for rust. Don't
be discouraged if this happens to your RFC, and don't take it personally.
This is not a reflection on you, but rather a community decision that rust
will go a different direction.</li>
<li><em>Postpone</em>: there is interest in going this direction but not at the moment.
This happens most often because the appropriate rust team doesn't have the
bandwidth to shepherd the feature through the process to stabilization. Often
this is the case when the feature doesn't fit into the team's roadmap.
Postponed ideas may be revisited later.</li>
</ul>
<p>When an RFC is merged, the PR is merged into the RFCs repo. A new <em>tracking
issue</em> is created in the <a href="https://github.com/rust-lang/rust">rust-lang/rust</a> repo to track progress on the feature
and discuss unresolved questions, implementation progress and blockers, etc.
Here is the tracking issue on for our <a href="https://github.com/rust-lang/rust/issues/48075"><code>?</code> macro feature</a>.</p>
<p><a name="impl"></a></p>
<h2><a class="header" href="#implementation" id="implementation">Implementation</a></h2>
<p>To make a change to the compiler, open a PR against the <a href="https://github.com/rust-lang/rust">rust-lang/rust</a> repo.</p>
<p>Depending on the feature/change/bug fix/improvement, implementation may be
relatively-straightforward or it may be a major undertaking. You can always ask
for help or mentorship from more experienced compiler devs.  Also, you don't
have to be the one to implement your feature; but keep in mind that if you
don't it might be a while before someone else does.</p>
<p>For the <code>?</code> macro feature, I needed to go understand the relevant parts of
macro expansion in the compiler. Personally, I find that <a href="https://github.com/rust-lang/rust/pull/47732">improving the
comments</a> in the code is a helpful way of making sure I understand
it, but you don't have to do that if you don't want to.</p>
<p>I then <a href="https://github.com/rust-lang/rust/pull/47752">implemented</a> the original feature, as described in the RFC. When
a new feature is implemented, it goes behind a <em>feature gate</em>, which means that
you have to use <code>#![feature(my_feature_name)]</code> to use the feature. The feature
gate is removed when the feature is stabilized.</p>
<p><strong>Most bug fixes and improvements</strong> don't require a feature gate. You can just
make your changes/improvements.</p>
<p>When you open a PR on the <a href="https://github.com/rust-lang/rust">rust-lang/rust</a>, a bot will assign your PR to a
review. If there is a particular rust team member you are working with, you can
request that reviewer by leaving a comment on the thread with <code>r? @reviewer-github-id</code> (e.g. <code>r? @eddyb</code>). If you don't know who to request,
don't request anyone; the bot will assign someone automatically.</p>
<p>The reviewer may request changes before they approve your PR. Feel free to ask
questions or discuss things you don't understand or disagree with. However,
recognize that the PR won't be merged unless someone on the rust team approves
it.</p>
<p>When your review approves the PR, it will go into a queue for yet another bot
called <code>@bors</code>.  <code>@bors</code> manages the CI build/merge queue. When your PR reaches
the head of the <code>@bors</code> queue, <code>@bors</code> will test out the merge by running all
tests against your PR on Travis CI. This takes a lot of time to
finish. If all tests pass, the PR is merged and becomes part of the next
nightly compiler!</p>
<p>There are a couple of things that may happen for some PRs during the review process</p>
<ul>
<li>If the change is substantial enough, the reviewer may request an FCP on
the PR. This gives all members of the appropriate team a chance to review the
changes.</li>
<li>If the change may cause breakage, the reviewer may request a <a href="./tests/intro.html#crater">crater</a> run.
This compiles the compiler with your changes and then attempts to compile all
crates on crates.io with your modified compiler. This is a great smoke test
to check if you introduced a change to compiler behavior that affects a large
portion of the ecosystem.</li>
<li>If the diff of your PR is large or the reviewer is busy, your PR may have
some merge conflicts with other PRs that happen to get merged first. You
should fix these merge conflicts using the normal git procedures.</li>
</ul>
<p>If you are not doing a new feature or something like that (e.g. if you are
fixing a bug), then that's it! Thanks for your contribution :)</p>
<h2><a class="header" href="#refining-your-implementation" id="refining-your-implementation">Refining your implementation</a></h2>
<p>As people get experience with your new feature on nightly, slight changes may
be proposed and unresolved questions may become resolved. Updates/changes go
through the same process for implementing any other changes, as described
above (i.e. submit a PR, go through review, wait for <code>@bors</code>, etc).</p>
<p>Some changes may be major enough to require an FCP and some review by rust team
members.</p>
<p>For the <code>?</code> macro feature, we went through a few different iterations after the
original implementation: <a href="https://github.com/rust-lang/rust/pull/49719">1</a>, <a href="https://github.com/rust-lang/rust/pull/51336">2</a>, <a href="https://github.com/rust-lang/rust/pull/51587">3</a>.</p>
<p>Along the way, we decided that <code>?</code> should not take a separator, which was
previously an unresolved question listed in the RFC. We also changed the
disambiguation strategy: we decided to remove the ability to use <code>?</code> as a
separator token for other repetition operators (e.g. <code>+</code> or <code>*</code>). However,
since this was a breaking change, we decided to do it over an edition boundary.
Thus, the new feature can be enabled only in edition 2018. These deviations
from the original RFC required <a href="https://github.com/rust-lang/rust/issues/51934">another
FCP</a>.</p>
<h2><a class="header" href="#stabilization" id="stabilization">Stabilization</a></h2>
<p>Finally, after the feature had baked for a while on nightly, a language team member
<a href="https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613">moved to stabilize it</a>.</p>
<p>A <em>stabilization report</em> needs to be written that includes</p>
<ul>
<li>brief description of the behavior and any deviations from the RFC</li>
<li>which edition(s) are affected and how</li>
<li>links to a few tests to show the interesting aspects</li>
</ul>
<p>The stabilization report for our feature is <a href="https://github.com/rust-lang/rust/issues/48075#issuecomment-433243048">here</a>.</p>
<p>After this, <a href="https://github.com/rust-lang/rust/pull/56245">a PR is made</a> to remove the feature gate, enabling the feature by
default (on the 2018 edition). A note is added to the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md">Release notes</a>
about the feature.</p>
<p>Steps to stabilize the feature can be found at <a href="./stabilization_guide.html">Stabilizing Features</a>.</p>
<h1><a class="header" href="#rustc-bug-fix-procedure" id="rustc-bug-fix-procedure">Rustc Bug Fix Procedure</a></h1>
<p>This page defines the best practices procedure for making bug fixes or soundness
corrections in the compiler that can cause existing code to stop compiling. This
text is based on
<a href="https://github.com/rust-lang/rfcs/blob/master/text/1589-rustc-bug-fix-procedure.md">RFC 1589</a>.</p>
<h1><a class="header" href="#motivation" id="motivation">Motivation</a></h1>
<p>From time to time, we encounter the need to make a bug fix, soundness
correction, or other change in the compiler which will cause existing code to
stop compiling. When this happens, it is important that we handle the change in
a way that gives users of Rust a smooth transition. What we want to avoid is
that existing programs suddenly stop compiling with opaque error messages: we
would prefer to have a gradual period of warnings, with clear guidance as to
what the problem is, how to fix it, and why the change was made. This RFC
describes the procedure that we have been developing for handling breaking
changes that aims to achieve that kind of smooth transition.</p>
<p>One of the key points of this policy is that (a) warnings should be issued
initially rather than hard errors if at all possible and (b) every change that
causes existing code to stop compiling will have an associated tracking issue.
This issue provides a point to collect feedback on the results of that change.
Sometimes changes have unexpectedly large consequences or there may be a way to
avoid the change that was not considered. In those cases, we may decide to
change course and roll back the change, or find another solution (if warnings
are being used, this is particularly easy to do).</p>
<h3><a class="header" href="#what-qualifies-as-a-bug-fix" id="what-qualifies-as-a-bug-fix">What qualifies as a bug fix?</a></h3>
<p>Note that this RFC does not try to define when a breaking change is permitted.
That is already covered under <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">RFC 1122</a>. This document assumes that the
change being made is in accordance with those policies. Here is a summary of the
conditions from RFC 1122:</p>
<ul>
<li><strong>Soundness changes:</strong> Fixes to holes uncovered in the type system.</li>
<li><strong>Compiler bugs:</strong> Places where the compiler is not implementing the specified
semantics found in an RFC or lang-team decision.</li>
<li><strong>Underspecified language semantics:</strong> Clarifications to grey areas where the
compiler behaves inconsistently and no formal behavior had been previously
decided.</li>
</ul>
<p>Please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">the RFC</a> for full details!</p>
<h1><a class="header" href="#detailed-design" id="detailed-design">Detailed design</a></h1>
<p>The procedure for making a breaking change is as follows (each of these steps is
described in more detail below):</p>
<ol start="0">
<li>Do a <strong>crater run</strong> to assess the impact of the change.</li>
<li>Make a <strong>special tracking issue</strong> dedicated to the change.</li>
<li>Do not report an error right away. Instead, <strong>issue forwards-compatibility
lint warnings</strong>.
<ul>
<li>Sometimes this is not straightforward. See the text below for suggestions
on different techniques we have employed in the past.</li>
<li>For cases where warnings are infeasible:
<ul>
<li>Report errors, but make every effort to give a targeted error message
that directs users to the tracking issue</li>
<li>Submit PRs to all known affected crates that fix the issue
<ul>
<li>or, at minimum, alert the owners of those crates to the problem and
direct them to the tracking issue</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Once the change has been in the wild for at least one cycle, we can
<strong>stabilize the change</strong>, converting those warnings into errors.</li>
</ol>
<p>Finally, for changes to <code>librustc_ast</code> that will affect plugins, the general policy
is to batch these changes. That is discussed below in more detail.</p>
<h3><a class="header" href="#tracking-issue" id="tracking-issue">Tracking issue</a></h3>
<p>Every breaking change should be accompanied by a <strong>dedicated tracking issue</strong>
for that change. The main text of this issue should describe the change being
made, with a focus on what users must do to fix their code. The issue should be
approachable and practical; it may make sense to direct users to an RFC or some
other issue for the full details. The issue also serves as a place where users
can comment with questions or other concerns.</p>
<p>A template for these breaking-change tracking issues can be found below. An
example of how such an issue should look can be <a href="https://gist.github.com/nikomatsakis/631ec8b4af9a18b5d062d9d9b7d3d967">found
here</a>.</p>
<p>The issue should be tagged with (at least) <code>B-unstable</code> and <code>T-compiler</code>.</p>
<h3><a class="header" href="#tracking-issue-template" id="tracking-issue-template">Tracking issue template</a></h3>
<p>This is a template to use for tracking issues:</p>
<pre><code>This is the **summary issue** for the `YOUR_LINT_NAME_HERE`
future-compatibility warning and other related errors. The goal of
this page is describe why this change was made and how you can fix
code that is affected by it. It also provides a place to ask questions
or register a complaint if you feel the change should not be made. For
more information on the policy around future-compatibility warnings,
see our [breaking change policy guidelines][guidelines].

[guidelines]: LINK_TO_THIS_RFC

#### What is the warning for?

*Describe the conditions that trigger the warning and how they can be
fixed. Also explain why the change was made.**

#### When will this warning become a hard error?

At the beginning of each 6-week release cycle, the Rust compiler team
will review the set of outstanding future compatibility warnings and
nominate some of them for **Final Comment Period**. Toward the end of
the cycle, we will review any comments and make a final determination
whether to convert the warning into a hard error or remove it
entirely.
</code></pre>
<h3><a class="header" href="#issuing-future-compatibility-warnings" id="issuing-future-compatibility-warnings">Issuing future compatibility warnings</a></h3>
<p>The best way to handle a breaking change is to begin by issuing
future-compatibility warnings. These are a special category of lint warning.
Adding a new future-compatibility warning can be done as follows.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 1. Define the lint in `src/librustc/lint/builtin.rs`:
declare_lint! {
    pub YOUR_ERROR_HERE,
    Warn,
    &quot;illegal use of foo bar baz&quot;
}

// 2. Add to the list of HardwiredLints in the same file:
impl LintPass for HardwiredLints {
    fn get_lints(&amp;self) -&gt; LintArray {
        lint_array!(
            ..,
            YOUR_ERROR_HERE
        )
    }
}

// 3. Register the lint in `src/librustc_lint/lib.rs`:
store.register_future_incompatible(sess, vec![
    ...,
    FutureIncompatibleInfo {
        id: LintId::of(YOUR_ERROR_HERE),
        reference: &quot;issue #1234&quot;, // your tracking issue here!
    },
]);

// 4. Report the lint:
tcx.lint_node(
    lint::builtin::YOUR_ERROR_HERE,
    path_id,
    binding.span,
    format!(&quot;some helper message here&quot;));
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#helpful-techniques" id="helpful-techniques">Helpful techniques</a></h4>
<p>It can often be challenging to filter out new warnings from older, pre-existing
errors. One technique that has been used in the past is to run the older code
unchanged and collect the errors it would have reported. You can then issue
warnings for any errors you would give which do not appear in that original set.
Another option is to abort compilation after the original code completes if
errors are reported: then you know that your new code will only execute when
there were no errors before.</p>
<h4><a class="header" href="#crater-and-cratesio" id="crater-and-cratesio">Crater and crates.io</a></h4>
<p>We should always do a crater run to assess impact. It is polite and considerate
to at least notify the authors of affected crates the breaking change. If we can
submit PRs to fix the problem, so much the better.</p>
<h4><a class="header" href="#is-it-ever-acceptable-to-go-directly-to-issuing-errors" id="is-it-ever-acceptable-to-go-directly-to-issuing-errors">Is it ever acceptable to go directly to issuing errors?</a></h4>
<p>Changes that are believed to have negligible impact can go directly to issuing
an error. One rule of thumb would be to check against <code>crates.io</code>: if fewer than
10 <strong>total</strong> affected projects are found (<strong>not</strong> root errors), we can move
straight to an error. In such cases, we should still make the &quot;breaking change&quot;
page as before, and we should ensure that the error directs users to this page.
In other words, everything should be the same except that users are getting an
error, and not a warning. Moreover, we should submit PRs to the affected
projects (ideally before the PR implementing the change lands in rustc).</p>
<p>If the impact is not believed to be negligible (e.g., more than 10 crates are
affected), then warnings are required (unless the compiler team agrees to grant
a special exemption in some particular case). If implementing warnings is not
feasible, then we should make an aggressive strategy of migrating crates before
we land the change so as to lower the number of affected crates. Here are some
techniques for approaching this scenario:</p>
<ol>
<li>Issue warnings for subparts of the problem, and reserve the new errors for
the smallest set of cases you can.</li>
<li>Try to give a very precise error message that suggests how to fix the problem
and directs users to the tracking issue.</li>
<li>It may also make sense to layer the fix:
<ul>
<li>First, add warnings where possible and let those land before proceeding to
issue errors.</li>
<li>Work with authors of affected crates to ensure that corrected versions are
available <em>before</em> the fix lands, so that downstream users can use them.</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#stabilization-1" id="stabilization-1">Stabilization</a></h3>
<p>After a change is made, we will <strong>stabilize</strong> the change using the same process
that we use for unstable features:</p>
<ul>
<li>
<p>After a new release is made, we will go through the outstanding tracking
issues corresponding to breaking changes and nominate some of them for <strong>final
comment period</strong> (FCP).</p>
</li>
<li>
<p>The FCP for such issues lasts for one cycle. In the final week or two of the
cycle, we will review comments and make a final determination:</p>
<ul>
<li>Convert to error: the change should be made into a hard error.</li>
<li>Revert: we should remove the warning and continue to allow the older code to
compile.</li>
<li>Defer: can't decide yet, wait longer, or try other strategies.</li>
</ul>
</li>
</ul>
<p>Ideally, breaking changes should have landed on the <strong>stable branch</strong> of the
compiler before they are finalized.</p>
<a name="guide">
<h3><a class="header" href="#removing-a-lint" id="removing-a-lint">Removing a lint</a></h3>
<p>Once we have decided to make a &quot;future warning&quot; into a hard error, we need a PR
that removes the custom lint. As an example, here are the steps required to
remove the <code>overlapping_inherent_impls</code> compatibility lint. First, convert the
name of the lint to uppercase (<code>OVERLAPPING_INHERENT_IMPLS</code>) ripgrep through the
source for that string. We will basically by converting each place where this
lint name is mentioned (in the compiler, we use the upper-case name, and a macro
automatically generates the lower-case string; so searching for
<code>overlapping_inherent_impls</code> would not find much).</p>
<blockquote>
<p>NOTE: these exact files don't exist anymore, but the procedure is still the same.</p>
</blockquote>
<h4><a class="header" href="#remove-the-lint" id="remove-the-lint">Remove the lint.</a></h4>
<p>The first reference you will likely find is the lint definition <a href="https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc/lint/builtin.rs#L171-L175">in
<code>librustc/lint/builtin.rs</code> that resembles this</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>declare_lint! {
    pub OVERLAPPING_INHERENT_IMPLS,
    Deny, // this may also say Warning
    &quot;two overlapping inherent impls define an item with the same name were erroneously allowed&quot;
}
<span class="boring">}
</span></code></pre></pre>
<p>This <code>declare_lint!</code> macro creates the relevant data structures. Remove it. You
will also find that there is a mention of <code>OVERLAPPING_INHERENT_IMPLS</code> later in
the file as <a href="https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc/lint/builtin.rs#L252-L290">part of a <code>lint_array!</code></a>; remove it too,</p>
<p>Next, you see see <a href="https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc_lint/lib.rs#L202-L205">a reference to <code>OVERLAPPING_INHERENT_IMPLS</code> in
<code>librustc_lint/lib.rs</code></a>. This defining the lint as a &quot;future
compatibility lint&quot;:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>FutureIncompatibleInfo {
    id: LintId::of(OVERLAPPING_INHERENT_IMPLS),
    reference: &quot;issue #36889 &lt;https://github.com/rust-lang/rust/issues/36889&gt;&quot;,
},
<span class="boring">}
</span></code></pre></pre>
<p>Remove this too.</p>
<h4><a class="header" href="#add-the-lint-to-the-list-of-removed-lists" id="add-the-lint-to-the-list-of-removed-lists">Add the lint to the list of removed lists.</a></h4>
<p>In <code>src/librustc_lint/lib.rs</code> there is a list of &quot;renamed and removed lints&quot;.
You can add this lint to the list:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>store.register_removed(&quot;overlapping_inherent_impls&quot;, &quot;converted into hard error, see #36889&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>where <code>#36889</code> is the tracking issue for your lint.</p>
<h4><a class="header" href="#update-the-places-that-issue-the-lint" id="update-the-places-that-issue-the-lint">Update the places that issue the lint</a></h4>
<p>Finally, the last class of references you will see are the places that actually
<strong>trigger</strong> the lint itself (i.e., what causes the warnings to appear). These
you do not want to delete. Instead, you want to convert them into errors. In
this case, the <a href="https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc_typeck/coherence/inherent.rs#L300-L303"><code>add_lint</code> call</a> looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,
                       node_id,
                       self.tcx.span_of_impl(item1).unwrap(),
                       msg);
<span class="boring">}
</span></code></pre></pre>
<p>We want to convert this into an error. In some cases, there may be an
existing error for this scenario. In others, we will need to allocate a
fresh diagnostic code.  <a href="./diagnostics/diagnostic-codes.html">Instructions for allocating a fresh diagnostic
code can be found here.</a> You may want
to mention in the extended description that the compiler behavior
changed on this point, and include a reference to the tracking issue for
the change.</p>
<p>Let's say that we've adopted <code>E0592</code> as our code. Then we can change the
<code>add_lint()</code> call above to something like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct_span_err!(self.tcx.sess, self.tcx.span_of_impl(item1).unwrap(), msg)
    .emit();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#update-tests" id="update-tests">Update tests</a></h4>
<p>Finally, run the test suite. These should be some tests that used to reference
the <code>overlapping_inherent_impls</code> lint, those will need to be updated. In
general, if the test used to have <code>#[deny(overlapping_inherent_impls)]</code>, that
can just be removed.</p>
<pre><code>./x.py test
</code></pre>
<h4><a class="header" href="#all-done" id="all-done">All done!</a></h4>
<p>Open a PR. =)</p>
<!-- -Links--------------------------------------------------------------------- -->
<h1><a class="header" href="#implement-new-feature" id="implement-new-feature">Implement New Feature</a></h1>
<p>When you want to implement a new significant feature in the compiler,
you need to go through this process to make sure everything goes
smoothly.</p>
<h2><a class="header" href="#the-rfcbot-pfcp-process" id="the-rfcbot-pfcp-process">The @rfcbot (p)FCP process</a></h2>
<p>When the change is small and uncontroversial, then it can be done
with just writing a PR and getting r+ from someone who knows that
part of the code. However, if the change is potentially controversial,
it would be a bad idea to push it without consensus from the rest
of the team (both in the &quot;distributed system&quot; sense to make sure
you don't break anything you don't know about, and in the social
sense to avoid PR fights).</p>
<p>If such a change seems to be too small to require a full formal RFC
process (e.g. a big refactoring of the code, or a
&quot;technically-breaking&quot; change, or a &quot;big bugfix&quot; that basically
amounts to a small feature) but is still too controversial or
big to get by with a single r+, you can start a pFCP (or, if you
don't have r+ rights, ask someone who has them to start one - and
unless they have a concern themselves, they should).</p>
<p>Again, the pFCP process is only needed if you need consensus - if you
don't think anyone would have a problem with your change, it's ok to
get by with only an r+. For example, it is OK to add or modify
unstable command-line flags or attributes without an pFCP for
compiler development or standard library use, as long as you don't
expect them to be in wide use in the nightly ecosystem.</p>
<p>You don't need to have the implementation fully ready for r+ to ask
for a pFCP, but it is generally a good idea to have at least a proof
of concept so that people can see what you are talking about.</p>
<p>That starts a &quot;proposed final comment period&quot; (pFCP), which requires
all members of the team to sign off the FCP. After they all do so,
there's a 10 day long &quot;final comment period&quot; where everybody can comment,
and if no new concerns are raised, the PR/issue gets FCP approval.</p>
<h2><a class="header" href="#the-logistics-of-writing-features" id="the-logistics-of-writing-features">The logistics of writing features</a></h2>
<p>There are a few &quot;logistic&quot; hoops you might need to go through in
order to implement a feature in a working way.</p>
<h3><a class="header" href="#warning-cycles" id="warning-cycles">Warning Cycles</a></h3>
<p>In some cases, a feature or bugfix might break some existing programs
in some edge cases. In that case, you might want to do a crater run
to assess the impact and possibly add a future-compatibility lint,
similar to those used for
<a href="diagnostics.html#edition-gated-lints">edition-gated lints</a>.</p>
<h3><a class="header" href="#stability" id="stability">Stability</a></h3>
<p>We <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">value the stability of Rust</a>. Code that works and runs on stable
should (mostly) not break. Because of that, we don't want to release
a feature to the world with only team consensus and code review -
we want to gain real-world experience on using that feature on nightly,
and we might want to change the feature based on that experience.</p>
<p>To allow for that, we must make sure users don't accidentally depend
on that new feature - otherwise, especially if experimentation takes
time or is delayed and the feature takes the trains to stable,
it would end up de facto stable and we'll not be able to make changes
in it without breaking people's code.</p>
<p>The way we do that is that we make sure all new features are feature
gated - they can't be used without enabling a feature gate
(<code>#[feature(foo)]</code>), which can't be done in a stable/beta compiler.
See the <a href="implementing_new_features.html#stability-in-code">stability in code</a> section for the technical details.</p>
<p>Eventually, after we gain enough experience using the feature,
make the necessary changes, and are satisfied, we expose it to
the world using the stabilization process described <a href="./stabilization_guide.html">here</a>.
Until then, the feature is not set in stone: every part of the
feature can be changed, or the feature might be completely
rewritten or removed. Features are not supposed to gain tenure
by being unstable and unchanged for a year.</p>
<p><a name = "tracking-issue"></a></p>
<h3><a class="header" href="#tracking-issues" id="tracking-issues">Tracking Issues</a></h3>
<p>To keep track of the status of an unstable feature, the
experience we get while using it on nightly, and of the
concerns that block its stabilization, every feature-gate
needs a tracking issue.</p>
<p>General discussions about the feature should be done on
the tracking issue.</p>
<p>For features that have an RFC, you should use the RFC's
tracking issue for the feature.</p>
<p>For other features, you'll have to make a tracking issue
for that feature. The issue title should be &quot;Tracking issue
for YOUR FEATURE&quot;.</p>
<p>For tracking issues for features (as opposed to future-compat
warnings), I don't think the description has to contain
anything specific. Generally we put the list of items required
for stabilization in a checklist, e.g.,</p>
<pre><code class="language-txt">**Steps:**

- [ ] Implement the RFC. (CC @rust-lang/compiler -- can anyone write
      up mentoring instructions?)
- [ ] Adjust the documentation. ([See instructions on rustc-dev-guide.](https://rustc-dev-guide.rust-lang.org/stabilization_guide.html#documentation-prs))
- [ ] Stabilize the feature. ([See instructions on rustc-dev-guide.](https://rustc-dev-guide.rust-lang.org/stabilization_guide.html#stabilization-pr))
</code></pre>
<p><a name="stability-in-code"></a></p>
<h2><a class="header" href="#stability-in-code" id="stability-in-code">Stability in code</a></h2>
<p>The below steps needs to be followed in order to implement
a new unstable feature:</p>
<ol>
<li>
<p>Open a <a href="implementing_new_features.html#tracking-issue">tracking issue</a> -
if you have an RFC, you can use the tracking issue for the RFC.</p>
<p>The tracking issue should be labeled with at least <code>C-tracking-issue</code>.
For a language feature, a label <code>F-feature_name</code> should be added as well.</p>
</li>
<li>
<p>Pick a name for the feature gate (for RFCs, use the name
in the RFC).</p>
</li>
<li>
<p>Add a feature gate declaration to <code>librustc_feature/active.rs</code>
in the active <code>declare_features</code> block:</p>
<pre><code class="language-rust ignore">/// description of feature
(active, $feature_name, &quot;$current_nightly_version&quot;, Some($tracking_issue_number), $edition)
</code></pre>
<p>where <code>$edition</code> has the type <code>Option&lt;Edition&gt;</code>, and is typically
just <code>None</code>.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">/// Allows defining identifiers beyond ASCII.
(active, non_ascii_idents, &quot;1.0.0&quot;, Some(55467), None),
</code></pre>
<p>When added, the current version should be the one for the current nightly.
Once the feature is moved to <code>accepted.rs</code>, the version is changed to that nightly version.</p>
</li>
<li>
<p>Prevent usage of the new feature unless the feature gate is set.
You can check it in most places in the compiler using the
expression <code>tcx.features().$feature_name</code> (or
<code>sess.features_untracked().$feature_name</code> if the
tcx is unavailable)</p>
<p>If the feature gate is not set, you should either maintain
the pre-feature behavior or raise an error, depending on
what makes sense.</p>
<p>For features introducing new syntax, pre-expansion gating should be used instead.
To do so, extend the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html"><code>GatedSpans</code></a> struct, add spans to it during parsing,
and then finally feature-gate all the spans in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast_passes/feature_gate/fn.check_crate.html"><code>rustc_ast_passes::feature_gate::check_crate</code></a>.</p>
</li>
<li>
<p>Add a test to ensure the feature cannot be used without
a feature gate, by creating <code>feature-gate-$feature_name.rs</code>
and <code>feature-gate-$feature_name.stderr</code> files under the
directory where the other tests for your feature reside.</p>
</li>
<li>
<p>Add a section to the unstable book, in
<code>src/doc/unstable-book/src/language-features/$feature_name.md</code>.</p>
</li>
<li>
<p>Write a lots of tests for the new feature.
PRs without tests will not be accepted!</p>
</li>
<li>
<p>Get your PR reviewed and land it. You have now successfully
implemented a feature in Rust!</p>
</li>
</ol>
<h1><a class="header" href="#stability-attributes" id="stability-attributes">Stability attributes</a></h1>
<p>This section is about the stability attributes and schemes that allow stable
APIs to use unstable APIs internally in the rustc standard library.</p>
<p>For instructions on stabilizing a language feature see <a href="./stabilization_guide.html">Stabilizing
Features</a>.</p>
<h2><a class="header" href="#unstable" id="unstable">unstable</a></h2>
<p>The <code>#[unstable(feature = &quot;foo&quot;, issue = &quot;1234&quot;, reason = &quot;lorem ipsum&quot;)]</code>
attribute explicitly marks an item as unstable. Items that are marked as
&quot;unstable&quot; cannot be used without a corresponding <code>#![feature]</code> attribute on
the crate, even on a nightly compiler. This restriction only applies across
crate boundaries, unstable items may be used within the crate that defines
them.</p>
<p>The <code>issue</code> field specifies the associated GitHub <a href="https://github.com/rust-lang/rust/issues">issue number</a>. This field is
required and all unstable features should have an associated tracking issue. In
rare cases where there is no sensible value <code>issue = &quot;none&quot;</code> is used.</p>
<p>The <code>unstable</code> attribute infects all sub-items, where the attribute doesn't
have to be reapplied. So if you apply this to a module, all items in the module
will be unstable.</p>
<p>You can make specific sub-items stable by using the <code>#[stable]</code> attribute on
them. The stability scheme works similarly to how <code>pub</code> works. You can have
public functions of nonpublic modules and you can have stable functions in
unstable modules or vice versa.</p>
<p>Note, however, that due to a <a href="https://github.com/rust-lang/rust/issues/15702">rustc bug</a>, stable items inside unstable modules
<em>are</em> available to stable code in that location!  So, for example, stable code
can import <code>core::intrinsics::transmute</code> even though <code>intrinsics</code> is an
unstable module.  Thus, this kind of nesting should be avoided when possible.</p>
<p>The <code>unstable</code> attribute may also have the <code>soft</code> value, which makes it a
future-incompatible deny-by-default lint instead of a hard error. This is used
by the <code>bench</code> attribute which was accidentally accepted in the past. This
prevents breaking dependencies by leveraging Cargo's lint capping.</p>
<h2><a class="header" href="#stable" id="stable">stable</a></h2>
<p>The <code>#[stable(feature = &quot;foo&quot;, &quot;since = &quot;1.420.69&quot;)]</code> attribute explicitly
marks an item as stabilized. To do this, follow the instructions in
<a href="./stabilization_guide.html">Stabilizing Features</a>.</p>
<p>Note that stable functions may use unstable things in their body.</p>
<h2><a class="header" href="#rustc_const_unstable" id="rustc_const_unstable">rustc_const_unstable</a></h2>
<p>The <code>#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;1234&quot;, reason = &quot;lorem ipsum&quot;)]</code>
has the same interface as the <code>unstable</code> attribute. It is used to mark
<code>const fn</code> as having their constness be unstable. This allows you to make a
function stable without stabilizing its constness or even just marking an existing
stable function as <code>const fn</code> without instantly stabilizing the <code>const fn</code>ness.</p>
<p>Furthermore this attribute is needed to mark an intrinsic as <code>const fn</code>, because
there's no way to add <code>const</code> to functions in <code>extern</code> blocks for now.</p>
<h2><a class="header" href="#rustc_const_stable" id="rustc_const_stable">rustc_const_stable</a></h2>
<p>The <code>#[stable(feature = &quot;foo&quot;, &quot;since = &quot;1.420.69&quot;)]</code> attribute explicitly marks
a <code>const fn</code> as having its constness be <code>stable</code>. This attribute can make sense
even on an <code>unstable</code> function, if that function is called from another
<code>rustc_const_stable</code> function.</p>
<p>Furthermore this attribute is needed to mark an intrinsic as callable from
<code>rustc_const_stable</code> functions.</p>
<h2><a class="header" href="#allow_internal_unstable" id="allow_internal_unstable">allow_internal_unstable</a></h2>
<p>Macros, compiler desugarings and <code>const fn</code>s expose their bodies to the call
site. To work around not being able to use unstable things in the standard
library's macros, there's the <code>#[allow_internal_unstable(feature1, feature2)]</code>
attribute that whitelists the given features for usage in stable macros or
<code>const fn</code>s.</p>
<p>Note that <code>const fn</code>s are even more special in this regard. You can't just
whitelist any feature, the features need an implementation in
<code>qualify_min_const_fn.rs</code>. For example the <code>const_fn_union</code> feature gate allows
accessing fields of unions inside stable <code>const fn</code>s. The rules for when it's
ok to use such a feature gate are that behavior matches the runtime behavior of
the same code (see also <a href="https://www.ralfj.de/blog/2018/07/19/const.html">this blog post</a>). This means that you may not
create a <code>const fn</code> that e.g. transmutes a memory address to an integer,
because the addresses of things are nondeterministic and often unknown at
compile-time.</p>
<p>Always ping @oli-obk, @RalfJung, and @Centril if you are adding more
<code>allow_internal_unstable</code> attributes to any <code>const fn</code></p>
<h2><a class="header" href="#staged_api" id="staged_api">staged_api</a></h2>
<p>Any crate that uses the <code>stable</code>, <code>unstable</code>, or <code>rustc_deprecated</code> attributes
must include the <code>#![feature(staged_api)]</code> attribute on the crate.</p>
<h2><a class="header" href="#rustc_deprecated" id="rustc_deprecated">rustc_deprecated</a></h2>
<p>The deprecation system shares the same infrastructure as the stable/unstable
attributes. The <code>rustc_deprecated</code> attribute is similar to the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code>
attribute</a>. It was previously called <code>deprecated</code>, but was split off when
<code>deprecated</code> was stabilized. The <code>deprecated</code> attribute cannot be used in a
<code>staged_api</code> crate, <code>rustc_deprecated</code> must be used instead. The deprecated
item must also have a <code>stable</code> or <code>unstable</code> attribute.</p>
<p><code>rustc_deprecated</code> has the following form:</p>
<pre><code class="language-rust ignore">#[rustc_deprecated(
    since = &quot;1.38.0&quot;,
    reason = &quot;explanation for deprecation&quot;,
    suggestion = &quot;other_function&quot;
)]
</code></pre>
<p>The <code>suggestion</code> field is optional. If given, it should be a string that can be
used as a machine-applicable suggestion to correct the warning. This is
typically used when the identifier is renamed, but no other significant changes
are necessary.</p>
<p>Another difference from the <code>deprecated</code> attribute is that the <code>since</code> field is
actually checked against the current version of <code>rustc</code>. If <code>since</code> is in a
future version, then the <code>deprecated_in_future</code> lint is triggered which is
default <code>allow</code>, but most of the standard library raises it to a warning with
<code>#![warn(deprecated_in_future)]</code>.</p>
<h2><a class="header" href="#-zforce-unstable-if-unmarked" id="-zforce-unstable-if-unmarked">-Zforce-unstable-if-unmarked</a></h2>
<p>The <code>-Zforce-unstable-if-unmarked</code> flag has a variety of purposes to help
enforce that the correct crates are marked as unstable. It was introduced
primarily to allow rustc and the standard library to link to arbitrary crates
on crates.io which do not themselves use <code>staged_api</code>. <code>rustc</code> also relies on
this flag to mark all of its crates as unstable with the <code>rustc_private</code>
feature so that each crate does not need to be carefully marked with
<code>unstable</code>.</p>
<p>This flag is automatically applied to all of <code>rustc</code> and the standard library
by the bootstrap scripts. This is needed because the compiler and all of its
dependencies are shipped in the sysroot to all users.</p>
<p>This flag has the following effects:</p>
<ul>
<li>Marks the crate as &quot;unstable&quot; with the <code>rustc_private</code> feature if it is not
itself marked as stable or unstable.</li>
<li>Allows these crates to access other forced-unstable crates without any need
for attributes. Normally a crate would need a <code>#![feature(rustc_private)]</code>
attribute to use other unstable crates. However, that would make it
impossible for a crate from crates.io to access its own dependencies since
that crate won't have a <code>feature(rustc_private)</code> attribute, but <em>everything</em>
is compiled with <code>-Zforce-unstable-if-unmarked</code>.</li>
</ul>
<p>Code which does not use <code>-Zforce-unstable-if-unmarked</code> should include the
<code>#![feature(rustc_private)]</code> crate attribute to access these force-unstable
crates. This is needed for things that link <code>rustc</code>, such as <code>miri</code>, <code>rls</code>, or
<code>clippy</code>.</p>
<h1><a class="header" href="#request-for-stabilization" id="request-for-stabilization">Request for stabilization</a></h1>
<p>Once an unstable feature has been well-tested with no outstanding
concern, anyone may push for its stabilization. It involves the
following steps.</p>
<ul>
<li>Documentation PRs</li>
<li>Write a stabilization report</li>
<li>FCP</li>
<li>Stabilization PR</li>
</ul>
<h2><a class="header" href="#documentation-prs" id="documentation-prs">Documentation PRs</a></h2>
<p><a name="updating-documentation"></a></p>
<p>If any documentation for this feature exists, it should be
in the <a href="https://doc.rust-lang.org/unstable-book/index.html"><code>Unstable Book</code></a>, located at <a href="https://github.com/rust-lang/rust/tree/master/src/doc/unstable-book"><code>src/doc/unstable-book</code></a>.
If it exists, the page for the feature gate should be removed.</p>
<p>If there was documentation there, integrating it into the
existing documentation is needed.</p>
<p>If there wasn't documentation there, it needs to be added.</p>
<p>Places that may need updated documentation:</p>
<ul>
<li><a href="https://github.com/rust-lang/reference">The Reference</a>: This must be updated, in full detail.</li>
<li><a href="https://github.com/rust-lang/book">The Book</a>: This may or may not need updating, depends.
If you're not sure, please open an issue on this repository
and it can be discussed.</li>
<li>standard library documentation: As needed. Language features
often don't need this, but if it's a feature that changes
how good examples are written, such as when <code>?</code> was added
to the language, updating examples is important.</li>
<li><a href="https://github.com/rust-lang/rust-by-example">Rust by Example</a>: As needed.</li>
</ul>
<p>Prepare PRs to update documentation involving this new feature
for repositories mentioned above. Maintainers of these repositories
will keep these PRs open until the whole stabilization process
has completed. Meanwhile, we can proceed to the next step.</p>
<h2><a class="header" href="#write-a-stabilization-report" id="write-a-stabilization-report">Write a stabilization report</a></h2>
<p>Find the tracking issue of the feature, and create a short
stabilization report. Essentially this would be a brief summary
of the feature plus some links to test cases showing it works
as expected, along with a list of edge cases that came up
and were considered. This is a minimal &quot;due diligence&quot; that
we do before stabilizing.</p>
<p>The report should contain:</p>
<ul>
<li>A summary, showing examples (e.g. code snippets) what is
enabled by this feature.</li>
<li>Links to test cases in our test suite regarding this feature
and describe the feature's behavior on encountering edge cases.</li>
<li>Links to the documentations (the PRs we have made in the
previous steps).</li>
<li>Any other relevant information(Examples of such reports can
be found in rust-lang/rust#44494 and rust-lang/rust#28237).</li>
<li>The resolutions of any unresolved questions if the stabilization
is for an RFC.</li>
</ul>
<h2><a class="header" href="#fcp" id="fcp">FCP</a></h2>
<p>If any member of the team responsible for tracking this
feature agrees with stabilizing this feature, they will
start the FCP (final-comment-period) process by commenting</p>
<pre><code class="language-bash">@rfcbot fcp merge
</code></pre>
<p>The rest of the team members will review the proposal. If the final
decision is to stabilize, we proceed to do the actual code modification.</p>
<h2><a class="header" href="#stabilization-pr" id="stabilization-pr">Stabilization PR</a></h2>
<p>Once we have decided to stabilize a feature, we need to have
a PR that actually makes that stabilization happen. These kinds
of PRs are a great way to get involved in Rust, as they take
you on a little tour through the source code.</p>
<p>Here is a general guide to how to stabilize a feature --
every feature is different, of course, so some features may
require steps beyond what this guide talks about.</p>
<p>Note: Before we stabilize any feature, it's the rule that it
should appear in the documentation.</p>
<h3><a class="header" href="#updating-the-feature-gate-listing" id="updating-the-feature-gate-listing">Updating the feature-gate listing</a></h3>
<p>There is a central listing of feature-gates in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_feature/index.html"><code>src/librustc_feature</code></a>. Search for the <code>declare_features!</code>
macro. There should be an entry for the feature you are aiming
to stabilize, something like (this example is taken from
<a href="https://github.com/rust-lang/rust/issues/32409">rust-lang/rust#32409</a>:</p>
<pre><code class="language-rust ignore">// pub(restricted) visibilities (RFC 1422)
(active, pub_restricted, &quot;1.9.0&quot;, Some(32409)),
</code></pre>
<p>The above line should be moved down to the area for &quot;accepted&quot;
features, declared below in a separate call to <code>declare_features!</code>.
When it is done, it should look like:</p>
<pre><code class="language-rust ignore">// pub(restricted) visibilities (RFC 1422)
(accepted, pub_restricted, &quot;1.31.0&quot;, Some(32409)),
// note that we changed this
</code></pre>
<p>Note that, the version number is updated to be the version number
of the stable release where this feature will appear. This can be
found by consulting <a href="https://forge.rust-lang.org/">the forge</a>, which will guide
you the next stable release number. You want to add 1 to that,
because the code that lands today will become go into beta on that
date, and then become stable after that. So, at the time of this
writing, the next stable release (i.e. what is currently beta) was
1.30.0, hence I wrote 1.31.0 above.</p>
<h3><a class="header" href="#removing-existing-uses-of-the-feature-gate" id="removing-existing-uses-of-the-feature-gate">Removing existing uses of the feature-gate</a></h3>
<p>Next search for the feature string (in this case, <code>pub_restricted</code>)
in the codebase to find where it appears. Change uses of
<code>#![feature(XXX)]</code> from the <code>libstd</code> and any rustc crates to be
<code>#![cfg_attr(bootstrap, feature(XXX))]</code>. This includes the feature-gate
only for stage0, which is built using the current beta (this is
needed because the feature is still unstable in the current beta).</p>
<p>Also, remove those strings from any tests. If there are tests
specifically targeting the feature-gate (i.e., testing that the
feature-gate is required to use the feature, but nothing else),
simply remove the test.</p>
<h3><a class="header" href="#do-not-require-the-feature-gate-to-use-the-feature" id="do-not-require-the-feature-gate-to-use-the-feature">Do not require the feature-gate to use the feature</a></h3>
<p>Most importantly, remove the code which flags an error if the
feature-gate is not present (since the feature is now considered
stable). If the feature can be detected because it employs some
new syntax, then a common place for that code to be is in the
same <code>src/librustc_ast_passes/feature_gate.rs</code>.
For example, you might see code like this:</p>
<pre><code class="language-rust ignore">gate_feature_post!(&amp;self, pub_restricted, span,
 &quot;`pub(restricted)` syntax is experimental&quot;);
</code></pre>
<p>This <code>gate_feature_post!</code> macro prints an error if the
<code>pub_restricted</code> feature is not enabled. It is not needed
now that <code>#[pub_restricted]</code> is stable.</p>
<p>For more subtle features, you may find code like this:</p>
<pre><code class="language-rust ignore">if self.tcx.sess.features.borrow().pub_restricted { /* XXX */ }
</code></pre>
<p>This <code>pub_restricted</code> field (obviously named after the feature)
would ordinarily be false if the feature flag is not present
and true if it is. So transform the code to assume that the field
is true. In this case, that would mean removing the <code>if</code> and
leaving just the <code>/* XXX */</code>.</p>
<pre><code class="language-rust ignore">if self.tcx.sess.features.borrow().pub_restricted { /* XXX */ }
becomes
/* XXX */

if self.tcx.sess.features.borrow().pub_restricted &amp;&amp; something { /* XXX */ }
 becomes
if something { /* XXX */ }
</code></pre>
<h1><a class="header" href="#debugging-the-compiler" id="debugging-the-compiler">Debugging the compiler</a></h1>
<p>This chapter contains a few tips to debug the compiler. These tips aim to be
useful no matter what you are working on.  Some of the other chapters have
advice about specific parts of the compiler (e.g. the <a href="./incrcomp-debugging.html">Queries Debugging and
Testing chapter</a> or the <a href="./backend/debugging.html">LLVM Debugging
chapter</a>).</p>
<h2><a class="header" href="#-z-flags" id="-z-flags"><code>-Z</code> flags</a></h2>
<p>The compiler has a bunch of <code>-Z</code> flags. These are unstable flags that are only
enabled on nightly. Many of them are useful for debugging. To get a full listing
of <code>-Z</code> flags, use <code>-Z help</code>.</p>
<p>One useful flag is <code>-Z verbose</code>, which generally enables printing more info that
could be useful for debugging.</p>
<h2><a class="header" href="#getting-a-backtrace" id="getting-a-backtrace">Getting a backtrace</a></h2>
<p>When you have an ICE (panic in the compiler), you can set
<code>RUST_BACKTRACE=1</code> to get the stack trace of the <code>panic!</code> like in
normal Rust programs.  IIRC backtraces <strong>don't work</strong> on MinGW,
sorry. If you have trouble or the backtraces are full of <code>unknown</code>,
you might want to find some way to use Linux, Mac, or MSVC on Windows.</p>
<p>In the default configuration, you don't have line numbers enabled, so the
backtrace looks like this:</p>
<pre><code class="language-text">stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
   1: std::sys_common::backtrace::_print
   2: std::panicking::default_hook::{{closure}}
   3: std::panicking::default_hook
   4: std::panicking::rust_panic_with_hook
   5: std::panicking::begin_panic
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
  32: rustc_typeck::check_crate
  33: &lt;std::thread::local::LocalKey&lt;T&gt;&gt;::with
  34: &lt;std::thread::local::LocalKey&lt;T&gt;&gt;::with
  35: rustc::ty::context::TyCtxt::create_and_enter
  36: rustc_driver::driver::compile_input
  37: rustc_driver::run_compiler
</code></pre>
<p>If you want line numbers for the stack trace, you can enable <code>debug = true</code> in
your config.toml and rebuild the compiler (<code>debuginfo-level = 1</code> will also add
line numbers, but <code>debug = true</code> gives full debuginfo). Then the backtrace will
look like this:</p>
<pre><code class="language-text">stack backtrace:
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
             at /home/user/rust/src/librustc_typeck/check/cast.rs:110
   7: rustc_typeck::check::cast::CastCheck::check
             at /home/user/rust/src/librustc_typeck/check/cast.rs:572
             at /home/user/rust/src/librustc_typeck/check/cast.rs:460
             at /home/user/rust/src/librustc_typeck/check/cast.rs:370
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
  33: rustc_driver::driver::compile_input
             at /home/user/rust/src/librustc_driver/driver.rs:1010
             at /home/user/rust/src/librustc_driver/driver.rs:212
  34: rustc_driver::run_compiler
             at /home/user/rust/src/librustc_driver/lib.rs:253
</code></pre>
<h2><a class="header" href="#getting-a-backtrace-for-errors" id="getting-a-backtrace-for-errors">Getting a backtrace for errors</a></h2>
<p>If you want to get a backtrace to the point where the compiler emits an
error message, you can pass the <code>-Z treat-err-as-bug=n</code>, which will make
the compiler panic on the <code>nth</code> error on <code>delay_span_bug.</code> If you leave
off <code>=n</code>, the compiler will assume <code>1</code> for <code>n</code> and thus panic on the
first error it encounters.</p>
<p>This can also help when debugging <code>delay_span_bug</code> calls - it will make
the first <code>delay_span_bug</code> call panic, which will give you a useful backtrace.</p>
<p>For example:</p>
<pre><code class="language-bash">$ cat error.rs
fn main() {
    1 + ();
}
</code></pre>
<pre><code class="language-bash">$ ./build/x86_64-unknown-linux-gnu/stage1/bin/rustc error.rs
error[E0277]: the trait bound `{integer}: std::ops::Add&lt;()&gt;` is not satisfied
 --&gt; error.rs:2:7
  |
2 |     1 + ();
  |       ^ no implementation for `{integer} + ()`
  |
  = help: the trait `std::ops::Add&lt;()&gt;` is not implemented for `{integer}`

error: aborting due to previous error

$ # Now, where does the error above come from?
$ RUST_BACKTRACE=1 \
    ./build/x86_64-unknown-linux-gnu/stage1/bin/rustc \
    error.rs \
    -Z treat-err-as-bug
error[E0277]: the trait bound `{integer}: std::ops::Add&lt;()&gt;` is not satisfied
 --&gt; error.rs:2:7
  |
2 |     1 + ();
  |       ^ no implementation for `{integer} + ()`
  |
  = help: the trait `std::ops::Add&lt;()&gt;` is not implemented for `{integer}`

error: internal compiler error: unexpected panic

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports

note: rustc 1.24.0-dev running on x86_64-unknown-linux-gnu

note: run with `RUST_BACKTRACE=1` for a backtrace

thread 'rustc' panicked at 'encountered error with `-Z treat_err_as_bug',
/home/user/rust/src/librustc_errors/lib.rs:411:12
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose
backtrace.
stack backtrace:
  (~~~ IRRELEVANT PART OF BACKTRACE REMOVED BY ME ~~~)
   7: rustc::traits::error_reporting::&lt;impl rustc::infer::InferCtxt&lt;'a, 'tcx&gt;&gt;
             ::report_selection_error
             at /home/user/rust/src/librustc_middle/traits/error_reporting.rs:823
   8: rustc::traits::error_reporting::&lt;impl rustc::infer::InferCtxt&lt;'a, 'tcx&gt;&gt;
             ::report_fulfillment_errors
             at /home/user/rust/src/librustc_middle/traits/error_reporting.rs:160
             at /home/user/rust/src/librustc_middle/traits/error_reporting.rs:112
   9: rustc_typeck::check::FnCtxt::select_obligations_where_possible
             at /home/user/rust/src/librustc_typeck/check/mod.rs:2192
  (~~~ IRRELEVANT PART OF BACKTRACE REMOVED BY ME ~~~)
  36: rustc_driver::run_compiler
             at /home/user/rust/src/librustc_driver/lib.rs:253
$ # Cool, now I have a backtrace for the error
</code></pre>
<h2><a class="header" href="#getting-logging-output" id="getting-logging-output">Getting logging output</a></h2>
<p>These crates are used in compiler for logging:</p>
<ul>
<li><a href="https://docs.rs/log/0.4.6/log/index.html">log</a></li>
<li><a href="https://docs.rs/env_logger/0.4.3/env_logger/">env-logger</a>: check the link to see the full <code>RUSTC_LOG</code> syntax</li>
</ul>
<p>The compiler has a lot of <code>debug!</code> calls, which print out logging information
at many points. These are very useful to at least narrow down the location of
a bug if not to find it entirely, or just to orient yourself as to why the
compiler is doing a particular thing.</p>
<p>To see the logs, you need to set the <code>RUSTC_LOG</code> environment variable to
your log filter, e.g. to get the logs for a specific module, you can run the
compiler as <code>RUSTC_LOG=module::path rustc my-file.rs</code>. All <code>debug!</code> output will
then appear in standard error.</p>
<p><strong>Note that unless you use a very strict filter, the logger will emit a lot of
output, so use the most specific module(s) you can (comma-separated if
multiple)</strong>. It's typically a good idea to pipe standard error to a file and
look at the log output with a text editor.</p>
<p>So to put it together.</p>
<pre><code class="language-bash"># This puts the output of all debug calls in `librustc_middle/traits` into
# standard error, which might fill your console backscroll.
$ RUSTC_LOG=rustc::traits rustc +local my-file.rs

# This puts the output of all debug calls in `librustc_middle/traits` in
# `traits-log`, so you can then see it with a text editor.
$ RUSTC_LOG=rustc::traits rustc +local my-file.rs 2&gt;traits-log

# Not recommended. This will show the output of all `debug!` calls
# in the Rust compiler, and there are a *lot* of them, so it will be
# hard to find anything.
$ RUSTC_LOG=debug rustc +local my-file.rs 2&gt;all-log

# This will show the output of all `info!` calls in `rustc_trans`.
#
# There's an `info!` statement in `trans_instance` that outputs
# every function that is translated. This is useful to find out
# which function triggers an LLVM assertion, and this is an `info!`
# log rather than a `debug!` log so it will work on the official
# compilers.
$ RUSTC_LOG=rustc_trans=info rustc +local my-file.rs
</code></pre>
<h3><a class="header" href="#how-to-keep-or-remove-debug-and-trace-calls-from-the-resulting-binary" id="how-to-keep-or-remove-debug-and-trace-calls-from-the-resulting-binary">How to keep or remove <code>debug!</code> and <code>trace!</code> calls from the resulting binary</a></h3>
<p>While calls to <code>error!</code>, <code>warn!</code> and <code>info!</code> are included in every build of the compiler,
calls to <code>debug!</code> and <code>trace!</code> are only included in the program if
<code>debug-assertions=yes</code> is turned on in config.toml (it is
turned off by default), so if you don't see <code>DEBUG</code> logs, especially
if you run the compiler with <code>RUSTC_LOG=rustc rustc some.rs</code> and only see
<code>INFO</code> logs, make sure that <code>debug-assertions=yes</code> is turned on in your
config.toml.</p>
<p>In some cases, just setting it will not trigger a rebuild,
so if you changed it and you already have a compiler built, you might
want to call <code>x.py clean</code> to force one.</p>
<h3><a class="header" href="#logging-etiquette-and-conventions" id="logging-etiquette-and-conventions">Logging etiquette and conventions</a></h3>
<p>Because calls to <code>debug!</code> are removed by default, in most cases, don't worry
about adding &quot;unnecessary&quot; calls to <code>debug!</code> and leaving them in code you
commit - they won't slow down the performance of what we ship, and if they
helped you pinning down a bug, they will probably help someone else with a
different one.</p>
<p>A loosely followed convention is to use <code>debug!(&quot;foo(...)&quot;)</code> at the <em>start</em> of
a function <code>foo</code> and <code>debug!(&quot;foo: ...&quot;)</code> <em>within</em> the function. Another
loosely followed convention is to use the <code>{:?}</code> format specifier for debug
logs.</p>
<p>One thing to be <strong>careful</strong> of is <strong>expensive</strong> operations in logs.</p>
<p>If in the module <code>rustc::foo</code> you have a statement</p>
<pre><code class="language-Rust">debug!(&quot;{:?}&quot;, random_operation(tcx));
</code></pre>
<p>Then if someone runs a debug <code>rustc</code> with <code>RUSTC_LOG=rustc::bar</code>, then
<code>random_operation()</code> will run.</p>
<p>This means that you should not put anything too expensive or likely to crash
there - that would annoy anyone who wants to use logging for their own module.
No-one will know it until someone tries to use logging to find <em>another</em> bug.</p>
<h2><a class="header" href="#formatting-graphviz-output-dot-files" id="formatting-graphviz-output-dot-files">Formatting Graphviz output (.dot files)</a></h2>
<p>Some compiler options for debugging specific features yield graphviz graphs -
e.g. the <code>#[rustc_mir(borrowck_graphviz_postflow=&quot;suffix.dot&quot;)]</code> attribute
dumps various borrow-checker dataflow graphs.</p>
<p>These all produce <code>.dot</code> files. To view these files, install graphviz (e.g.
<code>apt-get install graphviz</code>) and then run the following commands:</p>
<pre><code class="language-bash">$ dot -T pdf maybe_init_suffix.dot &gt; maybe_init_suffix.pdf
$ firefox maybe_init_suffix.pdf # Or your favorite pdf viewer
</code></pre>
<h2><a class="header" href="#narrowing-bisecting-regressions" id="narrowing-bisecting-regressions">Narrowing (Bisecting) Regressions</a></h2>
<p>The <a href="https://github.com/rust-lang/cargo-bisect-rustc">cargo-bisect-rustc</a> tool can be used as a quick and easy way to
find exactly which PR caused a change in <code>rustc</code> behavior. It automatically
downloads <code>rustc</code> PR artifacts and tests them against a project you provide
until it finds the regression. You can then look at the PR to get more context
on <em>why</em> it was changed.  See <a href="https://github.com/rust-lang/cargo-bisect-rustc/blob/master/TUTORIAL.md">this tutorial</a> on how to use
it.</p>
<h2><a class="header" href="#downloading-artifacts-from-rusts-ci" id="downloading-artifacts-from-rusts-ci">Downloading Artifacts from Rust's CI</a></h2>
<p>The <a href="https://github.com/kennytm/rustup-toolchain-install-master">rustup-toolchain-install-master</a> tool by kennytm can be used to
download the artifacts produced by Rust's CI for a specific SHA1 -- this
basically corresponds to the successful landing of some PR -- and then sets
them up for your local use. This also works for artifacts produced by <code>@bors try</code>. This is helpful when you want to examine the resulting build of a PR
without doing the build yourself.</p>
<h1><a class="header" href="#profiling-the-compiler" id="profiling-the-compiler">Profiling the compiler</a></h1>
<p>This section talks about how to profile the compiler and find out where it spends its time.</p>
<p>Depending on what you're trying to measure, there are several different approaches:</p>
<ul>
<li>
<p>If you want to see if a PR improves or regresses compiler performance:</p>
<ul>
<li>The <a href="https://github.com/rust-lang/rustc-perf">rustc-perf</a> project makes this easy and can be triggered to run on a PR via the <code>@rustc-perf</code> bot.</li>
</ul>
</li>
<li>
<p>If you want a medium-to-high level overview of where <code>rustc</code> is spending its time:</p>
<ul>
<li>The <code>-Zself-profile</code> flag and <a href="https://github.com/rust-lang/measureme">measureme</a> tools offer a query-based approach to profiling.
See <a href="https://github.com/rust-lang/measureme/blob/master/summarize/Readme.md">their docs</a> for more information.</li>
</ul>
</li>
<li>
<p>If you want function level performance data or even just more details than the above approaches:</p>
<ul>
<li>Consider using a native code profiler such as <a href="profiling/with_perf.html">perf</a>.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#profiling-with-perf" id="profiling-with-perf">Profiling with perf</a></h1>
<p>This is a guide for how to profile rustc with <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a>.</p>
<h2><a class="header" href="#initial-steps" id="initial-steps">Initial steps</a></h2>
<ul>
<li>Get a clean checkout of rust-lang/master, or whatever it is you want
to profile.</li>
<li>Set the following settings in your <code>config.toml</code>:
<ul>
<li><code>debuginfo-level = 1</code> - enables line debuginfo</li>
<li><code>jemalloc = false</code> - lets you do memory use profiling with valgrind</li>
<li>leave everything else the defaults</li>
</ul>
</li>
<li>Run <code>./x.py build</code> to get a full build</li>
<li>Make a rustup toolchain pointing to that result
<ul>
<li>see <a href="profiling/../building/how-to-build-and-run.html#toolchain">the &quot;build and run&quot; section for instructions</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#gathering-a-perf-profile" id="gathering-a-perf-profile">Gathering a perf profile</a></h2>
<p>perf is an excellent tool on linux that can be used to gather and
analyze all kinds of information. Mostly it is used to figure out
where a program spends its time. It can also be used for other sorts
of events, though, like cache misses and so forth.</p>
<h3><a class="header" href="#the-basics" id="the-basics">The basics</a></h3>
<p>The basic <code>perf</code> command is this:</p>
<pre><code class="language-bash">perf record -F99 --call-graph dwarf XXX
</code></pre>
<p>The <code>-F99</code> tells perf to sample at 99 Hz, which avoids generating too
much data for longer runs (why 99 Hz you ask? It is often chosen
because it is unlikely to be in lockstep with other periodic
activity). The <code>--call-graph dwarf</code> tells perf to get call-graph
information from debuginfo, which is accurate. The <code>XXX</code> is the
command you want to profile. So, for example, you might do:</p>
<pre><code class="language-bash">perf record -F99 --call-graph dwarf cargo +&lt;toolchain&gt; rustc
</code></pre>
<p>to run <code>cargo</code> -- here <code>&lt;toolchain&gt;</code> should be the name of the toolchain
you made in the beginning. But there are some things to be aware of:</p>
<ul>
<li>You probably don't want to profile the time spend building
dependencies. So something like <code>cargo build; cargo clean -p $C</code> may
be helpful (where <code>$C</code> is the crate name)
<ul>
<li>Though usually I just do <code>touch src/lib.rs</code> and rebuild instead. =)</li>
</ul>
</li>
<li>You probably don't want incremental messing about with your
profile. So something like <code>CARGO_INCREMENTAL=0</code> can be helpful.</li>
</ul>
<h3><a class="header" href="#gathering-a-perf-profile-from-a-perfrust-langorg-test" id="gathering-a-perf-profile-from-a-perfrust-langorg-test">Gathering a perf profile from a <code>perf.rust-lang.org</code> test</a></h3>
<p>Often we want to analyze a specific test from <code>perf.rust-lang.org</code>. To
do that, the first step is to clone
<a href="https://github.com/rust-lang/rustc-perf">the rustc-perf repository</a>:</p>
<pre><code class="language-bash">git clone https://github.com/rust-lang/rustc-perf
</code></pre>
<h4><a class="header" href="#doing-it-the-easy-way" id="doing-it-the-easy-way">Doing it the easy way</a></h4>
<p>Once you've cloned the repo, you can use the <code>collector</code> executable to
do profiling for you! You can find
<a href="https://github.com/rust-lang/rustc-perf/blob/master/collector/README.md#profiling">instructions in the rustc-perf readme</a>.</p>
<p>For example, to measure the clap-rs test, you might do:</p>
<pre><code class="language-bash">./target/release/collector                                      \
  --output-repo /path/to/place/output                           \
  profile perf-record                                           \
  --rustc /path/to/rustc/executable/from/your/build/directory   \
  --cargo `which cargo`                                         \
  --filter clap-rs                                              \
  --builds Check                                                \
</code></pre>
<p>You can also use that same command to use cachegrind or other profiling tools.</p>
<h4><a class="header" href="#doing-it-the-hard-way" id="doing-it-the-hard-way">Doing it the hard way</a></h4>
<p>If you prefer to run things manually, that is also possible. You first
need to find the source for the test you want. Sources for the tests
are found in <a href="https://github.com/rust-lang/rustc-perf/tree/master/collector/benchmarks">the <code>collector/benchmarks</code> directory</a>. So let's go
into the directory of a specific test; we'll use <code>clap-rs</code> as an
example:</p>
<pre><code class="language-bash">cd collector/benchmarks/clap-rs
</code></pre>
<p>In this case, let's say we want to profile the <code>cargo check</code>
performance. In that case, I would first run some basic commands to
build the dependencies:</p>
<pre><code class="language-bash"># Setup: first clean out any old results and build the dependencies:
cargo +&lt;toolchain&gt; clean
CARGO_INCREMENTAL=0 cargo +&lt;toolchain&gt; check
</code></pre>
<p>(Again, <code>&lt;toolchain&gt;</code> should be replaced with the name of the
toolchain we made in the first step.)</p>
<p>Next: we want record the execution time for <em>just</em> the clap-rs crate,
running cargo check. I tend to use <code>cargo rustc</code> for this, since it
also allows me to add explicit flags, which we'll do later on.</p>
<pre><code class="language-bash">touch src/lib.rs
CARGO_INCREMENTAL=0 perf record -F99 --call-graph dwarf cargo rustc --profile check --lib
</code></pre>
<p>Note that final command: it's a doozy! It uses the <code>cargo rustc</code>
command, which executes rustc with (potentially) additional options;
the <code>--profile check</code> and <code>--lib</code> options specify that we are doing a
<code>cargo check</code> execution, and that this is a library (not a binary).</p>
<p>At this point, we can use <code>perf</code> tooling to analyze the results. For example:</p>
<pre><code class="language-bash">perf report
</code></pre>
<p>will open up an interactive TUI program. In simple cases, that can be
helpful. For more detailed examination, the <a href="https://github.com/nikomatsakis/perf-focus"><code>perf-focus</code> tool</a>
can be helpful; it is covered below.</p>
<p><strong>A note of caution.</strong> Each of the rustc-perf tests is its own special
snowflake. In particular, some of them are not libraries, in which
case you would want to do <code>touch src/main.rs</code> and avoid passing
<code>--lib</code>. I'm not sure how best to tell which test is which to be
honest.</p>
<h3><a class="header" href="#gathering-nll-data" id="gathering-nll-data">Gathering NLL data</a></h3>
<p>If you want to profile an NLL run, you can just pass extra options to
the <code>cargo rustc</code> command, like so:</p>
<pre><code class="language-bash">touch src/lib.rs
CARGO_INCREMENTAL=0 perf record -F99 --call-graph dwarf cargo rustc --profile check --lib -- -Zborrowck=mir
</code></pre>
<h2><a class="header" href="#analyzing-a-perf-profile-with-perf-focus" id="analyzing-a-perf-profile-with-perf-focus">Analyzing a perf profile with <code>perf focus</code></a></h2>
<p>Once you've gathered a perf profile, we want to get some information
about it. For this, I personally use <a href="https://github.com/nikomatsakis/perf-focus">perf focus</a>. It's a kind of
simple but useful tool that lets you answer queries like:</p>
<ul>
<li>&quot;how much time was spent in function F&quot; (no matter where it was called from)</li>
<li>&quot;how much time was spent in function F when it was called from G&quot;</li>
<li>&quot;how much time was spent in function F <em>excluding</em> time spent in G&quot;</li>
<li>&quot;what functions does F call and how much time does it spend in them&quot;</li>
</ul>
<p>To understand how it works, you have to know just a bit about
perf. Basically, perf works by <em>sampling</em> your process on a regular
basis (or whenever some event occurs). For each sample, perf gathers a
backtrace. <code>perf focus</code> lets you write a regular expression that tests
which functions appear in that backtrace, and then tells you which
percentage of samples had a backtrace that met the regular
expression. It's probably easiest to explain by walking through how I
would analyze NLL performance.</p>
<h3><a class="header" href="#installing-perf-focus" id="installing-perf-focus">Installing <code>perf-focus</code></a></h3>
<p>You can install perf-focus using <code>cargo install</code>:</p>
<pre><code class="language-bash">cargo install perf-focus
</code></pre>
<h3><a class="header" href="#example-how-much-time-is-spent-in-mir-borrowck" id="example-how-much-time-is-spent-in-mir-borrowck">Example: How much time is spent in MIR borrowck?</a></h3>
<p>Let's say we've gathered the NLL data for a test. We'd like to know
how much time it is spending in the MIR borrow-checker. The &quot;main&quot;
function of the MIR borrowck is called <code>do_mir_borrowck</code>, so we can do
this command:</p>
<pre><code class="language-bash">$ perf focus '{do_mir_borrowck}'
Matcher    : {do_mir_borrowck}
Matches    : 228
Not Matches: 542
Percentage : 29%
</code></pre>
<p>The <code>'{do_mir_borrowck}'</code> argument is called the <strong>matcher</strong>. It
specifies the test to be applied on the backtrace. In this case, the
<code>{X}</code> indicates that there must be <em>some</em> function on the backtrace
that meets the regular expression <code>X</code>. In this case, that regex is
just the name of the function we want (in fact, it's a subset of the name;
the full name includes a bunch of other stuff, like the module
path). In this mode, perf-focus just prints out the percentage of
samples where <code>do_mir_borrowck</code> was on the stack: in this case, 29%.</p>
<p><strong>A note about c++filt.</strong> To get the data from <code>perf</code>, <code>perf focus</code>
currently executes <code>perf script</code> (perhaps there is a better
way...). I've sometimes found that <code>perf script</code> outputs C++ mangled
names. This is annoying. You can tell by running <code>perf script | head</code> yourself — if you see names like <code>5rustc6middle</code> instead of
<code>rustc::middle</code>, then you have the same problem. You can solve this
by doing:</p>
<pre><code class="language-bash">perf script | c++filt | perf focus --from-stdin ...
</code></pre>
<p>This will pipe the output from <code>perf script</code> through <code>c++filt</code> and
should mostly convert those names into a more friendly format. The
<code>--from-stdin</code> flag to <code>perf focus</code> tells it to get its data from
stdin, rather than executing <code>perf focus</code>. We should make this more
convenient (at worst, maybe add a <code>c++filt</code> option to <code>perf focus</code>, or
just always use it — it's pretty harmless).</p>
<h3><a class="header" href="#example-how-much-time-does-mir-borrowck-spend-solving-traits" id="example-how-much-time-does-mir-borrowck-spend-solving-traits">Example: How much time does MIR borrowck spend solving traits?</a></h3>
<p>Perhaps we'd like to know how much time MIR borrowck spends in the
trait checker. We can ask this using a more complex regex:</p>
<pre><code class="language-bash">$ perf focus '{do_mir_borrowck}..{^rustc::traits}'
Matcher    : {do_mir_borrowck},..{^rustc::traits}
Matches    : 12
Not Matches: 1311
Percentage : 0%
</code></pre>
<p>Here we used the <code>..</code> operator to ask &quot;how often do we have
<code>do_mir_borrowck</code> on the stack and then, later, some function whose
name begins with <code>rustc::traits</code>?&quot; (basically, code in that module). It
turns out the answer is &quot;almost never&quot; — only 12 samples fit that
description (if you ever see <em>no</em> samples, that often indicates your
query is messed up).</p>
<p>If you're curious, you can find out exactly which samples by using the
<code>--print-match</code> option. This will print out the full backtrace for
each sample. The <code>|</code> at the front of the line indicates the part that
the regular expression matched.</p>
<h3><a class="header" href="#example-where-does-mir-borrowck-spend-its-time" id="example-where-does-mir-borrowck-spend-its-time">Example: Where does MIR borrowck spend its time?</a></h3>
<p>Often we want to do a more &quot;explorational&quot; queries. Like, we know that
MIR borrowck is 29% of the time, but where does that time get spent?
For that, the <code>--tree-callees</code> option is often the best tool. You
usually also want to give <code>--tree-min-percent</code> or
<code>--tree-max-depth</code>. The result looks like this:</p>
<pre><code class="language-bash">$ perf focus '{do_mir_borrowck}' --tree-callees --tree-min-percent 3
Matcher    : {do_mir_borrowck}
Matches    : 577
Not Matches: 746
Percentage : 43%

Tree
| matched `{do_mir_borrowck}` (43% total, 0% self)
: | rustc_mir::borrow_check::nll::compute_regions (20% total, 0% self)
: : | rustc_mir::borrow_check::nll::type_check::type_check_internal (13% total, 0% self)
: : : | core::ops::function::FnOnce::call_once (5% total, 0% self)
: : : : | rustc_mir::borrow_check::nll::type_check::liveness::generate (5% total, 3% self)
: : : | &lt;rustc_mir::borrow_check::nll::type_check::TypeVerifier&lt;'a, 'b, 'tcx&gt; as rustc::mir::visit::Visitor&lt;'tcx&gt;&gt;::visit_mir (3% total, 0% self)
: | rustc::mir::visit::Visitor::visit_mir (8% total, 6% self)
: | &lt;rustc_mir::borrow_check::MirBorrowckCtxt&lt;'cx, 'tcx&gt; as rustc_mir::dataflow::DataflowResultsConsumer&lt;'cx, 'tcx&gt;&gt;::visit_statement_entry (5% total, 0% self)
: | rustc_mir::dataflow::do_dataflow (3% total, 0% self)
</code></pre>
<p>What happens with <code>--tree-callees</code> is that</p>
<ul>
<li>we find each sample matching the regular expression</li>
<li>we look at the code that is occurs <em>after</em> the regex match and try
to build up a call tree</li>
</ul>
<p>The <code>--tree-min-percent 3</code> option says &quot;only show me things that take
more than 3% of the time. Without this, the tree often gets really
noisy and includes random stuff like the innards of
malloc. <code>--tree-max-depth</code> can be useful too, it just limits how many
levels we print.</p>
<p>For each line, we display the percent of time in that function
altogether (&quot;total&quot;) and the percent of time spent in <strong>just that
function and not some callee of that function</strong> (self). Usually
&quot;total&quot; is the more interesting number, but not always.</p>
<h3><a class="header" href="#relative-percentages" id="relative-percentages">Relative percentages</a></h3>
<p>By default, all in perf-focus are relative to the <strong>total program
execution</strong>. This is useful to help you keep perspective — often as
we drill down to find hot spots, we can lose sight of the fact that,
in terms of overall program execution, this &quot;hot spot&quot; is actually not
important. It also ensures that percentages between different queries
are easily compared against one another.</p>
<p>That said, sometimes it's useful to get relative percentages, so <code>perf focus</code> offers a <code>--relative</code> option. In this case, the percentages are
listed only for samples that match (vs all samples). So for example we
could get our percentages relative to the borrowck itself
like so:</p>
<pre><code class="language-bash">$ perf focus '{do_mir_borrowck}' --tree-callees --relative --tree-max-depth 1 --tree-min-percent 5
Matcher    : {do_mir_borrowck}
Matches    : 577
Not Matches: 746
Percentage : 100%

Tree
| matched `{do_mir_borrowck}` (100% total, 0% self)
: | rustc_mir::borrow_check::nll::compute_regions (47% total, 0% self) [...]
: | rustc::mir::visit::Visitor::visit_mir (19% total, 15% self) [...]
: | &lt;rustc_mir::borrow_check::MirBorrowckCtxt&lt;'cx, 'tcx&gt; as rustc_mir::dataflow::DataflowResultsConsumer&lt;'cx, 'tcx&gt;&gt;::visit_statement_entry (13% total, 0% self) [...]
: | rustc_mir::dataflow::do_dataflow (8% total, 1% self) [...]
</code></pre>
<p>Here you see that <code>compute_regions</code> came up as &quot;47% total&quot; — that
means that 47% of <code>do_mir_borrowck</code> is spent in that function. Before,
we saw 20% — that's because <code>do_mir_borrowck</code> itself is only 43% of
the total time (and <code>.47 * .43 = .20</code>).</p>
<p>This file offers some tips on the coding conventions for rustc.  This
chapter covers <a href="conventions.html#formatting">formatting</a>, <a href="conventions.html#cc">coding for correctness</a>,
<a href="conventions.html#cio">using crates from crates.io</a>, and some tips on
<a href="conventions.html#er">structuring your PR for easy review</a>.</p>
<p><a name="formatting"></a></p>
<h1><a class="header" href="#formatting-and-the-tidy-script" id="formatting-and-the-tidy-script">Formatting and the tidy script</a></h1>
<p>rustc is slowly moving towards the <a href="https://github.com/rust-dev-tools/fmt-rfcs">Rust standard coding style</a>;
at the moment, however, it follows a rather more <em>chaotic</em> style.  We
do have some mandatory formatting conventions, which are automatically
enforced by a script we affectionately call the &quot;tidy&quot; script.  The
tidy script runs automatically when you do <code>./x.py test</code> and can be run
in isolation with <code>./x.py test tidy</code>.</p>
<p><a name="copyright"></a></p>
<h3><a class="header" href="#copyright-notice" id="copyright-notice">Copyright notice</a></h3>
<p>In the past, files began with a copyright and license notice. Please <strong>omit</strong>
this notice for new files licensed under the standard terms (dual
MIT/Apache-2.0).</p>
<p>All of the copyright notices should be gone by now, but if you come across one
in the rust-lang/rust repo, feel free to open a PR to remove it.</p>
<h2><a class="header" href="#line-length" id="line-length">Line length</a></h2>
<p>Lines should be at most 100 characters. It's even better if you can
keep things to 80.</p>
<p><strong>Ignoring the line length limit.</strong> Sometimes – in particular for
tests – it can be necessary to exempt yourself from this limit. In
that case, you can add a comment towards the top of the file (after
the copyright notice) like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// ignore-tidy-linelength
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#tabs-vs-spaces" id="tabs-vs-spaces">Tabs vs spaces</a></h2>
<p>Prefer 4-space indent.</p>
<p><a name="cc"></a></p>
<h1><a class="header" href="#coding-for-correctness" id="coding-for-correctness">Coding for correctness</a></h1>
<p>Beyond formatting, there are a few other tips that are worth
following.</p>
<h2><a class="header" href="#prefer-exhaustive-matches" id="prefer-exhaustive-matches">Prefer exhaustive matches</a></h2>
<p>Using <code>_</code> in a match is convenient, but it means that when new
variants are added to the enum, they may not get handled correctly.
Ask yourself: if a new variant were added to this enum, what's the
chance that it would want to use the <code>_</code> code, versus having some
other treatment?  Unless the answer is &quot;low&quot;, then prefer an
exhaustive match. (The same advice applies to <code>if let</code> and <code>while let</code>, which are effectively tests for a single variant.)</p>
<h2><a class="header" href="#use-todo-comments-for-things-you-dont-want-to-forget" id="use-todo-comments-for-things-you-dont-want-to-forget">Use &quot;TODO&quot; comments for things you don't want to forget</a></h2>
<p>As a useful tool to yourself, you can insert a <code>// TODO</code> comment
for something that you want to get back to before you land your PR:</p>
<pre><code class="language-rust ignore">fn do_something() {
    if something_else {
        unimplemented!(); // TODO write this
    }
}
</code></pre>
<p>The tidy script will report an error for a <code>// TODO</code> comment, so this
code would not be able to land until the TODO is fixed (or removed).</p>
<p>This can also be useful in a PR as a way to signal from one commit that you are
leaving a bug that a later commit will fix:</p>
<pre><code class="language-rust ignore">if foo {
    return true; // TODO wrong, but will be fixed in a later commit
}
</code></pre>
<p><a name="cio"></a></p>
<h1><a class="header" href="#using-crates-from-cratesio" id="using-crates-from-cratesio">Using crates from crates.io</a></h1>
<p>It is allowed to use crates from crates.io, though external
dependencies should not be added gratuitously. All such crates must
have a suitably permissive license. There is an automatic check which
inspects the Cargo metadata to ensure this.</p>
<p><a name="er"></a></p>
<h1><a class="header" href="#how-to-structure-your-pr" id="how-to-structure-your-pr">How to structure your PR</a></h1>
<p>How you prepare the commits in your PR can make a big difference for the
reviewer.  Here are some tips.</p>
<p><strong>Isolate &quot;pure refactorings&quot; into their own commit.</strong> For example, if
you rename a method, then put that rename into its own commit, along
with the renames of all the uses.</p>
<p><strong>More commits is usually better.</strong> If you are doing a large change,
it's almost always better to break it up into smaller steps that can
be independently understood. The one thing to be aware of is that if
you introduce some code following one strategy, then change it
dramatically (versus adding to it) in a later commit, that
'back-and-forth' can be confusing.</p>
<p><strong>Only run rustfmt on new content.</strong> One day, we might enforce formatting
for the rust-lang/rust repo. Meanwhile, we prefer that rustfmt not be run
on existing code as that will generate large diffs and will make git blame
harder to sift through. However, running <code>rustfmt</code> on new content, e.g. a
new file or a largely new part of a file is ok. Small formatting adjustments
nearby code you are already changing for other purposes are also ok.</p>
<p><strong>No merges.</strong> We do not allow merge commits into our history, other
than those by bors. If you get a merge conflict, rebase instead via a
command like <code>git rebase -i rust-lang/master</code> (presuming you use the
name <code>rust-lang</code> for your remote).</p>
<p><strong>Individual commits do not have to build (but it's nice).</strong> We do not
require that every intermediate commit successfully builds – we only
expect to be able to bisect at a PR level. However, if you <em>can</em> make
individual commits build, that is always helpful.</p>
<h1><a class="header" href="#naming-conventions" id="naming-conventions">Naming conventions</a></h1>
<p>Apart from normal Rust style/naming conventions, there are also some specific
to the compiler.</p>
<ul>
<li>
<p><code>cx</code> tends to be short for &quot;context&quot; and is often used as a suffix. For
example, <code>tcx</code> is a common name for the <a href="./ty.html">Typing Context</a>.</p>
</li>
<li>
<p><a href="./ty.html"><code>'tcx</code></a> is used as the lifetime name for the Typing Context.</p>
</li>
<li>
<p>Because <code>crate</code> is a keyword, if you need a variable to represent something
crate-related, often the spelling is changed to <code>krate</code>.</p>
</li>
</ul>
<h1><a class="header" href="#cratesio-dependencies" id="cratesio-dependencies">crates.io Dependencies</a></h1>
<p>The rust compiler supports building with some dependencies from <code>crates.io</code>.
For example, <code>log</code> and <code>env_logger</code> come from <code>crates.io</code>.</p>
<p>In general, you should avoid adding dependencies to the compiler for several
reasons:</p>
<ul>
<li>The dependency may not be high quality or well-maintained, whereas we want
the compiler to be high-quality.</li>
<li>The dependency may not be using a compatible license.</li>
<li>The dependency may have transitive dependencies that have one of the above
problems.</li>
</ul>
<p>TODO: what is the vetting process?</p>
<h2><a class="header" href="#whitelist" id="whitelist">Whitelist</a></h2>
<p>The <code>tidy</code> tool has a <a href="https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src/tools/tidy/src/deps.rs#L56">whitelist</a> of crates that are allowed. To add a
dependency that is not already in the compiler, you will need to add it to this
whitelist.</p>
<h1><a class="header" href="#emitting-errors-and-other-diagnostics" id="emitting-errors-and-other-diagnostics">Emitting Errors and other Diagnostics</a></h1>
<p>A lot of effort has been put into making <code>rustc</code> have great error messages.
This chapter is about how to emit compile errors and lints from the compiler.</p>
<h2><a class="header" href="#diagnostic-output-style-guide" id="diagnostic-output-style-guide">Diagnostic output style guide</a></h2>
<p>The main parts of a diagnostic error are the following:</p>
<pre><code>error[E0000]: main error message
  --&gt; file.rs:LL:CC
   |
LL | &lt;code&gt;
   | -^^^^- secondary label
   |  |
   |  primary label
   |
   = note: note without a `Span`, created with `.note`
note: sub-diagnostic message for `.span_note`
  --&gt; file.rs:LL:CC
   |
LL | more code
   |      ^^^^
</code></pre>
<ul>
<li>Description (<code>error</code>, <code>warning</code>, etc.).</li>
<li>Code (for example, for &quot;mismatched types&quot;, it is <code>E0308</code>). It helps
users get more information about the current error through an extended
description of the problem in the error code index.</li>
<li>Message. It is the main description of the problem. It should be general and
able to stand on its own, so that it can make sense even in isolation.</li>
<li>Diagnostic window. This contains several things:
<ul>
<li>The path, line number and column of the beginning of the primary span.</li>
<li>The users' affected code and its surroundings.</li>
<li>Primary and secondary spans underlying the users' code. These spans can
optionally contain one or more labels.
<ul>
<li>Primary spans should have enough text to describe the problem in such a
way that if it where the only thing being displayed (for example, in an
IDE) it would still make sense. Because it is &quot;spatially aware&quot; (it
points at the code), it can generally be more succinct than the error
message.</li>
<li>If cluttered output can be foreseen in cases when multiple span labels
overlap, it is a good idea to tweak the output appropriately. For
example, the <code>if/else arms have incompatible types</code> error uses different
spans depending on whether the arms are all in the same line, if one of
the arms is empty and if none of those cases applies.</li>
</ul>
</li>
</ul>
</li>
<li>Sub-diagnostics. Any error can have multiple sub-diagnostics that look
similar to the main part of the error. These are used for cases where the
order of the explanation might not correspond with the order of the code. If
the order of the explanation can be &quot;order free&quot;, leveraging secondary labels
in the main diagnostic is preferred, as it is typically less verbose.</li>
</ul>
<p>The text should be matter of fact and avoid capitalization and periods, unless
multiple sentences are <em>needed</em>:</p>
<pre><code class="language-txt">error: the fobrulator needs to be krontrificated
</code></pre>
<p>When code or an identifier must appear in an message or label, it should be
surrounded with single acute accents `.</p>
<h2><a class="header" href="#helpful-tips-and-options" id="helpful-tips-and-options">Helpful tips and options</a></h2>
<h3><a class="header" href="#finding-the-source-of-errors" id="finding-the-source-of-errors">Finding the source of errors</a></h3>
<p>There are two main ways to find where a given error is emitted:</p>
<ul>
<li><code>grep</code> for either a sub-part of the error message/label or error code. This
usually works well and is straightforward, but there are some cases where
the error emitting code is removed from the code where the error is
constructed behind a relatively deep call-stack. Even then, it is a good way
to get your bearings.</li>
<li>Invoking <code>rustc</code> with the nightly-only flag <code>-Ztreat-err-as-bug=1</code>, which
will treat the first error being emitted as an Internal Compiler Error, which
allows you to use the environment variable <code>RUST_BACKTRACE=full</code> to get a
stack trace at the point the error has been emitted. Change the <code>1</code> to
something else if you whish to trigger on a later error. Some limitations
with this approach is that some calls get elided from the stack trace because
they get inlined in the compiled <code>rustc</code>, and the same problem we faced with
the prior approach, where the <em>construction</em> of the error is far away from
where it is <em>emitted</em>. In some cases we buffer multiple errors in order to
emit them in order.</li>
</ul>
<p>The regular development practices apply: judicious use of <code>debug!()</code> statements
and use of a debugger to trigger break points in order to figure out in what
order things are happening.</p>
<h2><a class="header" href="#span" id="span"><code>Span</code></a></h2>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>Span</code></a> is the primary data structure in <code>rustc</code> used to represent a
location in the code being compiled. <code>Span</code>s are attached to most constructs in
HIR and MIR, allowing for more informative error reporting.</p>
<p>A <code>Span</code> can be looked up in a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/source_map/struct.SourceMap.html"><code>SourceMap</code></a> to get a &quot;snippet&quot;
useful for displaying errors with <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/source_map/struct.SourceMap.html#method.span_to_snippet"><code>span_to_snippet</code></a> and other
similar methods on the <code>SourceMap</code>.</p>
<h2><a class="header" href="#error-messages" id="error-messages">Error messages</a></h2>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/index.html"><code>rustc_errors</code></a> crate defines most of the utilities used for
reporting errors.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/struct.Session.html"><code>Session</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.ParseSess.html"><code>ParseSess</code></a> have
methods (or fields with methods) that allow reporting errors. These methods
usually have names like <code>span_err</code> or <code>struct_span_err</code> or <code>span_warn</code>, etc...
There are lots of them; they emit different types of &quot;errors&quot;, such as
warnings, errors, fatal errors, suggestions, etc.</p>
<p>In general, there are two classes of such methods: ones that emit an error
directly and ones that allow finer control over what to emit. For example,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/struct.Session.html#method.span_err"><code>span_err</code></a> emits the given error message at the given <code>Span</code>, but
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/struct.Session.html#method.struct_span_err"><code>struct_span_err</code></a> instead returns a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html"><code>DiagnosticBuilder</code></a>.</p>
<p><code>DiagnosticBuilder</code> allows you to add related notes and suggestions to an error
before emitting it by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html#method.emit"><code>emit</code></a> method. (Failing to either
emit or <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.Diagnostic.html#method.cancel">cancel</a> a <code>DiagnosticBuilder</code> will result in an ICE.) See the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html">docs</a> for more info on what you can do.</p>
<pre><code class="language-rust ignore">// Get a DiagnosticBuilder. This does _not_ emit an error yet.
let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);

// In some cases, you might need to check if `sp` is generated by a macro to
// avoid printing weird errors about macro-generated code.

if let Ok(snippet) = sess.source_map().span_to_snippet(sp) {
    // Use the snippet to generate a suggested fix
    err.span_suggestion(suggestion_sp, &quot;try using a qux here&quot;, format!(&quot;qux {}&quot;, snippet));
} else {
    // If we weren't able to generate a snippet, then emit a &quot;help&quot; message
    // instead of a concrete &quot;suggestion&quot;. In practice this is unlikely to be
    // reached.
    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);
}

// emit the error
err.emit();
</code></pre>
<h2><a class="header" href="#suggestions" id="suggestions">Suggestions</a></h2>
<p>In addition to telling the user exactly <em>why</em> their code is wrong, it's
oftentimes furthermore possible to tell them how to fix it. To this end,
<code>DiagnosticBuilder</code> offers a structured suggestions API, which formats code
suggestions pleasingly in the terminal, or (when the <code>--error-format json</code> flag
is passed) as JSON for consumption by tools, most notably the <a href="https://github.com/rust-lang/rls">Rust Language
Server</a> and <a href="https://github.com/rust-lang/rustfix"><code>rustfix</code></a>.</p>
<p>Not all suggestions should be applied mechanically, they have a degree of
confidence in the suggested code, from high
(<code>Applicability::MachineApplicable</code>) to low (<code>Applicability::MaybeIncorrect</code>).
Be conservative when choosing the level. Use the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html#method.span_suggestion"><code>span_suggestion</code></a> method of <code>DiagnosticBuilder</code> to
make a suggestion. The last argument provides a hint to tools whether
the suggestion is mechanically applicable or not.</p>
<p>Suggestions point to one or more spans with corresponding code that will
replace their current content.</p>
<p>The message that accompanies them should be understandable in the following
contexts:</p>
<ul>
<li>shown as an independent sub-diagnostic (this is the default output)</li>
<li>shown as a label pointing at the affected span (this is done automatically if
some heuristics for verbosity are met)</li>
<li>shown as a <code>help</code> sub-diagnostic with no content (used for cases where the
suggestion is obvious from the text, but we still want to let tools to apply
them))</li>
<li>not shown (used for <em>very</em> obvious cases, but we still want to allow tools to
apply them)</li>
</ul>
<p>For example, to make our <code>qux</code> suggestion machine-applicable, we would do:</p>
<pre><code class="language-rust ignore">let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);

if let Ok(snippet) = sess.source_map().span_to_snippet(sp) {
    err.span_suggestion(
        suggestion_sp,
        &quot;try using a qux here&quot;,
        format!(&quot;qux {}&quot;, snippet),
        Applicability::MachineApplicable,
    );
} else {
    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);
}

err.emit();
</code></pre>
<p>This might emit an error like</p>
<pre><code class="language-console">$ rustc mycode.rs
error[E0999]: oh no! this is an error!
 --&gt; mycode.rs:3:5
  |
3 |     sad()
  |     ^ help: try using a qux here: `qux sad()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
</code></pre>
<p>In some cases, like when the suggestion spans multiple lines or when there are
multiple suggestions, the suggestions are displayed on their own:</p>
<pre><code class="language-console">error[E0999]: oh no! this is an error!
 --&gt; mycode.rs:3:5
  |
3 |     sad()
  |     ^
help: try using a qux here:
  |
3 |     qux sad()
  |     ^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
</code></pre>
<p>The possible values of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html"><code>Applicability</code></a> are:</p>
<ul>
<li><code>MachineApplicable</code>: Can be applied mechanically.</li>
<li><code>HasPlaceholders</code>: Cannot be applied mechanically because it has placeholder
text in the suggestions. For example, &quot;Try adding a type: `let x:
&lt;type&gt;`&quot;.</li>
<li><code>MaybeIncorrect</code>: Cannot be applied mechanically because the suggestion may
or may not be a good one.</li>
<li><code>Unspecified</code>: Cannot be applied mechanically because we don't know which
of the above cases it falls into.</li>
</ul>
<h2><a class="header" href="#lints" id="lints">Lints</a></h2>
<p>The compiler linting infrastructure is defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/index.html"><code>rustc::lint</code></a>
module.</p>
<h3><a class="header" href="#declaring-a-lint" id="declaring-a-lint">Declaring a lint</a></h3>
<p>The built-in compiler lints are defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint</code></a>
crate.</p>
<p>Every lint is implemented via a <code>struct</code> that implements the <code>LintPass</code> <code>trait</code>
(you also implement one of the more specific lint pass traits, either
<code>EarlyLintPass</code> or <code>LateLintPass</code>).  The trait implementation allows you to
check certain syntactic constructs as the linter walks the source code. You can
then choose to emit lints in a very similar way to compile errors.</p>
<p>You also declare the metadata of a particular lint via the <code>declare_lint!</code>
macro. This includes the name, the default level, a short description, and some
more details.</p>
<p>Note that the lint and the lint pass must be registered with the compiler.</p>
<p>For example, the following lint checks for uses
of <code>while true { ... }</code> and suggests using <code>loop { ... }</code> instead.</p>
<pre><code class="language-rust ignore">// Declare a lint called `WHILE_TRUE`
declare_lint! {
    WHILE_TRUE,

    // warn-by-default
    Warn,

    // This string is the lint description
    &quot;suggest using `loop { }` instead of `while true { }`&quot;
}

// Define a struct and `impl LintPass` for it.
#[derive(Copy, Clone)]
pub struct WhileTrue;

// This declares a lint pass, providing a list of associated lints.  The
// compiler currently doesn't use the associated lints directly (e.g., to not
// run the pass or otherwise check that the pass emits the appropriate set of
// lints). However, it's good to be accurate here as it's possible that we're
// going to register the lints via the get_lints method on our lint pass (that
// this macro generates).
impl_lint_pass!(
    WhileTrue =&gt; [WHILE_TRUE],
);

// LateLintPass has lots of methods. We only override the definition of
// `check_expr` for this lint because that's all we need, but you could
// override other methods for your own lint. See the rustc docs for a full
// list of methods.
impl&lt;'a, 'tcx&gt; LateLintPass&lt;'a, 'tcx&gt; for WhileTrue {
    fn check_expr(&amp;mut self, cx: &amp;LateContext, e: &amp;hir::Expr) {
        if let hir::ExprWhile(ref cond, ..) = e.node {
            if let hir::ExprLit(ref lit) = cond.node {
                if let ast::LitKind::Bool(true) = lit.node {
                    if lit.span.ctxt() == SyntaxContext::empty() {
                        let msg = &quot;denote infinite loops with `loop { ... }`&quot;;
                        let condition_span = cx.tcx.sess.source_map().def_span(e.span);
                        let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);
                        err.span_suggestion_short(condition_span, &quot;use `loop`&quot;, &quot;loop&quot;.to_owned());
                        err.emit();
                    }
                }
            }
        }
    }
}
</code></pre>
<h3><a class="header" href="#edition-gated-lints" id="edition-gated-lints">Edition-gated Lints</a></h3>
<p>Sometimes we want to change the behavior of a lint in a new edition. To do this,
we just add the transition to our invocation of <code>declare_lint!</code>:</p>
<pre><code class="language-rust ignore">declare_lint! {
    pub ANONYMOUS_PARAMETERS,
    Allow,
    &quot;detects anonymous parameters&quot;,
    Edition::Edition2018 =&gt; Warn,
}
</code></pre>
<p>This makes the <code>ANONYMOUS_PARAMETERS</code> lint allow-by-default in the 2015 edition
but warn-by-default in the 2018 edition.</p>
<p>A future-incompatible lint should be declared with the <code>@future_incompatible</code>
additional &quot;field&quot;:</p>
<pre><code class="language-rust ignore">declare_lint! {
    pub ANONYMOUS_PARAMETERS,
    Allow,
    &quot;detects anonymous parameters&quot;,
    @future_incompatible = FutureIncompatibleInfo {
        reference: &quot;issue #41686 &lt;https://github.com/rust-lang/rust/issues/41686&gt;&quot;,
        edition: Some(Edition::Edition2018),
    };
}
</code></pre>
<p>If you need a combination of options that's not supported by the
<code>declare_lint!</code> macro, you can always define your own static with a type of
<code>&amp;Lint</code> but this is currently linted against in the compiler tree.</p>
<h4><a class="header" href="#guidelines-for-creating-a-future-incompatibility-lint" id="guidelines-for-creating-a-future-incompatibility-lint">Guidelines for creating a future incompatibility lint</a></h4>
<ul>
<li>Create a lint defaulting to warn as normal, with ideally the same error
message you would normally give.</li>
<li>Add a suitable reference, typically an RFC or tracking issue. Go ahead
and include the full URL, sort items in ascending order of issue numbers.</li>
<li>Later, change lint to error.</li>
<li>Eventually, remove lint.</li>
</ul>
<h3><a class="header" href="#lint-groups" id="lint-groups">Lint Groups</a></h3>
<p>Lints can be turned on in groups. These groups are declared in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html"><code>register_builtins</code></a> function in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint::lib</code></a>. The
<code>add_lint_group!</code> macro is used to declare a new group.</p>
<p>For example,</p>
<pre><code class="language-rust ignore">add_lint_group!(sess,
    &quot;nonstandard_style&quot;,
    NON_CAMEL_CASE_TYPES,
    NON_SNAKE_CASE,
    NON_UPPER_CASE_GLOBALS);
</code></pre>
<p>This defines the <code>nonstandard_style</code> group which turns on the listed lints. A
user can turn on these lints with a <code>!#[warn(nonstandard_style)]</code> attribute in
the source code, or by passing <code>-W nonstandard-style</code> on the command line.</p>
<h3><a class="header" href="#linting-early-in-the-compiler" id="linting-early-in-the-compiler">Linting early in the compiler</a></h3>
<p>On occasion, you may need to define a lint that runs before the linting system
has been initialized (e.g. during parsing or macro expansion). This is
problematic because we need to have computed lint levels to know whether we
should emit a warning or an error or nothing at all.</p>
<p>To solve this problem, we buffer the lints until the linting system is
processed. <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/struct.Session.html#method.buffer_lint"><code>Session</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.ParseSess.html#method.buffer_lint"><code>ParseSess</code></a> both have
<code>buffer_lint</code> methods that allow you to buffer a lint for later. The linting
system automatically takes care of handling buffered lints later.</p>
<p>Thus, to define a lint that runs early in the compilation, one defines a lint
like normal but invokes the lint with <code>buffer_lint</code>.</p>
<h4><a class="header" href="#linting-even-earlier-in-the-compiler" id="linting-even-earlier-in-the-compiler">Linting even earlier in the compiler</a></h4>
<p>The parser (<code>librustc_ast</code>) is interesting in that it cannot have dependencies on
any of the other <code>librustc*</code> crates. In particular, it cannot depend on
<code>librustc_middle::lint</code> or <code>librustc_lint</code>, where all of the compiler linting
infrastructure is defined. That's troublesome!</p>
<p>To solve this, <code>librustc_ast</code> defines its own buffered lint type, which
<code>ParseSess::buffer_lint</code> uses. After macro expansion, these buffered lints are
then dumped into the <code>Session::buffered_lints</code> used by the rest of the compiler.</p>
<h2><a class="header" href="#json-diagnostic-output" id="json-diagnostic-output">JSON diagnostic output</a></h2>
<p>The compiler accepts an <code>--error-format json</code> flag to output
diagnostics as JSON objects (for the benefit of tools such as <code>cargo fix</code> or the RLS). It looks like this—</p>
<pre><code class="language-console">$ rustc json_error_demo.rs --error-format json
{&quot;message&quot;:&quot;cannot add `&amp;str` to `{integer}`&quot;,&quot;code&quot;:{&quot;code&quot;:&quot;E0277&quot;,&quot;explanation&quot;:&quot;\nYou tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&amp;self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&amp;self);\n}\n\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&amp;self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func&lt;T&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func&lt;T: fmt::Debug&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n&quot;},&quot;level&quot;:&quot;error&quot;,&quot;spans&quot;:[{&quot;file_name&quot;:&quot;json_error_demo.rs&quot;,&quot;byte_start&quot;:50,&quot;byte_end&quot;:51,&quot;line_start&quot;:4,&quot;line_end&quot;:4,&quot;column_start&quot;:7,&quot;column_end&quot;:8,&quot;is_primary&quot;:true,&quot;text&quot;:[{&quot;text&quot;:&quot;    a + b&quot;,&quot;highlight_start&quot;:7,&quot;highlight_end&quot;:8}],&quot;label&quot;:&quot;no implementation for `{integer} + &amp;str`&quot;,&quot;suggested_replacement&quot;:null,&quot;suggestion_applicability&quot;:null,&quot;expansion&quot;:null}],&quot;children&quot;:[{&quot;message&quot;:&quot;the trait `std::ops::Add&lt;&amp;str&gt;` is not implemented for `{integer}`&quot;,&quot;code&quot;:null,&quot;level&quot;:&quot;help&quot;,&quot;spans&quot;:[],&quot;children&quot;:[],&quot;rendered&quot;:null}],&quot;rendered&quot;:&quot;error[E0277]: cannot add `&amp;str` to `{integer}`\n --&gt; json_error_demo.rs:4:7\n  |\n4 |     a + b\n  |       ^ no implementation for `{integer} + &amp;str`\n  |\n  = help: the trait `std::ops::Add&lt;&amp;str&gt;` is not implemented for `{integer}`\n\n&quot;}
{&quot;message&quot;:&quot;aborting due to previous error&quot;,&quot;code&quot;:null,&quot;level&quot;:&quot;error&quot;,&quot;spans&quot;:[],&quot;children&quot;:[],&quot;rendered&quot;:&quot;error: aborting due to previous error\n\n&quot;}
{&quot;message&quot;:&quot;For more information about this error, try `rustc --explain E0277`.&quot;,&quot;code&quot;:null,&quot;level&quot;:&quot;&quot;,&quot;spans&quot;:[],&quot;children&quot;:[],&quot;rendered&quot;:&quot;For more information about this error, try `rustc --explain E0277`.\n&quot;}
</code></pre>
<p>Note that the output is a series of lines, each of which is a JSON
object, but the series of lines taken together is, unfortunately, not
valid JSON, thwarting tools and tricks (such as <a href="https://docs.python.org/3/library/json.html#module-json.tool">piping to <code>python3 -m json.tool</code></a>)
that require such. (One speculates that this was intentional for LSP
performance purposes, so that each line/object can be sent to RLS as
it is flushed?)</p>
<p>Also note the &quot;rendered&quot; field, which contains the &quot;human&quot; output as a
string; this was introduced so that UI tests could both make use of
the structured JSON and see the &quot;human&quot; output (well, <em>sans</em> colors)
without having to compile everything twice.</p>
<p>The &quot;human&quot; readable and the json format emitter can be found under
librustc_errors, both were moved from the <code>librustc_ast</code> crate to the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/index.html">librustc_errors crate</a>.</p>
<p>The JSON emitter defines <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/json/struct.Diagnostic.html">its own <code>Diagnostic</code>
struct</a>
(and sub-structs) for the JSON serialization. Don't confuse this with
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.Diagnostic.html"><code>errors::Diagnostic</code></a>!</p>
<h2><a class="header" href="#rustc_on_unimplemented" id="rustc_on_unimplemented"><code>#[rustc_on_unimplemented(...)]</code></a></h2>
<p>The <code>#[rustc_on_unimplemented]</code> attribute allows trait definitions to add specialized
notes to error messages when an implementation was expected but not found.
You can refer to the trait's generic arguments by name and to the resolved type using <code>Self</code>.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">#![feature(rustc_attrs)]

#[rustc_on_unimplemented=&quot;an iterator over elements of type `{A}` \
    cannot be built from a collection of type `{Self}`&quot;]
trait MyIterator&lt;A&gt; {
    fn next(&amp;mut self) -&gt; A;
}

fn iterate_chars&lt;I: MyIterator&lt;char&gt;&gt;(i: I) {
    // ...
}

fn main() {
    iterate_chars(&amp;[1, 2, 3][..]);
}
</code></pre>
<p>When the user compiles this, they will see the following;</p>
<pre><code class="language-txt">error[E0277]: the trait bound `&amp;[{integer}]: MyIterator&lt;char&gt;` is not satisfied
  --&gt; &lt;anon&gt;:14:5
   |
14 |     iterate_chars(&amp;[1, 2, 3][..]);
   |     ^^^^^^^^^^^^^ an iterator over elements of type `char` cannot be built from a collection of type `&amp;[{integer}]`
   |
   = help: the trait `MyIterator&lt;char&gt;` is not implemented for `&amp;[{integer}]`
   = note: required by `iterate_chars`
</code></pre>
<p><code>rustc_on_unimplemented</code> also supports advanced filtering for better targeting
of messages, as well as modifying specific parts of the error message. You
target the text of:</p>
<ul>
<li>the main error message (<code>message</code>)</li>
<li>the label (<code>label</code>)</li>
<li>an extra note (<code>note</code>)</li>
</ul>
<p>For example, the following attribute</p>
<pre><code class="language-rust ignore">#[rustc_on_unimplemented(
    message=&quot;message&quot;,
    label=&quot;label&quot;,
    note=&quot;note&quot;
)]
trait MyIterator&lt;A&gt; {
    fn next(&amp;mut self) -&gt; A;
}
</code></pre>
<p>Would generate the following output:</p>
<pre><code class="language-text">error[E0277]: message
  --&gt; &lt;anon&gt;:14:5
   |
14 |     iterate_chars(&amp;[1, 2, 3][..]);
   |     ^^^^^^^^^^^^^ label
   |
   = note: note
   = help: the trait `MyIterator&lt;char&gt;` is not implemented for `&amp;[{integer}]`
   = note: required by `iterate_chars`
</code></pre>
<p>To allow more targeted error messages, it is possible to filter the
application of these fields based on a variety of attributes when using
<code>on</code>:</p>
<ul>
<li><code>crate_local</code>: whether the code causing the trait bound to not be
fulfilled is part of the user's crate. This is used to avoid suggesting
code changes that would require modifying a dependency.</li>
<li>Any of the generic arguments that can be substituted in the text can be
referred by name as well for filtering, like <code>Rhs=&quot;i32&quot;</code>, except for
<code>Self</code>.</li>
<li><code>_Self</code>: to filter only on a particular calculated trait resolution, like
<code>Self=&quot;std::iter::Iterator&lt;char&gt;&quot;</code>. This is needed because <code>Self</code> is a
keyword which cannot appear in attributes.</li>
<li><code>direct</code>: user-specified rather than derived obligation.</li>
<li><code>from_method</code>: usable both as boolean (whether the flag is present, like
<code>crate_local</code>) or matching against a particular method. Currently used
for <code>try</code>.</li>
<li><code>from_desugaring</code>: usable both as boolean (whether the flag is present)
or matching against a particular desugaring. The desugaring is identified
with its variant name in the <code>DesugaringKind</code> enum.</li>
</ul>
<p>For example, the <code>Iterator</code> trait can be annotated in the following way:</p>
<pre><code class="language-rust ignore">#[rustc_on_unimplemented(
    on(
        _Self=&quot;&amp;str&quot;,
        note=&quot;call `.chars()` or `.as_bytes()` on `{Self}&quot;
    ),
    message=&quot;`{Self}` is not an iterator&quot;,
    label=&quot;`{Self}` is not an iterator&quot;,
    note=&quot;maybe try calling `.iter()` or a similar method&quot;
)]
pub trait Iterator {}
</code></pre>
<p>Which would produce the following outputs:</p>
<pre><code class="language-text">error[E0277]: `Foo` is not an iterator
 --&gt; src/main.rs:4:16
  |
4 |     for foo in Foo {}
  |                ^^^ `Foo` is not an iterator
  |
  = note: maybe try calling `.iter()` or a similar method
  = help: the trait `std::iter::Iterator` is not implemented for `Foo`
  = note: required by `std::iter::IntoIterator::into_iter`

error[E0277]: `&amp;str` is not an iterator
 --&gt; src/main.rs:5:16
  |
5 |     for foo in &quot;&quot; {}
  |                ^^ `&amp;str` is not an iterator
  |
  = note: call `.chars()` or `.bytes() on `&amp;str`
  = help: the trait `std::iter::Iterator` is not implemented for `&amp;str`
  = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>If you need to filter on multiple attributes, you can use <code>all</code>, <code>any</code> or
<code>not</code> in the following way:</p>
<pre><code class="language-rust ignore">#[rustc_on_unimplemented(
    on(
        all(_Self=&quot;&amp;str&quot;, T=&quot;std::string::String&quot;),
        note=&quot;you can coerce a `{T}` into a `{Self}` by writing `&amp;*variable`&quot;
    )
)]
pub trait From&lt;T&gt;: Sized { /* ... */ }
</code></pre>
<h1><a class="header" href="#lints-1" id="lints-1">Lints</a></h1>
<p>This page documents some of the machinery around lint registration and how we
run lints in the compiler.</p>
<p>The <code>LintStore</code> is the central piece of infrastructure, around which everything
rotates. It's not available during the early parts of compilation (i.e., before
TyCtxt) in most code, as we need to fill it in with all of the lints, which can only happen after
plugin registration.</p>
<h2><a class="header" href="#lints-vs-lint-passes" id="lints-vs-lint-passes">Lints vs. lint passes</a></h2>
<p>There are two parts to the linting mechanism within the compiler: lints and lint passes.
Unfortunately, a lot of the documentation we have refers to both of these as just &quot;lints.&quot;</p>
<p>First, we have the lint declarations themselves: this is where the name and default lint level and
other metadata come from. These are normally defined by way of the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/macro.declare_lint.html"><code>declare_lint!</code></a> macro, which
boils down to a static with type <code>&amp;rustc::lint::Lint</code>. We lint against direct declarations without
the use of the macro today (though this may change in the future, as the macro is somewhat unwieldy
to add new fields to, like all macros by example).</p>
<p>Lint declarations don't carry any &quot;state&quot; - they are merely global identifers and descriptions of
lints. We assert at runtime that they are not registered twice (by lint name).</p>
<p>Lint passes are the meat of any lint. Notably, there is not a one-to-one relationship between
lints and lint passes; a lint might not have any lint pass that emits it, it could have many, or
just one -- the compiler doesn't track whether a pass is in any way associated with a particular
lint, and frequently lints are emitted as part of other work (e.g., type checking, etc.).</p>
<h2><a class="header" href="#registration" id="registration">Registration</a></h2>
<h3><a class="header" href="#high-level-overview" id="high-level-overview">High-level overview</a></h3>
<p>The lint store is created and all lints are registered during plugin registration, in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/passes/fn.register_plugins.html"><code>rustc_interface::register_plugins</code></a>. There are three 'sources' of lint: the internal lints, plugin
lints, and <code>rustc_interface::Config</code> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Config.html#structfield.register_lints"><code>register_lints</code></a>. All are registered here, in
<code>register_plugins</code>.</p>
<p>Once the registration is complete, we &quot;freeze&quot; the lint store by placing it in an <code>Lrc</code>. Later in
the driver, it's passed into the <code>GlobalCtxt</code> constructor where it lives in an immutable form from
then on.</p>
<p>Lints are registered via the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LintStore.html#method.register_lints"><code>LintStore::register_lint</code></a> function. This should
happen just once for any lint, or an ICE will occur.</p>
<p>Lint passes are registered separately into one of the categories (pre-expansion,
early, late, late module). Passes are registered as a closure -- i.e., <code>impl Fn() -&gt; Box&lt;dyn X&gt;</code>, where <code>dyn X</code> is either an early or late lint pass trait
object. When we run the lint passes, we run the closure and then invoke the lint
pass methods, which take <code>&amp;mut self</code> -- lint passes can keep track of state
internally.</p>
<h4><a class="header" href="#internal-lints" id="internal-lints">Internal lints</a></h4>
<p>Note, these include both rustc-internal lints, and the traditional lints, like, for example the dead
code lint.</p>
<p>These are primarily described in two places: <code>rustc::lint::builtin</code> and <code>rustc_lint::builtin</code>. The
first provides the definitions for the lints themselves, and the latter provides the lint pass
definitions (and implementations).</p>
<p>The internal lint registration happens in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html"><code>rustc_lint::register_builtins</code></a> function, along with
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_internals.html"><code>rustc_lint::register_internals</code></a> function. More generally, the LintStore &quot;constructor&quot;
function which is <em>the</em> way to get a <code>LintStore</code> in the compiler (you should not construct it
directly) is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.new_lint_store.html"><code>rustc_lint::new_lint_store</code></a>; it calls the registration functions.</p>
<h4><a class="header" href="#plugin-lints" id="plugin-lints">Plugin lints</a></h4>
<p>This is one of the primary use cases remaining for plugins/drivers. Plugins are given access to the
mutable <code>LintStore</code> during registration to call any functions they need on the <code>LintStore</code>, just
like rustc code. Plugins are intended to declare lints with the <code>plugin</code> field set to true (e.g., by
way of the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/macro.declare_tool_lint.html"><code>declare_tool_lint!</code></a> macro), but this is purely for diagnostics and help text;
otherwise plugin lints are mostly just as first class as rustc builtin lints.</p>
<h4><a class="header" href="#driver-lints" id="driver-lints">Driver lints</a></h4>
<p>These are the lints provided by drivers via the <code>rustc_interface::Config</code> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Config.html#structfield.register_lints"><code>register_lints</code></a> field,
which is a callback. Drivers should, if finding it already set, call the function currently set
within the callback they add. The best way for drivers to get access to this is by overriding the
<code>Callbacks::config</code> function which gives them direct access to the <code>Config</code> structure.</p>
<h2><a class="header" href="#compiler-lint-passes-are-combined-into-one-pass" id="compiler-lint-passes-are-combined-into-one-pass">Compiler lint passes are combined into one pass</a></h2>
<p>Within the compiler, for performance reasons, we usually do not register dozens
of lint passes. Instead, we have a single lint pass of each variety
(e.g. <code>BuiltinCombinedModuleLateLintPass</code>) which will internally call all of the
individual lint passes; this is because then we get the benefits of static over
dynamic dispatch for each of the (often empty) trait methods.</p>
<p>Ideally, we'd not have to do this, since it certainly adds to the complexity of
understanding the code. However, with the current type-erased lint store
approach, it is beneficial to do so for performance reasons.</p>
<p>New lints being added likely want to join one of the existing declarations like
<code>late_lint_mod_passes</code> in <code>librustc_lint/lib.rs</code>, which would then
auto-propagate into the other.</p>
<h1><a class="header" href="#diagnostic-codes" id="diagnostic-codes">Diagnostic Codes</a></h1>
<p>We generally try assign each error message a unique code like <code>E0123</code>. These
codes are defined in the compiler in the <code>diagnostics.rs</code> files found in each
crate, which basically consist of macros. The codes come in two varieties: those
that have an extended write-up, and those that do not. Whenever possible, if you
are making a new code, you should write an extended write-up.</p>
<h3><a class="header" href="#allocating-a-fresh-code" id="allocating-a-fresh-code">Allocating a fresh code</a></h3>
<p>If you want to create a new error, you first need to find the next available
code. This is a bit tricky since the codes are defined in various crates. To do
it, run this obscure command:</p>
<pre><code>./x.py test --stage 0 tidy
</code></pre>
<p>This will invoke the tidy script, which generally checks that your code obeys
our coding conventions. One of those jobs is to check that diagnostic codes are
indeed unique. Once it is finished with that, tidy will print out the lowest
unused code:</p>
<pre><code>...
tidy check (x86_64-apple-darwin)
* 470 error codes
* highest error code: E0591
...
</code></pre>
<p>Here we see the highest error code in use is <code>E0591</code>, so we <em>probably</em> want
<code>E0592</code>. To be sure, run <code>rg E0592</code> and check, you should see no references.</p>
<p>Next, open <code>src/{crate}/diagnostics.rs</code> within the crate where you wish to issue
the error (e.g., <code>src/librustc_typeck/diagnostics.rs</code>). Ideally, you will add
the code (in its proper numerical order) into the <code>register_long_diagnostics!</code>
macro, sort of like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>register_long_diagnostics! {
    ...
    E0592: r##&quot;
Your extended error text goes here!
&quot;##,
}
<span class="boring">}
</span></code></pre></pre>
<p>But you can also add it without an extended description:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>register_diagnostics! {
    ...
    E0592, // put a description here
}
<span class="boring">}
</span></code></pre></pre>
<p>To actually issue the error, you can use the <code>struct_span_err!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct_span_err!(self.tcx.sess, // some path to the session here
                 span, // whatever span in the source you want
                 E0592, // your new error code
                 &amp;format!(&quot;text of the error&quot;))
    .emit() // actually issue the error
<span class="boring">}
</span></code></pre></pre>
<p>If you want to add notes or other snippets, you can invoke methods before you
call <code>.emit()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct_span_err!(...)
    .span_label(another_span, &quot;something to label in the source&quot;)
    .span_note(another_span, &quot;some separate note, probably avoid these&quot;)
    .emit_()
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#ice-breakers" id="ice-breakers">ICE-breakers</a></h1>
<p>The <strong>ICE-breaker groups</strong> are an easy way to help out with rustc in a
&quot;piece-meal&quot; fashion, without committing to a larger project.
ICE-breaker groups are <strong><a href="ice-breaker/about.html#join">easy to join</a></strong> (just submit a PR!)
and joining does not entail any particular commitment.</p>
<p>Once you <a href="ice-breaker/about.html#join">join an ICE-breaker group</a>, you will be added to
a list that receives pings on github whenever a new issue is found
that fits the ICE-breaker group's criteria. If you are interested, you
can then <a href="https://github.com/rust-lang/triagebot/wiki/Assignment">claim the issue</a> and start working on it.</p>
<p>Of course, you don't have to wait for new issues to be tagged! If you
prefer, you can use the Github label for an ICE-breaker group to
search for existing issues that haven't been claimed yet.</p>
<h2><a class="header" href="#what-issues-are-a-good-fit-for-ice-breaker-groups" id="what-issues-are-a-good-fit-for-ice-breaker-groups">What issues are a good fit for ICE-breaker groups?</a></h2>
<p>&quot;ICE-breaker issues&quot; are intended to be <strong>isolated</strong> bugs of <strong>middle
priority</strong>:</p>
<ul>
<li>By <strong>isolated</strong>, we mean that we do not expect large-scale refactoring
to be required to fix the bug.</li>
<li>By <strong>middle priority</strong>, we mean that we'd like to see the bug fixed,
but it's not such a burning problem that we are dropping everything
else to fix it. The danger with such bugs, of course, is that they
can accumulate over time, and the role of the ICE-breaker groups is
to try and stop that from happening!</li>
</ul>
<p><a name="join"></a></p>
<h2><a class="header" href="#joining-an-ice-breaker-group" id="joining-an-ice-breaker-group">Joining an ICE-breaker group</a></h2>
<p>To join an ICE-breaker group, you just have to open a PR adding your
Github username to the appropriate file in the Rust team  repository.
See the &quot;example PRs&quot; below to get a precise idea and to identify the
file to edit.</p>
<p>Also, if you are not already a member of a Rust team then -- in addition
to adding your name to the file -- you have to checkout the repository and
run the following command:</p>
<pre><code class="language-bash">cargo run add-person $your_user_name
</code></pre>
<p>Example PRs:</p>
<ul>
<li><a href="https://github.com/rust-lang/team/pull/140">Example of adding yourself to the LLVM ICE-breakers.</a></li>
<li><a href="https://github.com/rust-lang/team/pull/221">Example of adding yourself to the Cleanup Crew ICE-breakers.</a></li>
</ul>
<h2><a class="header" href="#tagging-an-issue-for-an-ice-breaker-group" id="tagging-an-issue-for-an-ice-breaker-group">Tagging an issue for an ICE-breaker group</a></h2>
<p>To tag an issue as appropriate for an ICE-breaker group, you give
<a href="https://github.com/rust-lang/triagebot/">rustbot</a> a <a href="https://github.com/rust-lang/triagebot/wiki/Pinging"><code>ping</code></a> command with the name of the ICE-breakers
team. For example:</p>
<pre><code class="language-text">@rustbot ping icebreakers-llvm
@rustbot ping icebreakers-cleanup-crew
</code></pre>
<p>To make these commands shorter and easier to remember, there are aliases,
defined in the <a href="https://github.com/rust-lang/rust/blob/master/triagebot.toml"><code>triagebot.toml</code></a> file. For example:</p>
<pre><code class="language-text">@rustbot ping llvm
@rustbot ping cleanup
</code></pre>
<p>Keep in mind that these aliases are meant to make humans' life easier.
They might be subject to change. If you need to ensure that a command
will always be valid, prefer the full invocations over the aliases.</p>
<p><strong>Note though that this should only be done by compiler team members
or contributors, and is typically done as part of compiler team
triage.</strong></p>
<h1><a class="header" href="#cleanup-crew" id="cleanup-crew">Cleanup Crew</a></h1>
<p><strong>Github Label:</strong> <a href="https://github.com/rust-lang/rust/labels/ICEBreaker-Cleanup-Crew">ICEBreaker-Cleanup-Crew</a></p>
<p>The &quot;Cleanup Crew&quot; are focused on improving bug reports. Specifically,
the goal is to try to ensure that every bug report has all the
information that will be needed for someone to fix it:</p>
<ul>
<li>a minimal, standalone example that shows the problem</li>
<li>links to duplicates or related bugs</li>
<li>if the bug is a regression (something that used to work, but no longer does),
then a bisection to the PR or nightly that caused the regression</li>
</ul>
<p>This kind of cleanup is invaluable in getting bugs fixed. Better
still, it can be done by anybody who knows Rust, without any
particularly deep knowledge of the compiler.</p>
<p>Let's look a bit at the workflow for doing &quot;cleanup crew&quot; actions.</p>
<h2><a class="header" href="#finding-a-minimal-standalone-example" id="finding-a-minimal-standalone-example">Finding a minimal, standalone example</a></h2>
<p>Here the ultimate goal is to produce an example that reproduces the same
problem but without relying on any external crates. Such a test ought to contain
as little code as possible, as well. This will make it much easier to isolate the problem.</p>
<p>However, even if the &quot;ultimate minimal test&quot; cannot be achieved, it's
still useful to post incremental minimizations. For example, if you
can eliminate some of the external dependencies, that is helpful, and
so forth. </p>
<p>It's particularly useful to reduce to an example that works
in the <a href="https://play.rust-lang.org/">Rust playground</a>, rather than
requiring people to checkout a cargo build.</p>
<p>There are many resources for how to produce minimized test cases. Here
are a few:</p>
<ul>
<li>The <a href="https://github.com/jethrogb/rust-reduce">rust-reduce</a> tool can try to reduce
code automatically.
<ul>
<li>The <a href="https://embed.cs.utah.edu/creduce/">C-reduce</a> tool also works
on Rust code, though it requires that you start from a single
file. (XXX link to some post explaining how to do it?)</li>
</ul>
</li>
<li>pnkfelix's <a href="http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/">Rust Bug Minimization Patterns</a> blog post
<ul>
<li>This post focuses on &quot;heavy bore&quot; techniques, where you are
starting with a large, complex cargo project that you wish to
narrow down to something standalone.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#links-to-duplicate-or-related-bugs" id="links-to-duplicate-or-related-bugs">Links to duplicate or related bugs</a></h2>
<p>If you are on the &quot;Cleanup Crew&quot;, you will sometimes see multiple bug
reports that seem very similar. You can link one to the other just by
mentioning the other bug number in a Github comment. Sometimes it is
useful to close duplicate bugs. But if you do so, you should always
copy any test case from the bug you are closing to the other bug that
remains open, as sometimes duplicate-looking bugs will expose
different facets of the same problem.</p>
<h2><a class="header" href="#bisecting-regressions" id="bisecting-regressions">Bisecting regressions</a></h2>
<p>For regressions (something that used to work, but no longer does), it
is super useful if we can figure out precisely when the code stopped
working.  The gold standard is to be able to identify the precise
<strong>PR</strong> that broke the code, so we can ping the author, but even
narrowing it down to a nightly build is helpful, especially as that
then gives us a range of PRs. (One other challenge is that we
sometimes land &quot;rollup&quot; PRs, which combine multiple PRs into one.)</p>
<h3><a class="header" href="#cargo-bisect-rustc" id="cargo-bisect-rustc">cargo-bisect-rustc</a></h3>
<p>To help in figuring out the cause of a regression we have a tool
called <a href="https://github.com/rust-lang/cargo-bisect-rustc/">cargo-bisect-rustc</a>. It will automatically download and test
various builds of rustc. For recent regressions, it is even able to
use the builds from our CI to track down the regression to a specific
PR; for older regressions, it will simply identify a nightly.</p>
<p>To learn to use <a href="https://github.com/rust-lang/cargo-bisect-rustc/">cargo-bisect-rustc</a>, check out <a href="https://blog.rust-lang.org/inside-rust/2019/12/18/bisecting-rust-compiler.html">this blog
post</a>, which gives a quick introduction to how it works. You
can also ask questions at the Zulip stream
<a href="https://rust-lang.zulipchat.com/#narrow/stream/217417-t-compiler.2Fcargo-bisect-rustc"><code>#t-compiler/cargo-bisect-rustc</code></a>, or help in improving the tool.</p>
<h3><a class="header" href="#identifying-the-range-of-prs-in-a-nightly" id="identifying-the-range-of-prs-in-a-nightly">identifying the range of PRs in a nightly</a></h3>
<p>If the regression occurred more than 90 days ago, then
cargo-bisect-rustc will not able to identify the particular PR that
caused the regression, just the nightly build. In that case, we can
identify the set of PRs that this corresponds to by using the git
history. </p>
<p>The command <code>rustc +nightly -vV</code> will cause rustc to output a number
of useful bits of version info, including the <code>commit-hash</code>. Given the
commit-hash of two nightly versions, you can find all of PRs that have
landed in between by taking the following steps:</p>
<ol>
<li>Go to an update checkout of the <a href="https://github.com/rust-lang/rust/">rust-lang/rust</a> repository</li>
<li>Execute the command <code>git log --author=bors --format=oneline SHA1..SHA2</code></li>
</ol>
<ul>
<li>This will list out all of the commits by bors, which is our merge bot</li>
<li>Each commit corresponds to one PR, and information about the PR should be in the description</li>
</ul>
<ol start="3">
<li>Copy and paste that information into the bug report</li>
</ol>
<p>Often, just eye-balling the PR descriptions (which are included in the
commit messages) will give you a good idea which one likely caused the
problem. But if you're unsure feel free to just ping the compiler team
(<code>@rust-lang/compiler</code>) or else to ping the authors of the PR
themselves.</p>
<h1><a class="header" href="#llvm-ice-breakers" id="llvm-ice-breakers">LLVM ICE-breakers</a></h1>
<p><strong>Github Label:</strong> <a href="https://github.com/rust-lang/rust/labels/ICEBreaker-LLVM">ICEBreaker-LLVM</a></p>
<p>The &quot;LLVM ICE-breakers&quot; are focused on bugs that center around LLVM.
These bugs often arise because of LLVM optimizations gone awry, or as
the result of an LLVM upgrade. The goal here is:</p>
<ul>
<li>to determine whether the bug is a result of us generating invalid LLVM IR,
or LLVM misoptimizing;</li>
<li>if the former, to fix our IR;</li>
<li>if the latter, to try and file a bug on LLVM (or identify an existing bug).</li>
</ul>
<h2><a class="header" href="#helpful-tips-and-options-1" id="helpful-tips-and-options-1">Helpful tips and options</a></h2>
<p>The <a href="ice-breaker/../backend/debugging.html">&quot;Debugging LLVM&quot;</a> section of the
rustc-dev-guide gives a step-by-step process for how to help debug bugs
caused by LLVM. In particular, it discusses how to emit LLVM IR, run
the LLVM IR optimization pipeliness, and so forth. You may also find
it useful to look at the various codegen options listed under <code>-Chelp</code>
and the internal options under <code>-Zhelp</code> -- there are a number that
pertain to LLVM (just search for LLVM).</p>
<h2><a class="header" href="#if-you-do-narrow-to-an-llvm-bug" id="if-you-do-narrow-to-an-llvm-bug">If you do narrow to an LLVM bug</a></h2>
<p>The <a href="ice-breaker/../backend/debugging.html">&quot;Debugging LLVM&quot;</a> section also describes what to do once
you've identified the bug.</p>
<h1><a class="header" href="#rust-langrust-licenses" id="rust-langrust-licenses"><code>rust-lang/rust</code> Licenses</a></h1>
<p>The <code>rustc</code> compiler source and standard library are dual licensed under the <a href="https://github.com/rust-lang/rust/blob/master/LICENSE-APACHE">Apache License v2.0</a> and the <a href="https://github.com/rust-lang/rust/blob/master/LICENSE-MIT">MIT License</a> unless otherwise specified.</p>
<p>Detailed licensing information is available in the <a href="https://github.com/rust-lang/rust/blob/master/COPYRIGHT">COPYRIGHT document</a> of the <code>rust-lang/rust</code> repository.</p>
<h1><a class="header" href="#part-2-high-level-compiler-architecture" id="part-2-high-level-compiler-architecture">Part 2: High-Level Compiler Architecture</a></h1>
<p>The remaining parts of this guide discuss how the compiler works. They go
through everything from high-level structure of the compiler to how each stage
of compilation works. They should be friendly to both readers interested in the
end-to-end process of compilation <em>and</em> readers interested in learning about a
specific system they wish to contribute to. If anything is unclear, feel free
to file an issue on the <a href="https://github.com/rust-lang/rustc-dev-guide/issues">rustc-dev-guide
repo</a> or contact the compiler
team, as detailed in <a href="./compiler-team.html">this chapter from Part 1</a>.</p>
<p>In this part, we will specifically look at the high-level architecture of the
compiler. Specifically, will look at the query system, incremental compilation,
and interning. These are three overarching design choices that impact the whole
compiler.</p>
<h1><a class="header" href="#overview-of-the-compiler" id="overview-of-the-compiler">Overview of the Compiler</a></h1>
<p>This chapter is about the overall process of compiling a program -- how
everything fits together.</p>
<p>The rust compiler is special in two ways: it does things to your code that
other compilers don't do (e.g. borrow checking) and it has a lot of
unconventional implementation choices (e.g. queries). We will talk about these
in turn in this chapter, and in the rest of the guide, we will look at all the
individual pieces in more detail.</p>
<h2><a class="header" href="#what-the-compiler-does-to-your-code" id="what-the-compiler-does-to-your-code">What the compiler does to your code</a></h2>
<p>So first, let's look at what the compiler does to your code. For now, we will
avoid mentioning how the compiler implements these steps except as needed;
we'll talk about that later.</p>
<ul>
<li>The compile process begins when a user writes a Rust source program in text
and invokes the <code>rustc</code> compiler on it. The work that the compiler needs to
perform is defined by command-line options. For example, it is possible to
enable nightly features (<code>-Z</code> flags), perform <code>check</code>-only builds, or emit
LLVM-IR rather than executable machine code. The <code>rustc</code> executable call may
be indirect through the use of <code>cargo</code>.</li>
<li>Command line argument parsing occurs in the <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html"><code>librustc_driver</code></a>. This crate
defines the compile configuration that is requested by the user and passes it
to the rest of the compilation process as a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Config.html"><code>rustc_interface::Config</code></a>.</li>
<li>The raw Rust source text is analyzed by a low-level lexer located in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lexer/index.html"><code>librustc_lexer</code></a>. At this stage, the source text is turned into a stream of
atomic source code units known as <em>tokens</em>.  The lexer supports the
Unicode character encoding.</li>
<li>The token stream passes through a higher-level lexer located in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/index.html"><code>librustc_parse</code></a> to prepare for the next stage of the compile process. The
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/lexer/struct.StringReader.html"><code>StringReader</code></a> struct is used at this stage to perform a set of validations
and turn strings into interned symbols (<em>interning</em> is discussed later).</li>
<li>The lexer has a small interface and doesn't depend directly on the
diagnostic infrastructure in <code>rustc</code>. Instead it provides diagnostics as plain
data which are emitted in <code>librustc_parse::lexer::mod</code> as real diagnostics.</li>
<li>The lexer preserves full fidelity information for both IDEs and proc macros.</li>
<li>The parser <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/index.html">translates the token stream from the lexer into an Abstract Syntax
Tree (AST)</a>.  It uses a recursive descent (top-down) approach to syntax
analysis. The crate entry points for the parser are the <code>Parser.parse_crate_mod()</code> and
<code>Parser.parse_mod()</code> methods found in <code>librustc_parse::parser::item</code>. The external
module parsing entry point is <code>librustc_expand::module::parse_external_mod</code>. And
the macro parser entry point is <code>rustc_expand::mbe::macro_parser::parse_nt</code>.</li>
<li>Parsing is performed with a set of <code>Parser</code> utility methods including <code>fn bump</code>,
<code>fn check</code>, <code>fn eat</code>, <code>fn expect</code>, <code>fn look_ahead</code>.</li>
<li>Parsing is organized by the semantic construct that is being parsed. Separate
<code>parse_*</code> methods can be found in <code>librustc_parse</code> <code>parser</code> directory. The source
file name follows the construct name. For example, the following files are found
in the parser:
<ul>
<li><code>expr.rs</code></li>
<li><code>pat.rs</code></li>
<li><code>ty.rs</code></li>
<li><code>stmt.rs</code></li>
</ul>
</li>
<li>This naming scheme is used across many compiler stages. You will find
either a file or directory with the same name across the parsing, lowering,
type checking, HAIR lowering, and MIR building sources.</li>
<li>Macro expansion, AST validation, name resolution, and early linting takes place
during this stage of the compile process.</li>
<li>The parser uses the standard <code>DiagnosticBuilder</code> API for error handling, but we
try to recover, parsing a superset of Rust's grammar, while also emitting an error.</li>
<li><code>rustc_ast::ast::{Crate, Mod, Expr, Pat, ...}</code> AST nodes are returned from the parser.</li>
<li>We then take the AST and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/index.html">convert it to High-Level Intermediate
Representation (HIR)</a>. This is a compiler-friendly representation of the
AST.  This involves a lot of desugaring of things like loops and <code>async fn</code>.</li>
<li>We use the HIR to do <a href="https://rustc-dev-guide.rust-lang.org/type-inference.html">type inference</a>. This is the process of automatic
detection of the type of an expression.</li>
<li><strong>TODO: Maybe some other things are done here? I think initial type checking
happens here? And trait solving?</strong></li>
<li>The HIR is then <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">lowered to Mid-Level Intermediate Representation (MIR)</a>.
<ul>
<li>Along the way, we construct the HAIR, which is an even more desugared HIR.
HAIR is used for pattern and exhaustiveness checking. It is also more
convenient to convert into MIR than HIR is.</li>
</ul>
</li>
<li>The MIR is used for <a href="https://rustc-dev-guide.rust-lang.org/borrow_check.html">borrow checking</a>.</li>
<li>We (want to) do <a href="https://rustc-dev-guide.rust-lang.org/mir/optimizations.html">many optimizations on the MIR</a> because it is still
generic and that improves the code we generate later, improving compilation
speed too.
<ul>
<li>MIR is a higher level (and generic) representation, so it is easier to do
some optimizations at MIR level than at LLVM-IR level. For example LLVM
doesn't seem to be able to optimize the pattern the <a href="https://github.com/rust-lang/rust/pull/66282"><code>simplify_try</code></a> mir
opt looks for.</li>
</ul>
</li>
<li>Rust code is <em>monomorphized</em>, which means making copies of all the generic
code with the type parameters replaced by concrete types. To do
this, we need to collect a list of what concrete types to generate code for.
This is called <em>monomorphization collection</em>.</li>
<li>We then begin what is vaguely called <em>code generation</em> or <em>codegen</em>.
<ul>
<li>The <a href="https://rustc-dev-guide.rust-lang.org/backend/codegen.html">code generation stage (codegen)</a> is when higher level
representations of source are turned into an executable binary. <code>rustc</code>
uses LLVM for code generation.  The first step is the MIR is then
converted to LLVM Intermediate Representation (LLVM IR). This is where
the MIR is actually monomorphized, according to the list we created in
the previous step.</li>
<li>The LLVM IR is passed to LLVM, which does a lot more optimizations on it.
It then emits machine code. It is basically assembly code with additional
low-level types and annotations added. (e.g. an ELF object or wasm).</li>
<li>The different libraries/binaries are linked together to produce the final
binary.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#how-it-does-it" id="how-it-does-it">How it does it</a></h2>
<p>Ok, so now that we have a high-level view of what the compiler does to your
code, let's take a high-level view of <em>how</em> it does all that stuff. There are a
lot of constraints and conflicting goals that the compiler needs to
satisfy/optimize for. For example,</p>
<ul>
<li>Compilation speed: how fast is it to compile a program. More/better
compile-time analyses often means compilation is slower.
<ul>
<li>Also, we want to support incremental compilation, so we need to take that
into account. How can we keep track of what work needs to be redone and
what can be reused if the user modifies their program?
<ul>
<li>Also we can't store too much stuff in the incremental cache because
it would take a long time to load from disk and it could take a lot
of space on the user's system...</li>
</ul>
</li>
</ul>
</li>
<li>Compiler memory usage: while compiling a program, we don't want to use more
memory than we need.</li>
<li>Program speed: how fast is your compiled program. More/better compile-time
analyses often means the compiler can do better optimizations.</li>
<li>Program size: how large is the compiled binary? Similar to the previous
point.</li>
<li>Compiler compilation speed: how long does it take to compile the compiler?
This impacts contributors and compiler maintenance.</li>
<li>Implementation complexity: building a compiler is one of the hardest
things a person/group can do, and Rust is not a very simple language, so how
do we make the compiler's code base manageable?</li>
<li>Compiler correctness: the binaries produced by the compiler should do what
the input programs says they do, and should continue to do so despite the
tremendous amount of change constantly going on.</li>
<li>Integration: a number of other tools need to use the compiler in
various ways (e.g. cargo, clippy, miri, RLS) that must be supported.</li>
<li>Compiler stability: the compiler should not crash or fail ungracefully on the
stable channel.</li>
<li>Rust stability: the compiler must respect Rust's stability guarantees by not
breaking programs that previously compiled despite the many changes that are
always going on to its implementation.</li>
<li>Limitations of other tools: rustc uses LLVM in its backend, and LLVM has some
strengths we leverage and some limitations/weaknesses we need to work around.</li>
</ul>
<p>So, as you read through the rest of the guide, keep these things in mind. They
will often inform decisions that we make.</p>
<h3><a class="header" href="#constant-change" id="constant-change">Constant change</a></h3>
<p>Keep in mind that <code>rustc</code> is a real production-quality product.
As such, it has its fair share of codebase churn and technical debt. A lot of
the designs discussed throughout this guide are idealized designs that are not
fully realized yet. And things keep changing so that it is hard to keep this
guide completely up to date on everything!</p>
<p>The compiler definitely has rough edges, but because of its design it is able
to keep up with the requirements above.</p>
<h3><a class="header" href="#intermediate-representations" id="intermediate-representations">Intermediate representations</a></h3>
<p>As with most compilers, <code>rustc</code> uses some intermediate representations (IRs) to
facilitate computations. In general, working directly with the source code is
extremely inconvenient and error-prone. Source code is designed to be human-friendly while at
the same time being unambiguous, but it's less convenient for doing something
like, say, type checking.</p>
<p>Instead most compilers, including <code>rustc</code>, build some sort of IR out of the
source code which is easier to analyze. <code>rustc</code> has a few IRs, each optimized
for different purposes:</p>
<ul>
<li>Token stream: the lexer produces a stream of tokens directly from the source
code. This stream of tokens is easier for the parser to deal with than raw
text.</li>
<li>Abstract Syntax Tree (AST): the abstract syntax tree is built from the stream
of tokens produced by the lexer. It represents
pretty much exactly what the user wrote. It helps to do some syntactic sanity
checking (e.g. checking that a type is expected where the user wrote one).</li>
<li>High-level IR (HIR): This is a sort of desugared AST. It's still close
to what the user wrote syntactically, but it includes some implicit things
such as some elided lifetimes, etc. This IR is amenable to type checking.</li>
<li>HAIR: This is an intermediate between HIR and MIR. It is like the HIR but it
is fully typed and a bit more desugared (e.g. method calls and implicit
dereferences are made fully explicit). Moreover, it is easier to lower to MIR
from HAIR than from HIR.</li>
<li>Middle-level IR (MIR): This IR is basically a Control-Flow Graph (CFG). A CFG
is a type of diagram that shows the basic blocks of a program and how control
flow can go between them. Likewise, MIR also has a bunch of basic blocks with
simple typed statements inside them (e.g. assignment, simple computations,
etc) and control flow edges to other basic blocks (e.g., calls, dropping
values). MIR is used for borrow checking and other
important dataflow-based checks, such as checking for uninitialized values.
It is also used for a series of optimizations and for constant evaluation (via
MIRI). Because MIR is still generic, we can do a lot of analyses here more
efficiently than after monomorphization.</li>
<li>LLVM IR: This is the standard form of all input to the LLVM compiler. LLVM IR
is a sort of typed assembly language with lots of annotations. It's
a standard format that is used by all compilers that use LLVM (e.g. the clang
C compiler also outputs LLVM IR). LLVM IR is designed to be easy for other
compilers to emit and also rich enough for LLVM to run a bunch of
optimizations on it.</li>
</ul>
<p>One other thing to note is that many values in the compiler are <em>interned</em>.
This is a performance and memory optimization in which we allocate the values
in a special allocator called an <em>arena</em>. Then, we pass around references to
the values allocated in the arena. This allows us to make sure that identical
values (e.g. types in your program) are only allocated once and can be compared
cheaply by comparing pointers. Many of the intermediate representations are
interned.</p>
<h3><a class="header" href="#queries" id="queries">Queries</a></h3>
<p>The first big implementation choice is the <em>query</em> system. The rust compiler
uses a query system which is unlike most textbook compilers, which are
organized as a series of passes over the code that execute sequentially. The
compiler does this to make incremental compilation possible -- that is, if the
user makes a change to their program and recompiles, we want to do as little
redundant work as possible to produce the new binary.</p>
<p>In <code>rustc</code>, all the major steps above are organized as a bunch of queries that
call each other. For example, there is a query to ask for the type of something
and another to ask for the optimized MIR of a function. These
queries can call each other and are all tracked through the query system.
The results of the queries are cached on disk so that we can tell which
queries' results changed from the last compilation and only redo those. This is
how incremental compilation works.</p>
<p>In principle, for the query-fied steps, we do each of the above for each item
individually. For example, we will take the HIR for a function and use queries
to ask for the LLVM IR for that HIR. This drives the generation of optimized
MIR, which drives the borrow checker, which drives the generation of MIR, and
so on.</p>
<p>... except that this is very over-simplified. In fact, some queries are not
cached on disk, and some parts of the compiler have to run for all code anyway
for correctness even if the code is dead code (e.g. the borrow checker). For
example, <a href="https://github.com/rust-lang/rust/blob/45ebd5808afd3df7ba842797c0fcd4447ddf30fb/src/librustc_interface/passes.rs#L824">currently the <code>mir_borrowck</code> query is first executed on all functions
of a crate.</a> Then the codegen backend invokes the
<code>collect_and_partition_mono_items</code> query, which first recursively requests the
<code>optimized_mir</code> for all reachable functions, which in turn runs <code>mir_borrowck</code>
for that function and then creates codegen units. This kind of split will need
to remain to ensure that unreachable functions still have their errors emitted.</p>
<p>Moreover, the compiler wasn't originally built to use a query system; the query
system has been retrofitted into the compiler, so parts of it are not
query-fied yet. Also, LLVM isn't our code, so that isn't querified
either. The plan is to eventually query-fy all of the steps listed in the
previous section, but as of this writing, only the steps between HIR and
LLVM-IR are query-fied. That is, lexing and parsing are done all at once for
the whole program.</p>
<p>One other thing to mention here is the all-important &quot;typing context&quot;,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html"><code>TyCtxt</code></a>, which is a giant struct that is at the center of all things.
(Note that the name is mostly historic. This is <em>not</em> a &quot;typing context&quot; in the
sense of <code>Γ</code> or <code>Δ</code> from type theory. The name is retained because that's what
the name of the struct is in the source code.) All
queries are defined as methods on the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html"><code>TyCtxt</code></a> type, and the in-memory query
cache is stored there too. In the code, there is usually a variable called
<code>tcx</code> which is a handle on the typing context. You will also see lifetimes with
the name <code>'tcx</code>, which means that something is tied to the lifetime of the
<code>TyCtxt</code> (usually it is stored or interned there).</p>
<h3><a class="header" href="#tyty" id="tyty"><code>ty::Ty</code></a></h3>
<p>Types are really important in Rust, and they form the core of a lot of compiler
analyses. The main type (in the compiler) that represents types (in the user's
program) is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>rustc::ty::Ty</code></a>. This is so important that we have a whole chapter
on <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>ty::Ty</code></a>, but for now, we just want to mention that it exists and is the way
<code>rustc</code> represents types!</p>
<p>Also note that the <code>rustc::ty</code> module defines the <code>TyCtxt</code> struct we mentioned before.</p>
<h3><a class="header" href="#parallelism" id="parallelism">Parallelism</a></h3>
<p>Compiler performance is a problem that we would like to improve on
(and are always working on). One aspect of that is parallelizing
<code>rustc</code> itself.</p>
<p>Currently, there is only one part of rustc that is already parallel: codegen.
During monomorphization, the compiler will split up all the code to be
generated into smaller chunks called <em>codegen units</em>. These are then generated
by independent instances of LLVM. Since they are independent, we can run them
in parallel. At the end, the linker is run to combine all the codegen units
together into one binary.</p>
<p>However, the rest of the compiler is still not yet parallel. There have been
lots of efforts spent on this, but it is generally a hard problem. The current
approach is to turn <code>RefCell</code>s into <code>Mutex</code>s -- that is, we
switch to thread-safe internal mutability. However, there are ongoing
challenges with lock contention, maintaining query-system invariants under
concurrency, and the complexity of the code base. One can try out the current
work by enabling parallel compilation in <code>config.toml</code>. It's still early days,
but there are already some promising performance improvements.</p>
<h3><a class="header" href="#bootstrapping-1" id="bootstrapping-1">Bootstrapping</a></h3>
<p><code>rustc</code> itself is written in Rust. So how do we compile the compiler? We use an
older compiler to compile the newer compiler. This is called <em>bootstrapping</em>.</p>
<p>Bootstrapping has a lot of interesting implications. For example, it means that
one of the major users of Rust is Rust, so we are constantly testing our own
software (&quot;eating our own dogfood&quot;). Also, it means building the compiler can
take a long time because one must first build the new compiler with an older
compiler and then use that to build the new compiler with itself (sometimes you
can get away without the full 2-stage build, but for release artifacts you need
the 2-stage build).</p>
<p>Bootstrapping also has implications for when features are usable in the
compiler itself. The build system uses the current beta compiler to build the
stage-1 bootstrapping compiler. This means that the compiler source code can't
use some features until they reach beta (because otherwise the beta compiler
doesn't support them). On the other hand, for <a href="./appendix/glossary.html#intrinsic">compiler intrinsics</a>
and internal features, we may be able to use them immediately because the
stage-1 bootstrapping compiler will support them.</p>
<h1><a class="header" href="#unresolved-questions" id="unresolved-questions">Unresolved Questions</a></h1>
<ul>
<li>Does LLVM ever do optimizations in debug builds?</li>
<li>How do I explore phases of the compile process in my own sources (lexer,
parser, HIR, etc)? - e.g., <code>cargo rustc -- -Zunpretty=hir-tree</code> allows you to
view HIR representation</li>
<li>What is the main source entry point for <code>X</code>?</li>
<li>Where do phases diverge for cross-compilation to machine code across
different platforms?</li>
</ul>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ul>
<li>Command line parsing
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html">The Rustc Driver and Interface</a></li>
<li>Driver definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/"><code>rustc_driver</code></a></li>
<li>Main entry point: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/config/fn.build_session_options.html"><code>rustc_session::config::build_session_options</code></a></li>
</ul>
</li>
<li>Lexical Analysis: Lex the user program to a stream of tokens
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/the-parser.html">Lexing and Parsing</a></li>
<li>Lexer definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lexer/index.html"><code>librustc_lexer</code></a></li>
<li>Main entry point: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lexer/fn.first_token.html"><code>rustc_lexer::first_token</code></a></li>
</ul>
</li>
<li>Parsing: Parse the stream of tokens to an Abstract Syntax Tree (AST)
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/the-parser.html">Lexing and Parsing</a></li>
<li>Parser definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/index.html"><code>librustc_parse</code></a></li>
<li>Main entry points:
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/passes/fn.parse.html">Entry point for first file in crate</a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/module/fn.parse_external_mod.html">Entry point for outline module parsing</a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_parser/fn.parse_nt.html">Entry point for macro fragments</a></li>
</ul>
</li>
<li>AST definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/index.html"><code>librustc_ast</code></a></li>
<li>Expansion: <strong>TODO</strong></li>
<li>Name Resolution: <strong>TODO</strong></li>
<li>Feature gating: <strong>TODO</strong></li>
<li>Early linting: <strong>TODO</strong></li>
</ul>
</li>
<li>The High Level Intermediate Representation (HIR)
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/hir.html">The HIR</a></li>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/hir.html#identifiers-in-the-hir">Identifiers in the HIR</a></li>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/hir.html#the-hir-map">The HIR Map</a></li>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/lowering.html">Lowering AST to HIR</a></li>
<li>How to view HIR representation for your code <code>cargo rustc -- -Zunpretty=hir-tree</code></li>
<li>Rustc HIR definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/index.html"><code>rustc_hir</code></a></li>
<li>Main entry point: <strong>TODO</strong></li>
<li>Late linting: <strong>TODO</strong></li>
</ul>
</li>
<li>Type Inference
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/type-inference.html">Type Inference</a></li>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/ty.html">The ty Module: Representing Types</a> (semantics)</li>
<li>Main entry point (type inference): <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/struct.InferCtxtBuilder.html#method.enter"><code>InferCtxtBuilder::enter</code></a></li>
<li>Main entry point (type checking bodies): <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html#method.typeck_tables_of">the <code>typeck_tables_of</code> query</a>
<ul>
<li>These two functions can't be decoupled.</li>
</ul>
</li>
</ul>
</li>
<li>The Mid Level Intermediate Representation (MIR)
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">The MIR (Mid level IR)</a></li>
<li>Definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/index.html"><code>librustc_middle/mir</code></a></li>
<li>Definition of source that manipulates the MIR: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/index.html"><code>librustc_mir</code></a></li>
</ul>
</li>
<li>The Borrow Checker
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/borrow_check.html">MIR Borrow Check</a></li>
<li>Definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/index.html"><code>rustc_mir/borrow_check</code></a></li>
<li>Main entry point: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/fn.mir_borrowck.html"><code>mir_borrowck</code> query</a></li>
</ul>
</li>
<li>MIR Optimizations
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/mir/optimizations.html">MIR Optimizations</a></li>
<li>Definition: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/index.html"><code>rustc_mir/transform</code></a></li>
<li>Main entry point: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/fn.optimized_mir.html"><code>optimized_mir</code> query</a></li>
</ul>
</li>
<li>Code Generation
<ul>
<li>Guide: <a href="https://rustc-dev-guide.rust-lang.org/backend/codegen.html">Code Generation</a></li>
<li>Generating Machine Code from LLVM IR with LLVM - <strong>TODO: reference?</strong></li>
<li>Main entry point: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_crate.html"><code>rustc_codegen_ssa::base::codegen_crate</code></a>
<ul>
<li>This monomorphizes and produces LLVM IR for one codegen unit. It then
starts a background thread to run LLVM, which must be joined later.</li>
<li>Monomorphization happens lazily via <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#method.monomorphize"><code>FunctionCx::monomorphize</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_instance.html"><code>rustc_codegen_ssa::base::codegen_instance </code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#high-level-overview-of-the-compiler-source" id="high-level-overview-of-the-compiler-source">High-level overview of the compiler source</a></h1>
<h2><a class="header" href="#crate-structure" id="crate-structure">Crate structure</a></h2>
<p>The main Rust repository consists of a <code>src</code> directory, under which
there live many crates. These crates contain the sources for the
standard library and the compiler.  This document, of course, focuses
on the latter.</p>
<p>Rustc consists of a number of crates, including <code>rustc_ast</code>,
<code>rustc</code>, <code>rustc_target</code>, <code>rustc_codegen</code>, <code>rustc_driver</code>, and
many more. The source for each crate can be found in a directory
like <code>src/libXXX</code>, where <code>XXX</code> is the crate name.</p>
<p>(N.B. The names and divisions of these crates are not set in
stone and may change over time. For the time being, we tend towards a
finer-grained division to help with compilation time, though as incremental
compilation improves, that may change.)</p>
<p>The dependency structure of these crates is roughly a diamond:</p>
<pre><code class="language-text">                  rustc_driver
                /      |       \
              /        |         \
            /          |           \
          /            v             \
rustc_codegen  rustc_borrowck   ...  rustc_metadata
          \            |            /
            \          |          /
              \        |        /
                \      v      /
                  rustc_middle
                       |
                       v
                   rustc_ast
                    /    \
                  /       \
           rustc_span  rustc_builtin_macros
</code></pre>
<p>The <code>rustc_driver</code> crate, at the top of this lattice, is effectively
the &quot;main&quot; function for the rust compiler. It doesn't have much &quot;real
code&quot;, but instead ties together all of the code defined in the other
crates and defines the overall flow of execution. (As we transition
more and more to the <a href="query.html">query model</a>, however, the
&quot;flow&quot; of compilation is becoming less centrally defined.)</p>
<p>At the other extreme, the <code>rustc_middle</code> crate defines the common and
pervasive data structures that all the rest of the compiler uses
(e.g. how to represent types, traits, and the program itself). It
also contains some amount of the compiler itself, although that is
relatively limited.</p>
<p>Finally, all the crates in the bulge in the middle define the bulk of
the compiler – they all depend on <code>rustc_middle</code>, so that they can make use
of the various types defined there, and they export public routines
that <code>rustc_driver</code> will invoke as needed (more and more, what these
crates export are &quot;query definitions&quot;, but those are covered later
on).</p>
<p>Below <code>rustc_middle</code> lie various crates that make up the parser and error
reporting mechanism. They are also an internal part
of the compiler and not intended to be stable (though they do wind up
getting used by some crates in the wild; a practice we hope to
gradually phase out).</p>
<h2><a class="header" href="#the-main-stages-of-compilation" id="the-main-stages-of-compilation">The main stages of compilation</a></h2>
<p>The Rust compiler is in a bit of transition right now. It used to be a
purely &quot;pass-based&quot; compiler, where we ran a number of passes over the
entire program, and each did a particular check of transformation. We
are gradually replacing this pass-based code with an alternative setup
based on on-demand <strong>queries</strong>. In the query-model, we work backwards,
executing a <em>query</em> that expresses our ultimate goal (e.g. &quot;compile
this crate&quot;). This query in turn may make other queries (e.g. &quot;get me
a list of all modules in the crate&quot;). Those queries make other queries
that ultimately bottom out in the base operations, like parsing the
input, running the type-checker, and so forth. This on-demand model
permits us to do exciting things like only do the minimal amount of
work needed to type-check a single function. It also helps with
incremental compilation. (For details on defining queries, check out
the <a href="query.html">query model</a>.)</p>
<p>Regardless of the general setup, the basic operations that the
compiler must perform are the same. The only thing that changes is
whether these operations are invoked front-to-back, or on demand.  In
order to compile a Rust crate, these are the general steps that we
take:</p>
<ol>
<li><strong>Parsing input</strong>
<ul>
<li>this processes the <code>.rs</code> files and produces the AST
(&quot;abstract syntax tree&quot;)</li>
<li>the AST is defined in <code>src/librustc_ast/ast.rs</code>. It is intended to match the lexical
syntax of the Rust language quite closely.</li>
</ul>
</li>
<li><strong>Name resolution, macro expansion, and configuration</strong>
<ul>
<li>once parsing is complete, we process the AST recursively, resolving
paths and expanding macros. This same process also processes <code>#[cfg]</code>
nodes, and hence may strip things out of the AST as well.</li>
</ul>
</li>
<li><strong>Lowering to HIR</strong>
<ul>
<li>Once name resolution completes, we convert the AST into the HIR,
or &quot;<a href="hir.html">high-level intermediate representation</a>&quot;. The HIR is defined in
<code>src/librustc_middle/hir/</code>; that module also includes the <a href="lowering.html">lowering</a> code.</li>
<li>The HIR is a lightly desugared variant of the AST. It is more processed
than the AST and more suitable for the analyses that follow.
It is <strong>not</strong> required to match the syntax of the Rust language.</li>
<li>As a simple example, in the <strong>AST</strong>, we preserve the parentheses
that the user wrote, so <code>((1 + 2) + 3)</code> and <code>1 + 2 + 3</code> parse
into distinct trees, even though they are equivalent. In the
HIR, however, parentheses nodes are removed, and those two
expressions are represented in the same way.</li>
</ul>
</li>
<li><strong>Type-checking and subsequent analyses</strong>
<ul>
<li>An important step in processing the HIR is to perform type
checking. This process assigns types to every HIR expression,
for example, and also is responsible for resolving some
&quot;type-dependent&quot; paths, such as field accesses (<code>x.f</code> – we
can't know what field <code>f</code> is being accessed until we know the
type of <code>x</code>) and associated type references (<code>T::Item</code> – we
can't know what type <code>Item</code> is until we know what <code>T</code> is).</li>
<li>Type checking creates &quot;side-tables&quot; (<code>TypeckTables</code>) that include
the types of expressions, the way to resolve methods, and so forth.</li>
<li>After type-checking, we can do other analyses, such as privacy checking.</li>
</ul>
</li>
<li><strong>Lowering to MIR and post-processing</strong>
<ul>
<li>Once type-checking is done, we can lower the HIR into MIR (&quot;middle IR&quot;),
which is a <strong>very</strong> desugared version of Rust, well suited to borrowck
but also to certain high-level optimizations.</li>
</ul>
</li>
<li><strong>Translation to LLVM and LLVM optimizations</strong>
<ul>
<li>From MIR, we can produce LLVM IR.</li>
<li>LLVM then runs its various optimizations, which produces a number of
<code>.o</code> files (one for each &quot;codegen unit&quot;).</li>
</ul>
</li>
<li><strong>Linking</strong>
<ul>
<li>Finally, those <code>.o</code> files are linked together.</li>
</ul>
</li>
</ol>
<h1><a class="header" href="#queries-demand-driven-compilation" id="queries-demand-driven-compilation">Queries: demand-driven compilation</a></h1>
<p>As described in <a href="high-level-overview.html">the high-level overview of the compiler</a>, the
Rust compiler is currently transitioning from a traditional &quot;pass-based&quot;
setup to a &quot;demand-driven&quot; system. <strong>The Compiler Query System is the
key to our new demand-driven organization.</strong> The idea is pretty
simple. You have various queries that compute things about the input
– for example, there is a query called <code>type_of(def_id)</code> that, given
the <a href="appendix/glossary.html#def-id">def-id</a> of some item, will compute the type of that item and return
it to you.</p>
<p>Query execution is <strong>memoized</strong> – so the first time you invoke a
query, it will go do the computation, but the next time, the result is
returned from a hashtable. Moreover, query execution fits nicely into
<strong>incremental computation</strong>; the idea is roughly that, when you do a
query, the result <strong>may</strong> be returned to you by loading stored data
from disk (but that's a separate topic we won't discuss further here).</p>
<p>The overall vision is that, eventually, the entire compiler
control-flow will be query driven. There will effectively be one
top-level query (&quot;compile&quot;) that will run compilation on a crate; this
will in turn demand information about that crate, starting from the
<em>end</em>.  For example:</p>
<ul>
<li>This &quot;compile&quot; query might demand to get a list of codegen-units
(i.e. modules that need to be compiled by LLVM).</li>
<li>But computing the list of codegen-units would invoke some subquery
that returns the list of all modules defined in the Rust source.</li>
<li>That query in turn would invoke something asking for the HIR.</li>
<li>This keeps going further and further back until we wind up doing the
actual parsing.</li>
</ul>
<p>However, that vision is not fully realized. Still, big chunks of the
compiler (for example, generating MIR) work exactly like this.</p>
<h3><a class="header" href="#incremental-compilation-in-detail" id="incremental-compilation-in-detail">Incremental Compilation in Detail</a></h3>
<p>The <a href="queries/incremental-compilation-in-detail.html">Incremental Compilation in Detail</a> chapter gives a more
in-depth description of what queries are and how they work.
If you intend to write a query of your own, this is a good read.</p>
<h3><a class="header" href="#invoking-queries" id="invoking-queries">Invoking queries</a></h3>
<p>To invoke a query is simple. The tcx (&quot;type context&quot;) offers a method
for each defined query. So, for example, to invoke the <code>type_of</code>
query, you would just do this:</p>
<pre><code class="language-rust ignore">let ty = tcx.type_of(some_def_id);
</code></pre>
<h3><a class="header" href="#how-the-compiler-executes-a-query" id="how-the-compiler-executes-a-query">How the compiler executes a query</a></h3>
<p>So you may be wondering what happens when you invoke a query
method. The answer is that, for each query, the compiler maintains a
cache – if your query has already been executed, then, the answer is
simple: we clone the return value out of the cache and return it
(therefore, you should try to ensure that the return types of queries
are cheaply cloneable; insert a <code>Rc</code> if necessary).</p>
<h4><a class="header" href="#providers" id="providers">Providers</a></h4>
<p>If, however, the query is <em>not</em> in the cache, then the compiler will
try to find a suitable <strong>provider</strong>. A provider is a function that has
been defined and linked into the compiler somewhere that contains the
code to compute the result of the query.</p>
<p><strong>Providers are defined per-crate.</strong> The compiler maintains,
internally, a table of providers for every crate, at least
conceptually. Right now, there are really two sets: the providers for
queries about the <strong>local crate</strong> (that is, the one being compiled)
and providers for queries about <strong>external crates</strong> (that is,
dependencies of the local crate). Note that what determines the crate
that a query is targeting is not the <em>kind</em> of query, but the <em>key</em>.
For example, when you invoke <code>tcx.type_of(def_id)</code>, that could be a
local query or an external query, depending on what crate the <code>def_id</code>
is referring to (see the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/query/keys/trait.Key.html"><code>self::keys::Key</code></a> trait for more
information on how that works).</p>
<p>Providers always have the same signature:</p>
<pre><code class="language-rust ignore">fn provider&lt;'tcx&gt;(
    tcx: TyCtxt&lt;'tcx&gt;,
    key: QUERY_KEY,
) -&gt; QUERY_RESULT {
    ...
}
</code></pre>
<p>Providers take two arguments: the <code>tcx</code> and the query key.
They return the result of the query.</p>
<h4><a class="header" href="#how-providers-are-setup" id="how-providers-are-setup">How providers are setup</a></h4>
<p>When the tcx is created, it is given the providers by its creator using
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/query/struct.Providers.html"><code>Providers</code></a> struct. This struct is generated by
the macros here, but it is basically a big list of function pointers:</p>
<pre><code class="language-rust ignore">struct Providers {
    type_of: for&lt;'tcx&gt; fn(TyCtxt&lt;'tcx&gt;, DefId) -&gt; Ty&lt;'tcx&gt;,
    ...
}
</code></pre>
<p>At present, we have one copy of the struct for local crates, and one
for external crates, though the plan is that we may eventually have
one per crate.</p>
<p>These <code>Providers</code> structs are ultimately created and populated by
<code>librustc_driver</code>, but it does this by distributing the work
throughout the other <code>rustc_*</code> crates. This is done by invoking
various <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/fn.provide.html"><code>provide</code></a> functions. These functions tend to look
something like this:</p>
<pre><code class="language-rust ignore">pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        ..*providers
    };
}
</code></pre>
<p>That is, they take an <code>&amp;mut Providers</code> and mutate it in place. Usually
we use the formulation above just because it looks nice, but you could
as well do <code>providers.type_of = type_of</code>, which would be equivalent.
(Here, <code>type_of</code> would be a top-level function, defined as we saw
before.) So, if we want to add a provider for some other query,
let's call it <code>fubar</code>, into the crate above, we might modify the <code>provide()</code>
function like so:</p>
<pre><code class="language-rust ignore">pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        fubar,
        ..*providers
    };
}

fn fubar&lt;'tcx&gt;(tcx: TyCtxt&lt;'tcx&gt;, key: DefId) -&gt; Fubar&lt;'tcx&gt; { ... }
</code></pre>
<p>N.B. Most of the <code>rustc_*</code> crates only provide <strong>local
providers</strong>. Almost all <strong>extern providers</strong> wind up going through the
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_metadata"><code>rustc_metadata</code> crate</a>, which loads the information
from the crate metadata. But in some cases there are crates that
provide queries for <em>both</em> local and external crates, in which case
they define both a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/attributes/fn.provide.html"><code>provide</code></a> and a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/attributes/fn.provide_extern.html"><code>provide_extern</code></a> function that <code>rustc_driver</code>
can invoke.</p>
<h3><a class="header" href="#adding-a-new-kind-of-query" id="adding-a-new-kind-of-query">Adding a new kind of query</a></h3>
<p>So suppose you want to add a new kind of query, how do you do so?
Well, defining a query takes place in two steps:</p>
<ol>
<li>first, you have to specify the query name and arguments; and then,</li>
<li>you have to supply query providers where needed.</li>
</ol>
<p>To specify the query name and arguments, you simply add an entry to
the big macro invocation in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/query/index.html"><code>src/librustc_middle/query/mod.rs</code></a>, which looks something like:</p>
<pre><code class="language-rust ignore">rustc_queries! {
    Other {
        /// Records the type of every item.
        query type_of(key: DefId) -&gt; Ty&lt;'tcx&gt; {
            cache { key.is_local() }
        }
    }

    ...
}
</code></pre>
<p>Queries are grouped into categories (<code>Other</code>, <code>Codegen</code>, <code>TypeChecking</code>, etc.).
Each group contains one or more queries. Each query definition is broken up like
this:</p>
<pre><code class="language-rust ignore">query type_of(key: DefId) -&gt; Ty&lt;'tcx&gt; { ... }
^^    ^^^^^^^      ^^^^^     ^^^^^^^^   ^^^
|     |            |         |          |
|     |            |         |          query modifiers
|     |            |         result type of query
|     |            query key type
|     name of query
query keyword
</code></pre>
<p>Let's go over them one by one:</p>
<ul>
<li><strong>Query keyword:</strong> indicates a start of a query definition.</li>
<li><strong>Name of query:</strong> the name of the query method
(<code>tcx.type_of(..)</code>). Also used as the name of a struct
(<code>ty::queries::type_of</code>) that will be generated to represent
this query.</li>
<li><strong>Query key type:</strong> the type of the argument to this query.
This type must implement the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/query/keys/trait.Key.html"><code>ty::query::keys::Key</code></a> trait, which
defines (for example) how to map it to a crate, and so forth.</li>
<li><strong>Result type of query:</strong> the type produced by this query. This type
should (a) not use <code>RefCell</code> or other interior mutability and (b) be
cheaply cloneable. Interning or using <code>Rc</code> or <code>Arc</code> is recommended for
non-trivial data types.
<ul>
<li>The one exception to those rules is the <code>ty::steal::Steal</code> type,
which is used to cheaply modify MIR in place. See the definition
of <code>Steal</code> for more details. New uses of <code>Steal</code> should <strong>not</strong> be
added without alerting <code>@rust-lang/compiler</code>.</li>
</ul>
</li>
<li><strong>Query modifiers:</strong> various flags and options that customize how the
query is processed (mostly with respect to <a href="queries/incremental-compilation-in-detail.html#query-modifiers">incremental compilation</a>).</li>
</ul>
<p>So, to add a query:</p>
<ul>
<li>Add an entry to <code>rustc_queries!</code> using the format above.</li>
<li>Link the provider by modifying the appropriate <code>provide</code> method;
or add a new one if needed and ensure that <code>rustc_driver</code> is invoking it.</li>
</ul>
<h4><a class="header" href="#query-structs-and-descriptions" id="query-structs-and-descriptions">Query structs and descriptions</a></h4>
<p>For each kind, the <code>rustc_queries</code> macro will generate a &quot;query struct&quot;
named after the query. This struct is a kind of a place-holder
describing the query. Each such struct implements the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/query/trait.QueryConfig.html"><code>self::config::QueryConfig</code></a> trait, which has associated types for the
key/value of that particular query. Basically the code generated looks something
like this:</p>
<pre><code class="language-rust ignore">// Dummy struct representing a particular kind of query:
pub struct type_of&lt;'tcx&gt; { data: PhantomData&lt;&amp;'tcx ()&gt; }

impl&lt;'tcx&gt; QueryConfig for type_of&lt;'tcx&gt; {
  type Key = DefId;
  type Value = Ty&lt;'tcx&gt;;

  const NAME: QueryName = QueryName::type_of;
  const CATEGORY: ProfileCategory = ProfileCategory::Other;
}
</code></pre>
<p>There is an additional trait that you may wish to implement called
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_query_system/query/config/trait.QueryDescription.html"><code>self::config::QueryDescription</code></a>. This trait is
used during cycle errors to give a &quot;human readable&quot; name for the query,
so that we can summarize what was happening when the cycle occurred.
Implementing this trait is optional if the query key is <code>DefId</code>, but
if you <em>don't</em> implement it, you get a pretty generic error (&quot;processing <code>foo</code>...&quot;).
You can put new impls into the <code>config</code> module. They look something like this:</p>
<pre><code class="language-rust ignore">impl&lt;'tcx&gt; QueryDescription for queries::type_of&lt;'tcx&gt; {
    fn describe(tcx: TyCtxt, key: DefId) -&gt; String {
        format!(&quot;computing the type of `{}`&quot;, tcx.def_path_str(key))
    }
}
</code></pre>
<p>Another option is to add <code>desc</code> modifier:</p>
<pre><code class="language-rust ignore">rustc_queries! {
    Other {
        /// Records the type of every item.
        query type_of(key: DefId) -&gt; Ty&lt;'tcx&gt; {
            desc { |tcx| &quot;computing the type of `{}`&quot;, tcx.def_path_str(key) }
        }
    }
}
</code></pre>
<p><code>rustc_queries</code> macro will generate an appropriate <code>impl</code> automatically.</p>
<h1><a class="header" href="#the-query-evaluation-model-in-detail" id="the-query-evaluation-model-in-detail">The Query Evaluation Model in Detail</a></h1>
<p>This chapter provides a deeper dive into the abstract model queries are built on.
It does not go into implementation details but tries to explain
the underlying logic. The examples here, therefore, have been stripped down and
simplified and don't directly reflect the compilers internal APIs.</p>
<h2><a class="header" href="#what-is-a-query" id="what-is-a-query">What is a query?</a></h2>
<p>Abstractly we view the compiler's knowledge about a given crate as a &quot;database&quot;
and queries are the way of asking the compiler questions about it, i.e.
we &quot;query&quot; the compiler's &quot;database&quot; for facts.</p>
<p>However, there's something special to this compiler database: It starts out empty
and is filled on-demand when queries are executed. Consequently, a query must
know how to compute its result if the database does not contain it yet. For
doing so, it can access other queries and certain input values that the database
is pre-filled with on creation.</p>
<p>A query thus consists of the following things:</p>
<ul>
<li>A name that identifies the query</li>
<li>A &quot;key&quot; that specifies what we want to look up</li>
<li>A result type that specifies what kind of result it yields</li>
<li>A &quot;provider&quot; which is a function that specifies how the result is to be
computed if it isn't already present in the database.</li>
</ul>
<p>As an example, the name of the <code>type_of</code> query is <code>type_of</code>, its query key is a
<code>DefId</code> identifying the item we want to know the type of, the result type is
<code>Ty&lt;'tcx&gt;</code>, and the provider is a function that, given the query key and access
to the rest of the database, can compute the type of the item identified by the
key.</p>
<p>So in some sense a query is just a function that maps the query key to the
corresponding result. However, we have to apply some restrictions in order for
this to be sound:</p>
<ul>
<li>The key and result must be immutable values.</li>
<li>The provider function must be a pure function, that is, for the same key it
must always yield the same result.</li>
<li>The only parameters a provider function takes are the key and a reference to
the &quot;query context&quot; (which provides access to rest of the &quot;database&quot;).</li>
</ul>
<p>The database is built up lazily by invoking queries. The query providers will
invoke other queries, for which the result is either already cached or computed
by calling another query provider. These query provider invocations
conceptually form a directed acyclic graph (DAG) at the leaves of which are
input values that are already known when the query context is created.</p>
<h2><a class="header" href="#cachingmemoization" id="cachingmemoization">Caching/Memoization</a></h2>
<p>Results of query invocations are &quot;memoized&quot; which means that the query context
will cache the result in an internal table and, when the query is invoked with
the same query key again, will return the result from the cache instead of
running the provider again.</p>
<p>This caching is crucial for making the query engine efficient. Without
memoization the system would still be sound (that is, it would yield the same
results) but the same computations would be done over and over again.</p>
<p>Memoization is one of the main reasons why query providers have to be pure
functions. If calling a provider function could yield different results for
each invocation (because it accesses some global mutable state) then we could
not memoize the result.</p>
<h2><a class="header" href="#input-data" id="input-data">Input data</a></h2>
<p>When the query context is created, it is still empty: No queries have been
executed, no results are cached. But the context already provides access to
&quot;input&quot; data, i.e. pieces of immutable data that were computed before the
context was created and that queries can access to do their computations.
Currently this input data consists mainly of the HIR map, upstream crate
metadata, and the command-line
options the compiler was invoked with. In the future, inputs will just consist
of command-line options and a list of source files -- the HIR map will itself
be provided by a query which processes these source files.</p>
<p>Without inputs, queries would live in a void without anything to compute their
result from (remember, query providers only have access to other queries and
the context but not any other outside state or information).</p>
<p>For a query provider, input data and results of other queries look exactly the
same: It just tells the context &quot;give me the value of X&quot;. Because input data
is immutable, the provider can rely on it being the same across
different query invocations, just as is the case for query results.</p>
<h2><a class="header" href="#an-example-execution-trace-of-some-queries" id="an-example-execution-trace-of-some-queries">An example execution trace of some queries</a></h2>
<p>How does this DAG of query invocations come into existence? At some point
the compiler driver will create the, as yet empty, query context. It will then,
from outside of the query system, invoke the queries it needs to perform its
task. This looks something like the following:</p>
<pre><code class="language-rust ignore">fn compile_crate() {
    let cli_options = ...;
    let hir_map = ...;

    // Create the query context `tcx`
    let tcx = TyCtxt::new(cli_options, hir_map);

    // Do type checking by invoking the type check query
    tcx.type_check_crate();
}
</code></pre>
<p>The <code>type_check_crate</code> query provider would look something like the following:</p>
<pre><code class="language-rust ignore">fn type_check_crate_provider(tcx, _key: ()) {
    let list_of_hir_items = tcx.hir_map.list_of_items();

    for item_def_id in list_of_hir_items {
        tcx.type_check_item(item_def_id);
    }
}
</code></pre>
<p>We see that the <code>type_check_crate</code> query accesses input data
(<code>tcx.hir_map.list_of_items()</code>) and invokes other queries
(<code>type_check_item</code>). The <code>type_check_item</code>
invocations will themselves access input data and/or invoke other queries,
so that in the end the DAG of query invocations will be built up backwards
from the node that was initially executed:</p>
<pre><code class="language-ignore">         (2)                                                 (1)
  list_of_all_hir_items &lt;----------------------------- type_check_crate()
                                                               |
    (5)             (4)                  (3)                   |
  Hir(foo) &lt;--- type_of(foo) &lt;--- type_check_item(foo) &lt;-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
    (7)             v  (6)                  (8)                |
  Hir(bar) &lt;--- type_of(bar) &lt;--- type_check_item(bar) &lt;-------+

// (x) denotes invocation order
</code></pre>
<p>We also see that often a query result can be read from the cache:
<code>type_of(bar)</code> was computed for <code>type_check_item(foo)</code> so when
<code>type_check_item(bar)</code> needs it, it is already in the cache.</p>
<p>Query results stay cached in the query context as long as the context lives.
So if the compiler driver invoked another query later on, the above graph
would still exist and already executed queries would not have to be re-done.</p>
<h2><a class="header" href="#cycles" id="cycles">Cycles</a></h2>
<p>Earlier we stated that query invocations form a DAG. However, it would be easy
to form a cyclic graph by, for example, having a query provider like the
following:</p>
<pre><code class="language-rust ignore">fn cyclic_query_provider(tcx, key) -&gt; u32 {
  // Invoke the same query with the same key again
  tcx.cyclic_query(key)
}
</code></pre>
<p>Since query providers are regular functions, this would behave much as expected:
Evaluation would get stuck in an infinite recursion. A query like this would not
be very useful either. However, sometimes certain kinds of invalid user input
can result in queries being called in a cyclic way. The query engine includes
a check for cyclic invocations and, because cycles are an irrecoverable error,
will abort execution with a &quot;cycle error&quot; messages that tries to be human
readable.</p>
<p>At some point the compiler had a notion of &quot;cycle recovery&quot;, that is, one could
&quot;try&quot; to execute a query and if it ended up causing a cycle, proceed in some
other fashion. However, this was later removed because it is not entirely
clear what the theoretical consequences of this are, especially regarding
incremental compilation.</p>
<h2><a class="header" href="#steal-queries" id="steal-queries">&quot;Steal&quot; Queries</a></h2>
<p>Some queries have their result wrapped in a <code>Steal&lt;T&gt;</code> struct. These queries
behave exactly the same as regular with one exception: Their result is expected
to be &quot;stolen&quot; out of the cache at some point, meaning some other part of the
program is taking ownership of it and the result cannot be accessed anymore.</p>
<p>This stealing mechanism exists purely as a performance optimization because some
result values are too costly to clone (e.g. the MIR of a function). It seems
like result stealing would violate the condition that query results must be
immutable (after all we are moving the result value out of the cache) but it is
OK as long as the mutation is not observable. This is achieved by two things:</p>
<ul>
<li>Before a result is stolen, we make sure to eagerly run all queries that
might ever need to read that result. This has to be done manually by calling
those queries.</li>
<li>Whenever a query tries to access a stolen result, we make the compiler ICE so
that such a condition cannot go unnoticed.</li>
</ul>
<p>This is not an ideal setup because of the manual intervention needed, so it
should be used sparingly and only when it is well known which queries might
access a given result. In practice, however, stealing has not turned out to be
much of a maintenance burden.</p>
<p>To summarize: &quot;Steal queries&quot; break some of the rules in a controlled way.
There are checks in place that make sure that nothing can go silently wrong.</p>
<h2><a class="header" href="#parallel-query-execution" id="parallel-query-execution">Parallel Query Execution</a></h2>
<p>The query model has some properties that make it actually feasible to evaluate
multiple queries in parallel without too much of an effort:</p>
<ul>
<li>All data a query provider can access is accessed via the query context, so
the query context can take care of synchronizing access.</li>
<li>Query results are required to be immutable so they can safely be used by
different threads concurrently.</li>
</ul>
<p>The nightly compiler already implements parallel query evaluation as follows:</p>
<p>When a query <code>foo</code> is evaluated, the cache table for <code>foo</code> is locked.</p>
<ul>
<li>If there already is a result, we can clone it, release the lock and
we are done.</li>
<li>If there is no cache entry and no other active query invocation computing the
same result, we mark the key as being &quot;in progress&quot;, release the lock and
start evaluating.</li>
<li>If there <em>is</em> another query invocation for the same key in progress, we
release the lock, and just block the thread until the other invocation has
computed the result we are waiting for. This cannot deadlock because, as
mentioned before, query invocations form a DAG. Some thread will always make
progress.</li>
</ul>
<h1><a class="header" href="#incremental-compilation" id="incremental-compilation">Incremental compilation</a></h1>
<p>The incremental compilation scheme is, in essence, a surprisingly
simple extension to the overall query system. We'll start by describing
a slightly simplified variant of the real thing – the &quot;basic algorithm&quot; –
and then describe some possible improvements.</p>
<h2><a class="header" href="#the-basic-algorithm" id="the-basic-algorithm">The basic algorithm</a></h2>
<p>The basic algorithm is
called the <strong>red-green</strong> algorithm<sup class="footnote-reference"><a href="#salsa">1</a></sup>. The high-level idea is
that, after each run of the compiler, we will save the results of all
the queries that we do, as well as the <strong>query DAG</strong>. The
<strong>query DAG</strong> is a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> that indexes which queries executed which
other queries. So, for example, there would be an edge from a query Q1
to another query Q2 if computing Q1 required computing Q2 (note that
because queries cannot depend on themselves, this results in a DAG and
not a general graph).</p>
<p>On the next run of the compiler, then, we can sometimes reuse these
query results to avoid re-executing a query. We do this by assigning
every query a <strong>color</strong>:</p>
<ul>
<li>If a query is colored <strong>red</strong>, that means that its result during
this compilation has <strong>changed</strong> from the previous compilation.</li>
<li>If a query is colored <strong>green</strong>, that means that its result is
the <strong>same</strong> as the previous compilation.</li>
</ul>
<p>There are two key insights here:</p>
<ul>
<li>First, if all the inputs to query Q are colored green, then the
query Q <strong>must</strong> result in the same value as last time and hence
need not be re-executed (or else the compiler is not deterministic).</li>
<li>Second, even if some inputs to a query changes, it may be that it
<strong>still</strong> produces the same result as the previous compilation. In
particular, the query may only use part of its input.
<ul>
<li>Therefore, after executing a query, we always check whether it
produced the same result as the previous time. <strong>If it did,</strong> we
can still mark the query as green, and hence avoid re-executing
dependent queries.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#the-try-mark-green-algorithm" id="the-try-mark-green-algorithm">The try-mark-green algorithm</a></h3>
<p>At the core of incremental compilation is an algorithm called
&quot;try-mark-green&quot;. It has the job of determining the color of a given
query Q (which must not have yet been executed). In cases where Q has
red inputs, determining Q's color may involve re-executing Q so that
we can compare its output, but if all of Q's inputs are green, then we
can conclude that Q must be green without re-executing it or inspecting
its value at all. In the compiler, this allows us to avoid
deserializing the result from disk when we don't need it, and in fact
enables us to sometimes skip <em>serializing</em> the result as well
(see the refinements section below).</p>
<p>Try-mark-green works as follows:</p>
<ul>
<li>First check if the query Q was executed during the previous compilation.
<ul>
<li>If not, we can just re-execute the query as normal, and assign it the
color of red.</li>
</ul>
</li>
<li>If yes, then load the 'dependent queries' of Q.</li>
<li>If there is a saved result, then we load the <code>reads(Q)</code> vector from the
query DAG. The &quot;reads&quot; is the set of queries that Q executed during
its execution.
<ul>
<li>For each query R in <code>reads(Q)</code>, we recursively demand the color
of R using try-mark-green.
<ul>
<li>Note: it is important that we visit each node in <code>reads(Q)</code> in same order
as they occurred in the original compilation. See <a href="queries/incremental-compilation.html#dag">the section on the
query DAG below</a>.</li>
<li>If <strong>any</strong> of the nodes in <code>reads(Q)</code> wind up colored <strong>red</strong>, then Q is
dirty.
<ul>
<li>We re-execute Q and compare the hash of its result to the hash of the
result from the previous compilation.</li>
<li>If the hash has not changed, we can mark Q as <strong>green</strong> and return.</li>
</ul>
</li>
<li>Otherwise, <strong>all</strong> of the nodes in <code>reads(Q)</code> must be <strong>green</strong>. In that
case, we can color Q as <strong>green</strong> and return.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="dag"></a></p>
<h3><a class="header" href="#the-query-dag" id="the-query-dag">The query DAG</a></h3>
<p>The query DAG code is stored in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_middle/dep_graph"><code>src/librustc_middle/dep_graph</code></a>. Construction of the DAG is done
by instrumenting the query execution.</p>
<p>One key point is that the query DAG also tracks ordering; that is, for
each query Q, we not only track the queries that Q reads, we track the
<strong>order</strong> in which they were read.  This allows try-mark-green to walk
those queries back in the same order. This is important because once a
subquery comes back as red, we can no longer be sure that Q will continue
along the same path as before. That is, imagine a query like this:</p>
<pre><code class="language-rust ignore">fn main_query(tcx) {
    if tcx.subquery1() {
        tcx.subquery2()
    } else {
        tcx.subquery3()
    }
}
</code></pre>
<p>Now imagine that in the first compilation, <code>main_query</code> starts by
executing <code>subquery1</code>, and this returns true. In that case, the next
query <code>main_query</code> executes will be <code>subquery2</code>, and <code>subquery3</code> will
not be executed at all.</p>
<p>But now imagine that in the <strong>next</strong> compilation, the input has
changed such that <code>subquery1</code> returns <strong>false</strong>. In this case, <code>subquery2</code>
would never execute. If try-mark-green were to visit <code>reads(main_query)</code> out
of order, however, it might visit <code>subquery2</code> before <code>subquery1</code>, and hence
execute it.
This can lead to ICEs and other problems in the compiler.</p>
<h2><a class="header" href="#improvements-to-the-basic-algorithm" id="improvements-to-the-basic-algorithm">Improvements to the basic algorithm</a></h2>
<p>In the description of the basic algorithm, we said that at the end of
compilation we would save the results of all the queries that were
performed.  In practice, this can be quite wasteful – many of those
results are very cheap to recompute, and serializing and deserializing
them is not a particular win. In practice, what we would do is to save
<strong>the hashes</strong> of all the subqueries that we performed. Then, in select cases,
we <strong>also</strong> save the results.</p>
<p>This is why the incremental algorithm separates computing the
<strong>color</strong> of a node, which often does not require its value, from
computing the <strong>result</strong> of a node. Computing the result is done via a simple
algorithm like so:</p>
<ul>
<li>Check if a saved result for Q is available. If so, compute the color of Q.
If Q is green, deserialize and return the saved result.</li>
<li>Otherwise, execute Q.
<ul>
<li>We can then compare the hash of the result and color Q as green if
it did not change.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#resources" id="resources">Resources</a></h2>
<p>The initial design document can be found <a href="https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md">here</a>, which expands
on the memoization details, provides more high-level overview and motivation
for this system.</p>
<h1><a class="header" href="#footnotes" id="footnotes">Footnotes</a></h1>
<div class="footnote-definition" id="salsa"><sup class="footnote-definition-label">1</sup>
<p>I have long wanted to rename it to the Salsa algorithm, but it never caught on. -@nikomatsakis</p>
</div>
<h1><a class="header" href="#incremental-compilation-in-detail-1" id="incremental-compilation-in-detail-1">Incremental Compilation In Detail</a></h1>
<p>The incremental compilation scheme is, in essence, a surprisingly
simple extension to the overall query system. It relies on the fact that:</p>
<ol>
<li>queries are pure functions -- given the same inputs, a query will always
yield the same result, and</li>
<li>the query model structures compilation in an acyclic graph that makes
dependencies between individual computations explicit.</li>
</ol>
<p>This chapter will explain how we can use these properties for making things
incremental and then goes on to discuss version implementation issues.</p>
<h2><a class="header" href="#a-basic-algorithm-for-incremental-query-evaluation" id="a-basic-algorithm-for-incremental-query-evaluation">A Basic Algorithm For Incremental Query Evaluation</a></h2>
<p>As explained in the <a href="queries/./query-evaluation-model-in-detail.html">query evaluation model primer</a>, query
invocations form a directed-acyclic graph. Here's the example from the
previous chapter again:</p>
<pre><code class="language-ignore">  list_of_all_hir_items &lt;----------------------------- type_check_crate()
                                                               |
                                                               |
  Hir(foo) &lt;--- type_of(foo) &lt;--- type_check_item(foo) &lt;-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
                    v                                          |
  Hir(bar) &lt;--- type_of(bar) &lt;--- type_check_item(bar) &lt;-------+
</code></pre>
<p>Since every access from one query to another has to go through the query
context, we can record these accesses and thus actually build this dependency
graph in memory. With dependency tracking enabled, when compilation is done,
we know which queries were invoked (the nodes of the graph) and for each
invocation, which other queries or input has gone into computing the query's
result (the edges of the graph).</p>
<p>Now suppose we change the source code of our program so that
HIR of <code>bar</code> looks different than before. Our goal is to only recompute
those queries that are actually affected by the change while re-using
the cached results of all the other queries. Given the dependency graph we can
do exactly that. For a given query invocation, the graph tells us exactly
what data has gone into computing its results, we just have to follow the
edges until we reach something that has changed. If we don't encounter
anything that has changed, we know that the query still would evaluate to
the same result we already have in our cache.</p>
<p>Taking the <code>type_of(foo)</code> invocation from above as an example, we can check
whether the cached result is still valid by following the edges to its
inputs. The only edge leads to <code>Hir(foo)</code>, an input that has not been affected
by the change. So we know that the cached result for <code>type_of(foo)</code> is still
valid.</p>
<p>The story is a bit different for <code>type_check_item(foo)</code>: We again walk the
edges and already know that <code>type_of(foo)</code> is fine. Then we get to
<code>type_of(bar)</code> which we have not checked yet, so we walk the edges of
<code>type_of(bar)</code> and encounter <code>Hir(bar)</code> which <em>has</em> changed. Consequently
the result of <code>type_of(bar)</code> might yield a different same result than what we
have in the cache and, transitively, the result of <code>type_check_item(foo)</code>
might have changed too. We thus re-run <code>type_check_item(foo)</code>, which in
turn will re-run <code>type_of(bar)</code>, which will yield an up-to-date result
because it reads the up-to-date version of <code>Hir(bar)</code>.</p>
<h2><a class="header" href="#the-problem-with-the-basic-algorithm-false-positives" id="the-problem-with-the-basic-algorithm-false-positives">The Problem With The Basic Algorithm: False Positives</a></h2>
<p>If you read the previous paragraph carefully you'll notice that it says that
<code>type_of(bar)</code> <em>might</em> have changed because one of its inputs has changed.
There's also the possibility that it might still yield exactly the same
result <em>even though</em> its input has changed. Consider an example with a
simple query that just computes the sign of an integer:</p>
<pre><code class="language-ignore">  IntValue(x) &lt;---- sign_of(x) &lt;--- some_other_query(x)
</code></pre>
<p>Let's say that <code>IntValue(x)</code> starts out as <code>1000</code> and then is set to <code>2000</code>.
Even though <code>IntValue(x)</code> is different in the two cases, <code>sign_of(x)</code> yields
the result <code>+</code> in both cases.</p>
<p>If we follow the basic algorithm, however, <code>some_other_query(x)</code> would have to
(unnecessarily) be re-evaluated because it transitively depends on a changed
input. Change detection yields a &quot;false positive&quot; in this case because it has
to conservatively assume that <code>some_other_query(x)</code> might be affected by that
changed input.</p>
<p>Unfortunately it turns out that the actual queries in the compiler are full
of examples like this and small changes to the input often potentially affect
very large parts of the output binaries. As a consequence, we had to make the
change detection system smarter and more accurate.</p>
<h2><a class="header" href="#improving-accuracy-the-red-green-algorithm" id="improving-accuracy-the-red-green-algorithm">Improving Accuracy: The red-green Algorithm</a></h2>
<p>The &quot;false positives&quot; problem can be solved by interleaving change detection
and query re-evaluation. Instead of walking the graph all the way to the
inputs when trying to find out if some cached result is still valid, we can
check if a result has <em>actually</em> changed after we were forced to re-evaluate
it.</p>
<p>We call this algorithm the red-green algorithm because nodes
in the dependency graph are assigned the color green if we were able to prove
that its cached result is still valid and the color red if the result has
turned out to be different after re-evaluating it.</p>
<p>The meat of red-green change tracking is implemented in the try-mark-green
algorithm, that, you've guessed it, tries to mark a given node as green:</p>
<pre><code class="language-rust ignore">fn try_mark_green(tcx, current_node) -&gt; bool {

    // Fetch the inputs to `current_node`, i.e. get the nodes that the direct
    // edges from `node` lead to.
    let dependencies = tcx.dep_graph.get_dependencies_of(current_node);

    // Now check all the inputs for changes
    for dependency in dependencies {

        match tcx.dep_graph.get_node_color(dependency) {
            Green =&gt; {
                // This input has already been checked before and it has not
                // changed; so we can go on to check the next one
            }
            Red =&gt; {
                // We found an input that has changed. We cannot mark
                // `current_node` as green without re-running the
                // corresponding query.
                return false
            }
            Unknown =&gt; {
                // This is the first time we look at this node. Let's try
                // to mark it green by calling try_mark_green() recursively.
                if try_mark_green(tcx, dependency) {
                    // We successfully marked the input as green, on to the
                    // next.
                } else {
                    // We could *not* mark the input as green. This means we
                    // don't know if its value has changed. In order to find
                    // out, we re-run the corresponding query now!
                    tcx.run_query_for(dependency);

                    // Fetch and check the node color again. Running the query
                    // has forced it to either red (if it yielded a different
                    // result than we have in the cache) or green (if it
                    // yielded the same result).
                    match tcx.dep_graph.get_node_color(dependency) {
                        Red =&gt; {
                            // The input turned out to be red, so we cannot
                            // mark `current_node` as green.
                            return false
                        }
                        Green =&gt; {
                            // Re-running the query paid off! The result is the
                            // same as before, so this particular input does
                            // not invalidate `current_node`.
                        }
                        Unknown =&gt; {
                            // There is no way a node has no color after
                            // re-running the query.
                            panic!(&quot;unreachable&quot;)
                        }
                    }
                }
            }
        }
    }

    // If we have gotten through the entire loop, it means that all inputs
    // have turned out to be green. If all inputs are unchanged, it means
    // that the query result corresponding to `current_node` cannot have
    // changed either.
    tcx.dep_graph.mark_green(current_node);

    true
}

// Note: The actual implementation can be found in
//       src/librustc_middle/dep_graph/graph.rs
</code></pre>
<p>By using red-green marking we can avoid the devastating cumulative effect of
having false positives during change detection. Whenever a query is executed
in incremental mode, we first check if its already green. If not, we run
<code>try_mark_green()</code> on it. If it still isn't green after that, then we actually
invoke the query provider to re-compute the result.</p>
<h2><a class="header" href="#the-real-world-how-persistence-makes-everything-complicated" id="the-real-world-how-persistence-makes-everything-complicated">The Real World: How Persistence Makes Everything Complicated</a></h2>
<p>The sections above described the underlying algorithm for incremental
compilation but because the compiler process exits after being finished and
takes the query context with its result cache with it into oblivion, we have to
persist data to disk, so the next compilation session can make use of it.
This comes with a whole new set of implementation challenges:</p>
<ul>
<li>The query result cache is stored to disk, so they are not readily available
for change comparison.</li>
<li>A subsequent compilation session will start off with new version of the code
that has arbitrary changes applied to it. All kinds of IDs and indices that
are generated from a global, sequential counter (e.g. <code>NodeId</code>, <code>DefId</code>, etc)
might have shifted, making the persisted results on disk not immediately
usable anymore because the same numeric IDs and indices might refer to
completely new things in the new compilation session.</li>
<li>Persisting things to disk comes at a cost, so not every tiny piece of
information should be actually cached in between compilation sessions.
Fixed-sized, plain-old-data is preferred to complex things that need to run
through an expensive (de-)serialization step.</li>
</ul>
<p>The following sections describe how the compiler currently solves these issues.</p>
<h3><a class="header" href="#a-question-of-stability-bridging-the-gap-between-compilation-sessions" id="a-question-of-stability-bridging-the-gap-between-compilation-sessions">A Question Of Stability: Bridging The Gap Between Compilation Sessions</a></h3>
<p>As noted before, various IDs (like <code>DefId</code>) are generated by the compiler in a
way that depends on the contents of the source code being compiled. ID assignment
is usually deterministic, that is, if the exact same code is compiled twice,
the same things will end up with the same IDs. However, if something
changes, e.g. a function is added in the middle of a file, there is no
guarantee that anything will have the same ID as it had before.</p>
<p>As a consequence we cannot represent the data in our on-disk cache the same
way it is represented in memory. For example, if we just stored a piece
of type information like <code>TyKind::FnDef(DefId, &amp;'tcx Substs&lt;'tcx&gt;)</code> (as we do
in memory) and then the contained <code>DefId</code> points to a different function in
a new compilation session we'd be in trouble.</p>
<p>The solution to this problem is to find &quot;stable&quot; forms for IDs which remain
valid in between compilation sessions. For the most important case, <code>DefId</code>s,
these are the so-called <code>DefPath</code>s. Each <code>DefId</code> has a
corresponding <code>DefPath</code> but in place of a numeric ID, a <code>DefPath</code> is based on
the path to the identified item, e.g. <code>std::collections::HashMap</code>. The
advantage of an ID like this is that it is not affected by unrelated changes.
For example, one can add a new function to <code>std::collections</code> but
<code>std::collections::HashMap</code> would still be <code>std::collections::HashMap</code>. A
<code>DefPath</code> is &quot;stable&quot; across changes made to the source code while a <code>DefId</code>
isn't.</p>
<p>There is also the <code>DefPathHash</code> which is just a 128-bit hash value of the
<code>DefPath</code>. The two contain the same information and we mostly use the
<code>DefPathHash</code> because it simpler to handle, being <code>Copy</code> and self-contained.</p>
<p>This principle of stable identifiers is used to make the data in the on-disk
cache resilient to source code changes. Instead of storing a <code>DefId</code>, we store
the <code>DefPathHash</code> and when we deserialize something from the cache, we map the
<code>DefPathHash</code> to the corresponding <code>DefId</code> in the <em>current</em> compilation session
(which is just a simple hash table lookup).</p>
<p>The <code>HirId</code>, used for identifying HIR components that don't have their own
<code>DefId</code>, is another such stable ID. It is (conceptually) a pair of a <code>DefPath</code>
and a <code>LocalId</code>, where the <code>LocalId</code> identifies something (e.g. a <code>hir::Expr</code>)
locally within its &quot;owner&quot; (e.g. a <code>hir::Item</code>). If the owner is moved around,
the <code>LocalId</code>s within it are still the same.</p>
<h3><a class="header" href="#checking-query-results-for-changes-hashstable-and-fingerprints" id="checking-query-results-for-changes-hashstable-and-fingerprints">Checking Query Results For Changes: HashStable And Fingerprints</a></h3>
<p>In order to do red-green-marking we often need to check if the result of a
query has changed compared to the result it had during the previous
compilation session. There are two performance problems with this though:</p>
<ul>
<li>We'd like to avoid having to load the previous result from disk just for
doing the comparison. We already computed the new result and will use that.
Also loading a result from disk will &quot;pollute&quot; the interners with data that
is unlikely to ever be used.</li>
<li>We don't want to store each and every result in the on-disk cache. For
example, it would be wasted effort to persist things to disk that are
already available in upstream crates.</li>
</ul>
<p>The compiler avoids these problems by using so-called <code>Fingerprint</code>s. Each time
a new query result is computed, the query engine will compute a 128 bit hash
value of the result. We call this hash value &quot;the <code>Fingerprint</code> of the query
result&quot;. The hashing is (and has to be) done &quot;in a stable way&quot;. This means
that whenever something is hashed that might change in between compilation
sessions (e.g. a <code>DefId</code>), we instead hash its stable equivalent
(e.g. the corresponding <code>DefPath</code>). That's what the whole <code>HashStable</code>
infrastructure is for. This way <code>Fingerprint</code>s computed in two
different compilation sessions are still comparable.</p>
<p>The next step is to store these fingerprints along with the dependency graph.
This is cheap since fingerprints are just bytes to be copied. It's also cheap to
load the entire set of fingerprints together with the dependency graph.</p>
<p>Now, when red-green-marking reaches the point where it needs to check if a
result has changed, it can just compare the (already loaded) previous
fingerprint to the fingerprint of the new result.</p>
<p>This approach works rather well but it's not without flaws:</p>
<ul>
<li>
<p>There is a small possibility of hash collisions. That is, two different
results could have the same fingerprint and the system would erroneously
assume that the result hasn't changed, leading to a missed update.</p>
<p>We mitigate this risk by using a high-quality hash function and a 128 bit
wide hash value. Due to these measures the practical risk of a hash
collision is negligible.</p>
</li>
<li>
<p>Computing fingerprints is quite costly. It is the main reason why incremental
compilation can be slower than non-incremental compilation. We are forced to
use a good and thus expensive hash function, and we have to map things to
their stable equivalents while doing the hashing.</p>
</li>
</ul>
<h3><a class="header" href="#a-tale-of-two-depgraphs-the-old-and-the-new" id="a-tale-of-two-depgraphs-the-old-and-the-new">A Tale Of Two DepGraphs: The Old And The New</a></h3>
<p>The initial description of dependency tracking glosses over a few details
that quickly become a head scratcher when actually trying to implement things.
In particular it's easy to overlook that we are actually dealing with <em>two</em>
dependency graphs: The one we built during the previous compilation session and
the one that we are building for the current compilation session.</p>
<p>When a compilation session starts, the compiler loads the previous dependency
graph into memory as an immutable piece of data. Then, when a query is invoked,
it will first try to mark the corresponding node in the graph as green. This
means really that we are trying to mark the node in the <em>previous</em> dep-graph
as green that corresponds to the query key in the <em>current</em> session. How do we
do this mapping between current query key and previous <code>DepNode</code>? The answer
is again <code>Fingerprint</code>s: Nodes in the dependency graph are identified by a
fingerprint of the query key. Since fingerprints are stable across compilation
sessions, computing one in the current session allows us to find a node
in the dependency graph from the previous session. If we don't find a node with
the given fingerprint, it means that the query key refers to something that
did not yet exist in the previous session.</p>
<p>So, having found the dep-node in the previous dependency graph, we can look
up its dependencies (i.e. also dep-nodes in the previous graph) and continue with
the rest of the try-mark-green algorithm. The next interesting thing happens
when we successfully marked the node as green. At that point we copy the node
and the edges to its dependencies from the old graph into the new graph. We
have to do this because the new dep-graph cannot not acquire the
node and edges via the regular dependency tracking. The tracking system can
only record edges while actually running a query -- but running the query,
although we have the result already cached, is exactly what we want to avoid.</p>
<p>Once the compilation session has finished, all the unchanged parts have been
copied over from the old into the new dependency graph, while the changed parts
have been added to the new graph by the tracking system. At this point, the
new graph is serialized out to disk, alongside the query result cache, and can
act as the previous dep-graph in a subsequent compilation session.</p>
<h3><a class="header" href="#didnt-you-forget-something-cache-promotion" id="didnt-you-forget-something-cache-promotion">Didn't You Forget Something?: Cache Promotion</a></h3>
<p>The system described so far has a somewhat subtle property: If all inputs of a
dep-node are green then the dep-node itself can be marked as green without
computing or loading the corresponding query result. Applying this property
transitively often leads to the situation that some intermediate results are
never actually loaded from disk, as in the following example:</p>
<pre><code class="language-ignore">   input(A) &lt;-- intermediate_query(B) &lt;-- leaf_query(C)
</code></pre>
<p>The compiler might need the value of <code>leaf_query(C)</code> in order to generate some
output artifact. If it can mark <code>leaf_query(C)</code> as green, it will load the
result from the on-disk cache. The result of <code>intermediate_query(B)</code> is never
loaded though. As a consequence, when the compiler persists the <em>new</em> result
cache by writing all in-memory query results to disk, <code>intermediate_query(B)</code>
will not be in memory and thus will be missing from the new result cache.</p>
<p>If there subsequently is another compilation session that actually needs the
result of <code>intermediate_query(B)</code> it will have to be re-computed even though we
had a perfectly valid result for it in the cache just before.</p>
<p>In order to prevent this from happening, the compiler does something called
&quot;cache promotion&quot;: Before emitting the new result cache it will walk all green
dep-nodes and make sure that their query result is loaded into memory. That way
the result cache doesn't unnecessarily shrink again.</p>
<h1><a class="header" href="#incremental-compilation-and-the-compiler-backend" id="incremental-compilation-and-the-compiler-backend">Incremental Compilation and the Compiler Backend</a></h1>
<p>The compiler backend, the part involving LLVM, is using the query system but
it is not implemented in terms of queries itself. As a consequence
it does not automatically partake in dependency tracking. However, the manual
integration with the tracking system is pretty straight-forward. The compiler
simply tracks what queries get invoked when generating the initial LLVM version
of each codegen unit, which results in a dep-node for each of them. In
subsequent compilation sessions it then tries to mark the dep-node for a CGU as
green. If it succeeds it knows that the corresponding object and bitcode files
on disk are still valid. If it doesn't succeed, the entire codegen unit has to
be recompiled.</p>
<p>This is the same approach that is used for regular queries. The main differences
are:</p>
<ul>
<li>
<p>that we cannot easily compute a fingerprint for LLVM modules (because
they are opaque C++ objects),</p>
</li>
<li>
<p>that the logic for dealing with cached values is rather different from
regular queries because here we have bitcode and object files instead of
serialized Rust values in the common result cache file, and</p>
</li>
<li>
<p>the operations around LLVM are so expensive in terms of computation time and
memory consumption that we need to have tight control over what is
executed when and what stays in memory for how long.</p>
</li>
</ul>
<p>The query system could probably be extended with general purpose mechanisms to
deal with all of the above but so far that seemed like more trouble than it
would save.</p>
<h2><a class="header" href="#query-modifiers" id="query-modifiers">Query Modifiers</a></h2>
<p>The query system allows for applying <a href="queries/../query.html#adding-a-new-kind-of-query">modifiers</a> to queries. These
modifiers affect certain aspects of how the system treats the query with
respect to incremental compilation:</p>
<ul>
<li>
<p><code>eval_always</code> - A query with the <code>eval_always</code> attribute is re-executed
unconditionally during incremental compilation. I.e. the system will not
even try to mark the query's dep-node as green. This attribute has two use
cases:</p>
<ul>
<li>
<p><code>eval_always</code> queries can read inputs (from files, global state, etc).
They can also produce side effects like writing to files and changing global state.</p>
</li>
<li>
<p>Some queries are very likely to be re-evaluated because their result
depends on the entire source code. In this case <code>eval_always</code> can be used
as an optimization because the system can skip recording dependencies in
the first place.</p>
</li>
</ul>
</li>
<li>
<p><code>no_hash</code> - Applying <code>no_hash</code> to a query tells the system to not compute
the fingerprint of the query's result. This has two consequences:</p>
<ul>
<li>
<p>Not computing the fingerprint can save quite a bit of time because
fingerprinting is expensive, especially for large, complex values.</p>
</li>
<li>
<p>Without the fingerprint, the system has to unconditionally assume that
the result of the query has changed. As a consequence anything depending
on a <code>no_hash</code> query will always be re-executed.</p>
</li>
</ul>
</li>
<li>
<p><code>cache_on_disk_if</code> - This attribute is what determines which query results
are persisted in the incremental compilation query result cache. The
attribute takes an expression that allows per query invocation
decisions. For example, it makes no sense to store values from upstream
crates in the cache because they are already available in the upstream
crate's metadata.</p>
</li>
<li>
<p><code>anon</code> - This attribute makes the system use &quot;anonymous&quot; dep-nodes for the
given query. An anonymous dep-node is not identified by the corresponding
query key, instead its ID is computed from the IDs of its dependencies. This
allows the red-green system to do its change detection even if there is no
query key available for a given dep-node -- something which is needed for
handling trait selection because it is not based on queries.</p>
</li>
</ul>
<h2><a class="header" href="#the-projection-query-pattern" id="the-projection-query-pattern">The Projection Query Pattern</a></h2>
<p>It's interesting to note that <code>eval_always</code> and <code>no_hash</code> can be used together
in the so-called &quot;projection query&quot; pattern. It is often the case that there is
one query that depends on the entirety of the compiler's input (e.g. the indexed HIR)
and another query that projects individual values out of this monolithic value
(e.g. a HIR item with a certain <code>DefId</code>). These projection queries allow for
building change propagation &quot;firewalls&quot; because even if the result of the
monolithic query changes (which it is very likely to do) the small projections
can still mostly be marked as green.</p>
<pre><code class="language-ignore">  +------------+
  |            |           +---------------+           +--------+
  |            | &lt;---------| projection(x) | &lt;---------| foo(a) |
  |            |           +---------------+           +--------+
  |            |
  | monolithic |           +---------------+           +--------+
  |   query    | &lt;---------| projection(y) | &lt;---------| bar(b) |
  |            |           +---------------+           +--------+
  |            |
  |            |           +---------------+           +--------+
  |            | &lt;---------| projection(z) | &lt;---------| baz(c) |
  |            |           +---------------+           +--------+
  +------------+
</code></pre>
<p>Let's assume that the result <code>monolithic_query</code> changes so that also the result
of <code>projection(x)</code> has changed, i.e. both their dep-nodes are being marked as
red. As a consequence <code>foo(a)</code> needs to be re-executed; but <code>bar(b)</code> and
<code>baz(c)</code> can be marked as green. However, if <code>foo</code>, <code>bar</code>, and <code>baz</code> would have
directly depended on <code>monolithic_query</code> then all of them would have had to be
re-evaluated.</p>
<p>This pattern works even without <code>eval_always</code> and <code>no_hash</code> but the two
modifiers can be used to avoid unnecessary overhead. If the monolithic query
is likely to change at any minor modification of the compiler's input it makes
sense to mark it as <code>eval_always</code>, thus getting rid of its dependency tracking
cost. And it always makes sense to mark the monolithic query as <code>no_hash</code>
because we have the projections to take care of keeping things green as much
as possible.</p>
<h1><a class="header" href="#shortcomings-of-the-current-system" id="shortcomings-of-the-current-system">Shortcomings of the Current System</a></h1>
<p>There are many things that still can be improved.</p>
<h2><a class="header" href="#incrementality-of-on-disk-data-structures" id="incrementality-of-on-disk-data-structures">Incrementality of on-disk data structures</a></h2>
<p>The current system is not able to update on-disk caches and the dependency graph
in-place. Instead it has to rewrite each file entirely in each compilation
session. The overhead of doing so is a few percent of total compilation time.</p>
<h2><a class="header" href="#unnecessary-data-dependencies" id="unnecessary-data-dependencies">Unnecessary data dependencies</a></h2>
<p>Data structures used as query results could be factored in a way that removes
edges from the dependency graph. Especially &quot;span&quot; information is very volatile,
so including it in query result will increase the chance that that result won't
be reusable. See https://github.com/rust-lang/rust/issues/47389 for more
information.</p>
<h1><a class="header" href="#debugging-and-testing-dependencies" id="debugging-and-testing-dependencies">Debugging and Testing Dependencies</a></h1>
<h2><a class="header" href="#testing-the-dependency-graph" id="testing-the-dependency-graph">Testing the dependency graph</a></h2>
<p>There are various ways to write tests against the dependency graph.
The simplest mechanisms are the <code>#[rustc_if_this_changed]</code> and
<code>#[rustc_then_this_would_need]</code> annotations. These are used in compile-fail
tests to test whether the expected set of paths exist in the dependency graph.
As an example, see <code>src/test/compile-fail/dep-graph-caller-callee.rs</code>.</p>
<p>The idea is that you can annotate a test like:</p>
<pre><code class="language-rust ignore">#[rustc_if_this_changed]
fn foo() { }

#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK
fn bar() { foo(); }

#[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path
fn baz() { }
</code></pre>
<p>This will check whether there is a path in the dependency graph from <code>Hir(foo)</code>
to <code>TypeckTables(bar)</code>. An error is reported for each
<code>#[rustc_then_this_would_need]</code> annotation that indicates whether a path
exists. <code>//~ ERROR</code> annotations can then be used to test if a path is found (as
demonstrated above).</p>
<h2><a class="header" href="#debugging-the-dependency-graph" id="debugging-the-dependency-graph">Debugging the dependency graph</a></h2>
<h3><a class="header" href="#dumping-the-graph" id="dumping-the-graph">Dumping the graph</a></h3>
<p>The compiler is also capable of dumping the dependency graph for your
debugging pleasure. To do so, pass the <code>-Z dump-dep-graph</code> flag. The
graph will be dumped to <code>dep_graph.{txt,dot}</code> in the current
directory.  You can override the filename with the <code>RUST_DEP_GRAPH</code>
environment variable.</p>
<p>Frequently, though, the full dep graph is quite overwhelming and not
particularly helpful. Therefore, the compiler also allows you to filter
the graph. You can filter in three ways:</p>
<ol>
<li>All edges originating in a particular set of nodes (usually a single node).</li>
<li>All edges reaching a particular set of nodes.</li>
<li>All edges that lie between given start and end nodes.</li>
</ol>
<p>To filter, use the <code>RUST_DEP_GRAPH_FILTER</code> environment variable, which should
look like one of the following:</p>
<pre><code class="language-text">source_filter     // nodes originating from source_filter
-&gt; target_filter  // nodes that can reach target_filter
source_filter -&gt; target_filter // nodes in between source_filter and target_filter
</code></pre>
<p><code>source_filter</code> and <code>target_filter</code> are a <code>&amp;</code>-separated list of strings.
A node is considered to match a filter if all of those strings appear in its
label. So, for example:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='-&gt; TypeckTables'
</code></pre>
<p>would select the predecessors of all <code>TypeckTables</code> nodes. Usually though you
want the <code>TypeckTables</code> node for some particular fn, so you might write:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='-&gt; TypeckTables &amp; bar'
</code></pre>
<p>This will select only the predecessors of <code>TypeckTables</code> nodes for functions
with <code>bar</code> in their name.</p>
<p>Perhaps you are finding that when you change <code>foo</code> you need to re-type-check
<code>bar</code>, but you don't think you should have to. In that case, you might do:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='Hir &amp; foo -&gt; TypeckTables &amp; bar'
</code></pre>
<p>This will dump out all the nodes that lead from <code>Hir(foo)</code> to
<code>TypeckTables(bar)</code>, from which you can (hopefully) see the source
of the erroneous edge.</p>
<h3><a class="header" href="#tracking-down-incorrect-edges" id="tracking-down-incorrect-edges">Tracking down incorrect edges</a></h3>
<p>Sometimes, after you dump the dependency graph, you will find some
path that should not exist, but you will not be quite sure how it came
to be. <strong>When the compiler is built with debug assertions,</strong> it can
help you track that down. Simply set the <code>RUST_FORBID_DEP_GRAPH_EDGE</code>
environment variable to a filter. Every edge created in the dep-graph
will be tested against that filter – if it matches, a <code>bug!</code> is
reported, so you can easily see the backtrace (<code>RUST_BACKTRACE=1</code>).</p>
<p>The syntax for these filters is the same as described in the previous
section. However, note that this filter is applied to every <strong>edge</strong>
and doesn't handle longer paths in the graph, unlike the previous
section.</p>
<p>Example:</p>
<p>You find that there is a path from the <code>Hir</code> of <code>foo</code> to the type
check of <code>bar</code> and you don't think there should be. You dump the
dep-graph as described in the previous section and open <code>dep-graph.txt</code>
to see something like:</p>
<pre><code class="language-text">Hir(foo) -&gt; Collect(bar)
Collect(bar) -&gt; TypeckTables(bar)
</code></pre>
<p>That first edge looks suspicious to you. So you set
<code>RUST_FORBID_DEP_GRAPH_EDGE</code> to <code>Hir&amp;foo -&gt; Collect&amp;bar</code>, re-run, and
then observe the backtrace. Voila, bug fixed!</p>
<h1><a class="header" href="#profiling-queries" id="profiling-queries">Profiling Queries</a></h1>
<p>In an effort to support <em>incremental compilation</em>, the latest design of the Rust
compiler consists of a <em>query-based</em> model.</p>
<p>The details of this model are (currently) outside the scope of this document,
however, we explain <a href="queries/profiling.html#background">some background of this model</a>, in an effort
to explain how we profile its performance. We intend this profiling effort to
address <a href="https://github.com/rust-lang/rust/issues/42678">issue 42678</a>.</p>
<h2><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h2>
<h3><a class="header" href="#0-enable-debug-assertions" id="0-enable-debug-assertions">0. Enable debug assertions</a></h3>
<pre><code>./configure --enable-debug-assertions
</code></pre>
<h3><a class="header" href="#1-compile-rustc" id="1-compile-rustc">1. Compile <code>rustc</code></a></h3>
<p>Compile the compiler, up to at least stage 1:</p>
<pre><code>python x.py --stage 1
</code></pre>
<h3><a class="header" href="#2-run-rustc-with-flags" id="2-run-rustc-with-flags">2. Run <code>rustc</code>, with flags</a></h3>
<p>Run the compiler on a source file, supplying two additional debugging flags with
<code>-Z</code>:</p>
<pre><code>rustc -Z profile-queries -Z incremental=cache foo.rs
</code></pre>
<p>Regarding the two additional parameters:</p>
<ul>
<li><code>-Z profile-queries</code> tells the compiler to run a separate thread that profiles
the queries made by the main compiler thread(s).</li>
<li><code>-Z incremental=cache</code> tells the compiler to &quot;cache&quot; various files that
describe the compilation dependencies, in the subdirectory <code>cache</code>.</li>
</ul>
<p>This command will generate the following files:</p>
<ul>
<li><code>profile_queries.html</code> consists of an HTML-based representation of the
<a href="queries/profiling.html#trace-of-queries">trace of queries</a>.</li>
<li><code>profile_queries.counts.txt</code> consists of a histogram, where each histogram
&quot;bucket&quot; is a query provider.</li>
</ul>
<h3><a class="header" href="#3-run-rustc-with--z-time-passes" id="3-run-rustc-with--z-time-passes">3. Run <code>rustc</code>, with <code>-Z time-passes</code>:</a></h3>
<ul>
<li>This additional flag will add all timed passes to the output files mentioned
above, in step 2. As described below, these passes appear visually distinct
from the queries in the HTML output (they currently appear as green boxes, via
CSS).</li>
</ul>
<h3><a class="header" href="#4-inspect-the-output" id="4-inspect-the-output">4. Inspect the output</a></h3>
<ul>
<li>4(a). Open the HTML file (<code>profile_queries.html</code>) with a browser. See
<a href="queries/profiling.html#interpret-the-html-output">this section</a> for an explanation of this file.</li>
<li>4(b). Open the data file (<code>profile_queries.counts.txt</code>) with a text editor, or
spreadsheet. See <a href="queries/profiling.html#interpret-the-data-output">this section</a> for an explanation
of this file.</li>
</ul>
<h2><a class="header" href="#interpret-the-html-output" id="interpret-the-html-output">Interpret the HTML Output</a></h2>
<h3><a class="header" href="#example-0" id="example-0">Example 0</a></h3>
<p>The following image gives some example output, from tracing the queries of
<code>hello_world.rs</code> (a single <code>main</code> function, that prints <code>&quot;hello world&quot;</code> via the
macro <code>println!</code>). This image only shows a short prefix of the total output; the
<em>actual</em> output is much longer.</p>
<p><a href="queries/./example-0.html"><img src="queries/./example-0.png" alt="Example HTML output" /></a>
<a href="queries/./example-0.html">View full HTML output</a>. Note; it could take up
to a second to properly render depending on your browser.</p>
<p>Here is the corresponding <a href="queries/./example-0.counts.txt">text output</a>.</p>
<h3><a class="header" href="#example-0-explanation" id="example-0-explanation">Example 0 explanation</a></h3>
<p>The trace of the queries has a formal structure; see
<a href="queries/profiling.html#trace-of-queries">Trace of Queries</a> for details.</p>
<p>We style this formal structure as follows:</p>
<ul>
<li><strong>Timed passes:</strong> Green boxes, when present (via <code>-Z time-passes</code>), represent
<em>timed passes</em> in the compiler. In future versions, these passes may be
replaced by queries, explained below.</li>
<li><strong>Labels:</strong> Some green and red boxes are labeled with text. Where they are
present, the labels give the following information:
<ul>
<li>The <a href="queries/profiling.html#queries">query's <em>provider</em></a>, sans its <em>key</em> and its <em>result</em>, which
are often too long to include in these labels.</li>
<li>The <em>duration</em> of the provider, as a fraction of the total time (for the
entire trace). This fraction includes the query's entire extent (that is,
the sum total of all of its sub-queries).</li>
</ul>
</li>
<li><strong>Query hits:</strong> Blue dots represent query hits. They consist of leaves in the
trace's tree. (CSS class: <code>hit</code>).</li>
<li><strong>Query misses:</strong> Red boxes represent query misses. They consist of internal
nodes in the trace's tree. (CSS class: <code>miss</code>).</li>
<li><strong>Nesting structure:</strong> Many red boxes contain <em>nested boxes and dots</em>. This
nesting structure reflects that some providers <em>depend on</em> results from other
providers, which consist of their nested children.</li>
<li>Some red boxes are <em>labeled</em> with text, and have highlighted borders (light
red, and bolded). (See <a href="queries/profiling.html#heuristics">heuristics</a> for details).</li>
</ul>
<h2><a class="header" href="#heuristics" id="heuristics">Heuristics</a></h2>
<p>Heuristics-based CSS Classes:</p>
<ul>
<li>
<p><code>important</code> -- Trace nodes are <code>important</code> if they have an extent of 6 (or
more), <em>or</em> they have a duration fraction of one percent (or more). These
numbers are simple heuristics (currently hard-coded, but easy to modify).
Important nodes are styled with textual labels, and highlighted borders (light
red, and bolded).</p>
</li>
<li>
<p><code>frac-50</code>, <code>-40</code>, ... -- Trace nodes whose total duration (self and children)
take a large fraction of the total duration, at or above 50%, 40%, and so on.
We style nodes these with larger font and padding.</p>
</li>
</ul>
<h2><a class="header" href="#interpret-the-data-output" id="interpret-the-data-output">Interpret the Data Output</a></h2>
<p>The file <code>profile_queries.counts.txt</code> contains a table of information about the
queries, organized around their providers.</p>
<p>For each provider (or timed pass, when <code>-Z time-passes</code> is present), we produce:</p>
<ul>
<li>
<p>A total <strong>count</strong> --- the total number of times this provider was queried</p>
</li>
<li>
<p>A total <strong>duration</strong> --- the total number of seconds spent running this
provider, <em>including</em> all providers it may depend on. To get a sense of this
dependency structure, and inspect a more fine-grained view of these durations,
see <a href="queries/profiling.html#interpret-the-html-output">this section</a>.</p>
</li>
</ul>
<p>These rows are <strong>sorted by total duration</strong>, in descending order.</p>
<h3><a class="header" href="#counts-example-0" id="counts-example-0">Counts: Example 0</a></h3>
<p>The following example <code>profile_queries.counts.txt</code> file results from running on
a hello world program (a single main function that uses <code>println</code> to print
`&quot;hellow world&quot;).</p>
<p>As explained above, the columns consist of <code>provider/pass</code>, <code>count</code>, <code>duration</code>:</p>
<pre><code>translation,1,0.891
symbol_name,2658,0.733
def_symbol_name,2556,0.268
item_attrs,5566,0.162
type_of,6922,0.117
generics_of,8020,0.084
serialize dep graph,1,0.079
relevant_trait_impls_for,50,0.063
def_span,24875,0.061
expansion,1,0.059
const checking,1,0.055
adt_def,1141,0.048
trait_impls_of,32,0.045
is_copy_raw,47,0.045
is_foreign_item,2638,0.042
fn_sig,2172,0.033
adt_dtorck_constraint,2,0.023
impl_trait_ref,2434,0.023
typeck_tables_of,29,0.022
item-bodies checking,1,0.017
typeck_item_bodies,1,0.017
is_default_impl,2320,0.017
borrow checking,1,0.014
borrowck,4,0.014
mir_validated,4,0.013
adt_destructor,10,0.012
layout_raw,258,0.010
load_dep_graph,1,0.007
item-types checking,1,0.005
mir_const,2,0.005
name resolution,1,0.004
is_object_safe,35,0.003
is_sized_raw,89,0.003
parsing,1,0.003
is_freeze_raw,11,0.001
privacy checking,1,0.001
privacy_access_levels,5,0.001
resolving dependency formats,1,0.001
adt_sized_constraint,9,0.001
wf checking,1,0.001
liveness checking,1,0.001
compute_incremental_hashes_map,1,0.001
match checking,1,0.001
type collecting,1,0.001
param_env,31,0.000
effect checking,1,0.000
trait_def,140,0.000
lowering ast -&gt; hir,1,0.000
predicates_of,70,0.000
extern_crate,319,0.000
lifetime resolution,1,0.000
is_const_fn,6,0.000
intrinsic checking,1,0.000
translation item collection,1,0.000
impl_polarity,15,0.000
creating allocators,1,0.000
language item collection,1,0.000
crate injection,1,0.000
early lint checks,1,0.000
indexing hir,1,0.000
maybe creating a macro crate,1,0.000
coherence checking,1,0.000
optimized_mir,6,0.000
is_panic_runtime,33,0.000
associated_item_def_ids,7,0.000
needs_drop_raw,10,0.000
lint checking,1,0.000
complete gated feature checking,1,0.000
stability index,1,0.000
region_maps,11,0.000
super_predicates_of,8,0.000
coherent_trait,2,0.000
AST validation,1,0.000
loop checking,1,0.000
static item recursion checking,1,0.000
variances_of,11,0.000
associated_item,5,0.000
plugin loading,1,0.000
looking for plugin registrar,1,0.000
stability checking,1,0.000
describe_def,15,0.000
variance testing,1,0.000
codegen unit partitioning,1,0.000
looking for entry point,1,0.000
checking for inline asm in case the target doesn't support it,1,0.000
inherent_impls,1,0.000
crate_inherent_impls,1,0.000
trait_of_item,7,0.000
crate_inherent_impls_overlap_check,1,0.000
attribute checking,1,0.000
internalize symbols,1,0.000
impl wf inference,1,0.000
death checking,1,0.000
reachability checking,1,0.000
reachable_set,1,0.000
is_exported_symbol,3,0.000
is_mir_available,2,0.000
unused lib feature checking,1,0.000
maybe building test harness,1,0.000
recursion limit,1,0.000
write allocator module,1,0.000
assert dep graph,1,0.000
plugin registration,1,0.000
write metadata,1,0.000
</code></pre>
<h1><a class="header" href="#background" id="background">Background</a></h1>
<p>We give some background about the query model of the Rust compiler.</p>
<h2><a class="header" href="#def-ids" id="def-ids">Def IDs</a></h2>
<p>In the query model, many queries have a key that consists of a Def ID. The Rust
compiler uses Def IDs to distinguish definitions in the input Rust program.</p>
<p>From the compiler source code (<code>src/librustc_middle/hir/def_id.rs</code>):</p>
<pre><code>/// A DefId identifies a particular *definition*, by combining a crate
/// index and a def index.
#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]
pub struct DefId {
    pub krate: CrateNum,
    pub index: DefIndex,
}
</code></pre>
<h2><a class="header" href="#queries-1" id="queries-1">Queries</a></h2>
<p>A query relates a <em>key</em> to a <em>result</em>, either by invoking a <em>provider</em> that
computes this result, or by reusing a cached result that was provided earlier.
We explain each term in more detail:</p>
<ul>
<li>Query <strong>Provider</strong>: Each kind of query has a pre-defined <em>provider</em>, which
refers to the compiler behavior that provides an answer to the query. These
providers may nest; see <a href="queries/profiling.html#trace-of-queries">trace of queries</a> for more
information about this nesting structure.
<em>Example providers:</em>
<ul>
<li><code>typeck_tables_of</code> -- Typecheck a Def ID; produce &quot;tables&quot; of type
information.</li>
<li><code>borrowck</code> -- Borrow-check a Def ID.</li>
<li><code>optimized_mir</code> -- Generate an optimized MIR for a Def ID; produce MIR.</li>
<li>For more examples, see <a href="queries/profiling.html#counts-example-0">Example 0</a>.</li>
</ul>
</li>
<li>Query <strong>Key</strong>: The input/arguments to the provider. Often, this consists of a
particular <a href="queries/profiling.html#def-ids">Def ID</a>.</li>
<li>Query <strong>Result</strong>: The output of the provider.</li>
</ul>
<h2><a class="header" href="#trace-of-queries" id="trace-of-queries">Trace of Queries</a></h2>
<p>Formally, a <em>trace</em> of the queries consists of a <em>tree</em>, where sub-trees
represent sub-traces. In particular, the nesting structure of the trace of
queries describes how the queries depend on one another.</p>
<p>Even more precisely, this tree represents a directed acyclic graph (DAG), where
shared sub-graphs consist of tree nodes that occur multiple times in the tree,
first as &quot;cache misses&quot; and later as &quot;cache hits&quot;.</p>
<p><strong>Cache hits and misses.</strong> The trace is a tree with the following possible tree
nodes:</p>
<ul>
<li>Query, with cache <strong>miss</strong>: The query's result is <strong>unknown</strong>, and its
provider runs to compute it. In this case, the dynamic extent of the query's
trace consists of the traced behavior of its provider.</li>
<li>Query, with cache <strong>hit</strong>: The query's result is <strong>known</strong>, and is reused; its
provider does not rerun. These nodes are leaves in the trace, since they have
no dynamic extent. These leaves also represent where the tree, represented as
a DAG, would <em>share</em> a sub-graph (namely, the sub-graph of the query that was
reused from the cache).</li>
</ul>
<p><strong>Tree node metrics.</strong> To help determine how to style this tree, we define the
following tree node metrics:</p>
<ul>
<li><strong>Depth</strong>: The number of <strong>ancestors</strong> of the node in its path from the tree
root.</li>
<li><strong>Extent</strong>: The number of <strong>immediate children</strong> of the node.</li>
</ul>
<p>Intuitively, a dependency tree is &quot;good&quot; for incremental caching when the depth
and extent of each node is relatively small. It is pathological when either of
these metrics grows too large. For instance, a tree node whose extent consists
of 1M immediate children means that if and when this node is re-computed, all 1M
children must be re-queried, at the very least (some may also require
recomputation, too).</p>
<h2><a class="header" href="#external-links" id="external-links">External Links</a></h2>
<p>Related design ideas, and tracking issues:</p>
<ul>
<li>Design document:
<a href="https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md">On-demand Rustc incremental design doc</a></li>
<li>Tracking Issue:
<a href="https://github.com/rust-lang/rust/issues/42293">&quot;Red/Green&quot; dependency tracking in compiler</a></li>
</ul>
<p>More discussion and issues:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/42633">GitHub issue #42633</a></li>
<li><a href="https://internals.rust-lang.org/t/incremental-compilation-beta/4721">Incremental Compilation Beta</a></li>
<li><a href="https://blog.rust-lang.org/2016/09/08/incremental.html">Incremental Compilation Announcement</a></li>
</ul>
<h1><a class="header" href="#how-salsa-works" id="how-salsa-works">How Salsa works</a></h1>
<p>This chapter is based on the explanation given by Niko Matsakis in this
<a href="https://www.youtube.com/watch?v=_muY4HjSqVw">video</a> about
<a href="https://github.com/salsa-rs/salsa">Salsa</a>.</p>
<blockquote>
<p>Salsa is not used directly in rustc, but it is used extensively for
rust-analyzer and may be integrated into the compiler in the future.</p>
</blockquote>
<h2><a class="header" href="#what-is-salsa" id="what-is-salsa">What is Salsa?</a></h2>
<p>Salsa is a library for incremental recomputation. This means it allows reusing
computations that were already done in the past to increase the efficiency
of future computations.</p>
<p>The objectives of Salsa are:</p>
<ul>
<li>Provide that functionality in an automatic way, so reusing old computations
is done automatically by the library</li>
<li>Doing so in a &quot;sound&quot;, or &quot;correct&quot;, way, therefore leading to the same
results as if it had been done from scratch</li>
</ul>
<p>Salsa's actual model is much richer, allowing many kinds of inputs and many
different outputs.
For example, integrating Salsa with an IDE could mean that the inputs could be
the manifest (<code>Cargo.toml</code>), entire source files (<code>foo.rs</code>), snippets and so
on; the outputs of such an integration could range from a binary executable, to
lints, types (for example, if a user selects a certain variable and wishes to
see its type), completions, etc.</p>
<h2><a class="header" href="#how-does-it-work" id="how-does-it-work">How does it work?</a></h2>
<p>The first thing that Salsa has to do is identify the &quot;base inputs&quot; <sup class="footnote-reference"><a href="#EN1">1</a></sup>.</p>
<p>Then Salsa has to also identify intermediate, &quot;derived&quot; values, which are
something that the library produces, but, for each derived value there's a
&quot;pure&quot; function that computes the derived value.</p>
<p>For example, there might be a function <code>ast(x: Path) -&gt; AST</code>. The produced
<code>AST</code> isn't a final value, it's an intermidiate value that the library would
use for the computation.</p>
<p>This means that when you try to compute with the library, Salsa is going to
compute various derived values, and eventually read the input and produce the
result for the asked computation.</p>
<p>In the course of computing, Salsa tracks which inputs were accessed and which
values are derived. This information is used to determine what's going to
happen when the inputs change: are the derived values still valid?</p>
<p>This doesn't necessarily mean that each computation downstream from the input
is going to be checked, which could be costly. Salsa only needs to check each
downstream computation until it finds one that isn't changed. At that point, it
won't check other derived computations since they wouldn't need to change.</p>
<p>It's is helpful to think about this as a graph with nodes. Each derived value
has a dependency on other values, which could themselves be either base or
derived. Base values don't have a dependency.</p>
<pre><code class="language-ignore">I &lt;- A &lt;- C ...
          |
J &lt;- B &lt;--+
</code></pre>
<p>When an input <code>I</code> changes, the derived value <code>A</code> could change. The derived
value <code>B</code> , which does not depend on <code>I</code>, <code>A</code>, or any value derived from <code>A</code> or
<code>I</code>, is not subject to change.  Therefore, Salsa can reuse the computation done
for <code>B</code> in the past, without having to compute it again.</p>
<p>The computation could also terminate early. Keeping the same graph as before,
say that input <code>I</code> has changed in some way (and input <code>J</code> hasn't) but, when
computing <code>A</code> again, it's found that <code>A</code> hasn't changed from the previous
computation. This leads to an &quot;early termination&quot;, because there's no need to
check if <code>C</code> needs to change, since both <code>C</code> direct inputs, <code>A</code> and <code>B</code>,
haven't changed.</p>
<h2><a class="header" href="#key-salsa-concepts" id="key-salsa-concepts">Key Salsa concepts</a></h2>
<h3><a class="header" href="#query" id="query">Query</a></h3>
<p>A query is some value that Salsa can access in the course of computation.  Each
query can have a number of keys (from 0 to many), and all queries have a
result, akin to functions.  0-key queries are called &quot;input&quot; queries.</p>
<h3><a class="header" href="#database" id="database">Database</a></h3>
<p>The database is basically the context for the entire computation, it's meant to
store Salsa's internal state, all intermediate values for each query, and
anything else that the computation might need.  The database must know all the
queries that the library is going to do before it can be built, but they don't
need to be specified in the same place.</p>
<p>After the database is formed, it can be accessed with queries that are very
similar to functions.  Since each query's result is stored in the database,
when a query is invoked N times, it will return N <strong>cloned</strong> results, without
having to recompute the query (unless the input has changed in such a way that
it warrants recomputation).</p>
<p>For each input query (0-key), a &quot;set&quot; method is generated, allowing the user to
change the output of such query, and trigger previous memoized values to be
potentially invalidated.</p>
<h3><a class="header" href="#query-groups" id="query-groups">Query Groups</a></h3>
<p>A query group is a set of queries which have been defined together as a unit.
The database is formed by combining query groups.  Query groups are akin to
&quot;Salsa modules&quot; <sup class="footnote-reference"><a href="#EN2">2</a></sup>.</p>
<p>A set of queries in a query group are just a set of methods in a trait.</p>
<p>To create a query group a trait annotated with a specific attribute
(<code>#[salsa::query_group(...)]</code>) has to be created.</p>
<p>An argument must also be provided to said attribute as it will be used by Salsa
to create a struct to be used later when the database is created.</p>
<p>Example input query group:</p>
<pre><code class="language-rust ignore">/// This attribute will process this tree, produce this tree as output, and produce
/// a bunch of intermidiate stuff that Salsa also uses.  One of these things is a
/// &quot;StorageStruct&quot;, whose name we have specified in the attribute.
///
/// This query group is a bunch of **input** queries, that do not rely on any
/// derived input.
#[salsa::query_group(InputsStorage)]
pub trait Inputs {
    /// This attribute (`#[salsa::input]`) indicates that this query is a base
    /// input, therefore `set_manifest` is going to be auto-generated
    #[salsa::input]
    fn manifest(&amp;self) -&gt; Manifest;

    #[salsa::input]
    fn source_text(&amp;self, name: String) -&gt; String;
}
</code></pre>
<p>To create a <strong>derived</strong> query group, one must specify which other query groups
this one depends on by specifying them as supertraits, as seen in the following
example:</p>
<pre><code class="language-rust ignore">/// This query group is going to contain queries that depend on derived values a
/// query group can access another query group's queries by specifying the
/// dependency as a super trait query groups can be stacked as much as needed using
/// that pattern.
#[salsa::query_group(ParserStorage)]
pub trait Parser: Inputs {
    /// This query `ast` is not an input query, it's a derived query this means
    /// that a definition is necessary.
    fn ast(&amp;self, name: String) -&gt; String;
}
</code></pre>
<p>When creating a derived query the implementation of said query must be defined
outside the trait.  The definition must take a database parameter as an <code>impl Trait</code> (or <code>dyn Trait</code>), where <code>Trait</code> is the query group that the definition
belongs to, in addition to the other keys.</p>
<pre><code class="language-rust ignore">///This is going to be the definition of the `ast` query in the `Parser` trait.
///So, when the query `ast` is invoked, and it needs to be recomputed, Salsa is going to call this function
///and it's is going to give it the database as `impl Parser`.
///The function doesn't need to be aware of all the queries of all the query groups
fn ast(db: &amp;impl Parser, name: String) -&gt; String {
    //! Note, `impl Parser` is used here but `dyn Parser` works just as well
    /* code */
    ///By passing an `impl Parser`, this is allowed
    let source_text = db.input_file(name);
    /* do the actual parsing */
    return ast;
}
</code></pre>
<p>Eventually, after all the query groups have been defined, the database can be
created by declaring a struct.</p>
<p>To specify which query groups are going to be part of the database an attribute
(<code>#[salsa::database(...)]</code>) must be added. The argument of said attribute is a
list of identifiers, specifying the query groups <strong>storages</strong>.</p>
<pre><code class="language-rust ignore">///This attribute specifies which query groups are going to be in the database
#[salsa::database(InputsStorage, ParserStorage)]
#[derive(Default)] //optional!
struct MyDatabase {
    ///You also need this one field
    runtime : salsa::Runtime&lt;MyDatabase&gt;,
}
///And this trait has to be implemented
impl salsa::Databse for MyDatabase {
    fn salsa_runtime(&amp;self) -&gt; &amp;salsa::Runtime&lt;MyDatabase&gt; {
        &amp;self.runtime
    }
}
</code></pre>
<p>Example usage:</p>
<pre><code class="language-rust ignore">fn main() {
    let db = MyDatabase::default();
    db.set_manifest(...);
    db.set_source_text(...);
    loop {
        db.ast(...); //will reuse results
        db.set_source_text(...);
    }
}
</code></pre>
<div class="footnote-definition" id="EN1"><sup class="footnote-definition-label">1</sup>
<p>&quot;They are not something that you <strong>inaubible</strong> but something that you kinda get <strong>inaudible</strong> from the outside <a href="https://youtu.be/_muY4HjSqVw?t=203">3:23</a>.</p>
</div>
<div class="footnote-definition" id="EN2"><sup class="footnote-definition-label">2</sup>
<p>What is a Salsa module?</p>
</div>
<h1><a class="header" href="#memory-management-in-rustc" id="memory-management-in-rustc">Memory Management in Rustc</a></h1>
<p>Rustc tries to be pretty careful how it manages memory. The compiler allocates
<em>a lot</em> of data structures throughout compilation, and if we are not careful,
it will take a lot of time and space to do so.</p>
<p>One of the main way the compiler manages this is using arenas and interning.</p>
<h2><a class="header" href="#arenas-and--interning" id="arenas-and--interning">Arenas and  Interning</a></h2>
<p>We create a LOT of data structures during compilation. For performance reasons,
we allocate them from a global memory pool; they are each allocated once from a
long-lived <em>arena</em>. This is called <em>arena allocation</em>. This system reduces
allocations/deallocations of memory. It also allows for easy comparison of
types for equality: for each interned type <code>X</code>, we implemented <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html#implementations"><code>PartialEq for X</code></a>, so we can just compare pointers. The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.CtxtInterners.html#structfield.arena"><code>CtxtInterners</code></a> type
contains a bunch of maps of interned types and the arena itself.</p>
<h3><a class="header" href="#example-tytys" id="example-tytys">Example: <code>ty::TyS</code></a></h3>
<p>Taking the example of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html"><code>ty::TyS</code></a> which represents a type in the compiler (you
can read more <a href="./ty.html">here</a>).  Each time we want to construct a type, the
compiler doesn’t naively allocate from the buffer.  Instead, we check if that
type was already constructed. If it was, we just get the same pointer we had
before, otherwise we make a fresh pointer. With this schema if we want to know
if two types are the same, all we need to do is compare the pointers which is
efficient. <code>TyS</code> is carefully setup so you never construct them on the stack.
You always allocate them from this arena and you always intern them so they are
unique.</p>
<p>At the beginning of the compilation we make a buffer and each time we need to allocate a type we use
some of this memory buffer. If we run out of space we get another one. The lifetime of that buffer
is <code>'tcx</code>. Our types are tied to that lifetime, so when compilation finishes all the memory related
to that buffer is freed and our <code>'tcx</code> references would be invalid.</p>
<p>In addition to types, there are a number of other arena-allocated data structures that you can
allocate, and which are found in this module. Here are a few examples:</p>
<ul>
<li><a href="./generic_arguments.html#subst"><code>Substs</code></a>, allocated with <code>mk_substs</code> – this will intern a slice of types, often used to
specify the values to be substituted for generics (e.g. <code>HashMap&lt;i32, u32&gt;</code> would be represented
as a slice <code>&amp;'tcx [tcx.types.i32, tcx.types.u32]</code>).</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TraitRef.html"><code>TraitRef</code></a>, typically passed by value – a <strong>trait reference</strong> consists of a reference to a trait
along with its various type parameters (including <code>Self</code>), like <code>i32: Display</code> (here, the def-id
would reference the <code>Display</code> trait, and the substs would contain <code>i32</code>). Note that <code>def-id</code> is
defined and discussed in depth in the <code>AdtDef and DefId</code> section.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.Predicate.html"><code>Predicate</code></a> defines something the trait system has to prove (see <code>traits</code> module).</li>
</ul>
<h2><a class="header" href="#the-tcx-and-how-it-uses-lifetimes" id="the-tcx-and-how-it-uses-lifetimes">The tcx and how it uses lifetimes</a></h2>
<p>The <code>tcx</code> (&quot;typing context&quot;) is the central data structure in the compiler. It is the context that
you use to perform all manner of queries. The struct <code>TyCtxt</code> defines a reference to this shared
context:</p>
<pre><code class="language-rust ignore">tcx: TyCtxt&lt;'tcx&gt;
//          ----
//          |
//          arena lifetime
</code></pre>
<p>As you can see, the <code>TyCtxt</code> type takes a lifetime parameter. When you see a reference with a
lifetime like <code>'tcx</code>, you know that it refers to arena-allocated data (or data that lives as long as
the arenas, anyhow).</p>
<h3><a class="header" href="#a-note-on-lifetimes" id="a-note-on-lifetimes">A Note On Lifetimes</a></h3>
<p>The Rust compiler is a fairly large program containing lots of big data
structures (e.g. the AST, HIR, and the type system) and as such, arenas and
references are heavily relied upon to minimize unnecessary memory use. This
manifests itself in the way people can plug into the compiler (i.e. the
<a href="./rustc-driver.html">driver</a>), preferring a &quot;push&quot;-style API (callbacks) instead
of the more Rust-ic &quot;pull&quot; style (think the <code>Iterator</code> trait).</p>
<p>Thread-local storage and interning are used a lot through the compiler to reduce
duplication while also preventing a lot of the ergonomic issues due to many
pervasive lifetimes. The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/tls/index.html"><code>rustc::ty::tls</code></a> module is used to access these
thread-locals, although you should rarely need to touch it.</p>
<h1><a class="header" href="#parallel-compilation" id="parallel-compilation">Parallel Compilation</a></h1>
<p>Most of the compiler is not parallel. This represents an opportunity for
improving compiler performance. Much effort has been put into parallelizing
<code>rustc</code>, but it is still pretty early days for this work. There is a lot of
design and correctness work that needs to be done.</p>
<p>One can try out the current parallel compiler work by enabling it in the
<code>config.toml</code>.</p>
<p>There are a few basic ideas in this effort:</p>
<ul>
<li>There are a lot of loops in the compiler that just iterate over all items in
a crate. These can possibly be parallelized.</li>
<li>We can use (a custom fork of) <a href="https://crates.io/rayon"><code>rayon</code></a> to run tasks in parallel. The custom
fork allows the execution of DAGs of tasks, not just trees.</li>
<li>There are currently a lot of global data structures that need to be made
thread-safe. A key strategy here has been converting interior-mutable
data-structures (e.g. <code>Cell</code>) into their thread-safe siblings (e.g. <code>Mutex</code>).</li>
</ul>
<p>As of this writing, much of this effort is on hold due to lack of manpower. We
have a working prototype with promising performance gains in many cases.
However, there are two blockers:</p>
<ul>
<li>
<p>It's not clear what invariants need to be upheld that might not hold in the
face of concurrency. An auditing effort was underway, but seems to have
stalled at some point.</p>
</li>
<li>
<p>There is a lot of lock contention, which actually degrades performance as the
number of threads increases beyond 4.</p>
</li>
</ul>
<p>Here are some resources that can be used to learn more (note that some of them
are a bit out of date):</p>
<ul>
<li><a href="https://internals.rust-lang.org/t/parallelizing-rustc-using-rayon/6606">This IRLO thread by Zoxc, one of the pioneers of the effort</a></li>
<li><a href="https://github.com/nikomatsakis/rustc-parallelization/blob/master/interior-mutability-list.md">This list of interior mutability in the compiler by nikomatsakis</a></li>
<li><a href="https://internals.rust-lang.org/t/help-test-parallel-rustc/11503">This IRLO thread by alexchricton about performance</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/48685">This tracking issue</a></li>
</ul>
<h1><a class="header" href="#part-3-source-code-representations" id="part-3-source-code-representations">Part 3: Source Code Representations</a></h1>
<p>This part describes the process of taking raw source code from the user and
transforming it into various forms that the compiler can work with easily.
These are called <em>intermediate representations (IRs)</em>.</p>
<p>This process starts with compiler understanding what the user has asked for:
parsing the command line arguments given and determining what it is to compile.
After that, the compiler transforms the user input into a series of IRs that
look progressively less like what the user wrote.</p>
<h1><a class="header" href="#the-rustc-driver-and-interface" id="the-rustc-driver-and-interface">The Rustc Driver and Interface</a></h1>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/"><code>rustc_driver</code></a> is essentially <code>rustc</code>'s <code>main()</code> function. It acts as
the glue for running the various phases of the compiler in the correct order,
using the interface defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/index.html"><code>rustc_interface</code></a> crate.</p>
<p>The <code>rustc_interface</code> crate provides external users with an (unstable) API
for running code at particular times during the compilation process, allowing
third parties to effectively use <code>rustc</code>'s internals as a library for
analysing a crate or emulating the compiler in-process (e.g. the RLS or rustdoc).</p>
<p>For those using <code>rustc</code> as a library, the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/fn.run_compiler.html"><code>rustc_interface::run_compiler()</code></a>
function is the main entrypoint to the compiler. It takes a configuration for the compiler
and a closure that takes a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Compiler.html"><code>Compiler</code></a>. <code>run_compiler</code> creates a <code>Compiler</code> from the
configuration and passes it to the closure. Inside the closure, you can use the <code>Compiler</code>
to drive queries to compile a crate and get the results. This is what the <code>rustc_driver</code> does too.
You can see a minimal example of how to use <code>rustc_interface</code> <a href="https://github.com/rust-lang/rustc-dev-guide/blob/master/examples/rustc-driver-example.rs">here</a>.</p>
<p>You can see what queries are currently available through the rustdocs for <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Compiler.html"><code>Compiler</code></a>.
You can see an example of how to use them by looking at the <code>rustc_driver</code> implementation,
specifically the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/fn.run_compiler.html"><code>rustc_driver::run_compiler</code> function</a> (not to be confused with
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/fn.run_compiler.html"><code>rustc_interface::run_compiler</code></a>). The <code>rustc_driver::run_compiler</code> function
takes a bunch of command-line args and some other configurations and
drives the compilation to completion.</p>
<p><code>rustc_driver::run_compiler</code> also takes a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a>,
a trait that allows for custom compiler configuration,
as well as allowing some custom code run after different phases of the compilation.</p>
<blockquote>
<p><strong>Warning:</strong> By its very nature, the internal compiler APIs are always going
to be unstable. That said, we do try not to break things unnecessarily.</p>
</blockquote>
<h1><a class="header" href="#the-walking-tour-of-rustdoc" id="the-walking-tour-of-rustdoc">The walking tour of rustdoc</a></h1>
<p>Rustdoc actually uses the rustc internals directly. It lives in-tree with the
compiler and standard library. This chapter is about how it works.</p>
<p>Rustdoc is implemented entirely within the crate <a href="https://github.com/rust-lang/rust/tree/master/src/librustdoc"><code>librustdoc</code></a>. It runs
the compiler up to the point where we have an internal representation of a
crate (HIR) and the ability to run some queries about the types of items. <a href="./hir.html">HIR</a>
and <a href="./query.html">queries</a> are discussed in the linked chapters.</p>
<p><code>librustdoc</code> performs two major steps after that to render a set of
documentation:</p>
<ul>
<li>&quot;Clean&quot; the AST into a form that's more suited to creating documentation (and
slightly more resistant to churn in the compiler).</li>
<li>Use this cleaned AST to render a crate's documentation, one page at a time.</li>
</ul>
<p>Naturally, there's more than just this, and those descriptions simplify out
lots of details, but that's the high-level overview.</p>
<p>(Side note: <code>librustdoc</code> is a library crate! The <code>rustdoc</code> binary is created
using the project in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/rustdoc"><code>src/tools/rustdoc</code></a>. Note that literally all that
does is call the <code>main()</code> that's in this crate's <code>lib.rs</code>, though.)</p>
<h2><a class="header" href="#cheat-sheet" id="cheat-sheet">Cheat sheet</a></h2>
<ul>
<li>Use <code>./x.py build --stage 1 src/libstd src/tools/rustdoc</code> to make a usable
rustdoc you can run on other projects.
<ul>
<li>Add <code>src/libtest</code> to be able to use <code>rustdoc --test</code>.</li>
<li>If you've used <code>rustup toolchain link local /path/to/build/$TARGET/stage1</code>
previously, then after the previous build command, <code>cargo +local doc</code> will
Just Work.</li>
</ul>
</li>
<li>Use <code>./x.py doc --stage 1 src/libstd</code> to use this rustdoc to generate the
standard library docs.
<ul>
<li>The completed docs will be available in <code>build/$TARGET/doc/std</code>, though the
bundle is meant to be used as though you would copy out the <code>doc</code> folder to
a web server, since that's where the CSS/JS and landing page are.</li>
</ul>
</li>
<li>Most of the HTML printing code is in <code>html/format.rs</code> and <code>html/render.rs</code>.
It's in a bunch of <code>fmt::Display</code> implementations and supplementary
functions.</li>
<li>The types that got <code>Display</code> impls above are defined in <code>clean/mod.rs</code>, right
next to the custom <code>Clean</code> trait used to process them out of the rustc HIR.</li>
<li>The bits specific to using rustdoc as a test harness are in <code>test.rs</code>.</li>
<li>The Markdown renderer is loaded up in <code>html/markdown.rs</code>, including functions
for extracting doctests from a given block of Markdown.</li>
<li>The tests on rustdoc <em>output</em> are located in <code>src/test/rustdoc</code>, where
they're handled by the test runner of rustbuild and the supplementary script
<code>src/etc/htmldocck.py</code>.</li>
<li>Tests on search index generation are located in <code>src/test/rustdoc-js</code>, as a
series of JavaScript files that encode queries on the standard library search
index and expected results.</li>
</ul>
<h2><a class="header" href="#from-crate-to-clean" id="from-crate-to-clean">From crate to clean</a></h2>
<p>In <code>core.rs</code> are two central items: the <code>DocContext</code> struct, and the <code>run_core</code>
function. The latter is where rustdoc calls out to rustc to compile a crate to
the point where rustdoc can take over. The former is a state container used
when crawling through a crate to gather its documentation.</p>
<p>The main process of crate crawling is done in <code>clean/mod.rs</code> through several
implementations of the <code>Clean</code> trait defined within. This is a conversion
trait, which defines one method:</p>
<pre><code class="language-rust ignore">pub trait Clean&lt;T&gt; {
    fn clean(&amp;self, cx: &amp;DocContext) -&gt; T;
}
</code></pre>
<p><code>clean/mod.rs</code> also defines the types for the &quot;cleaned&quot; AST used later on to
render documentation pages. Each usually accompanies an implementation of
<code>Clean</code> that takes some AST or HIR type from rustc and converts it into the
appropriate &quot;cleaned&quot; type. &quot;Big&quot; items like modules or associated items may
have some extra processing in its <code>Clean</code> implementation, but for the most part
these impls are straightforward conversions. The &quot;entry point&quot; to this module
is the <code>impl Clean&lt;Crate&gt; for visit_ast::RustdocVisitor</code>, which is called by
<code>run_core</code> above.</p>
<p>You see, I actually lied a little earlier: There's another AST transformation
that happens before the events in <code>clean/mod.rs</code>.  In <code>visit_ast.rs</code> is the
type <code>RustdocVisitor</code>, which <em>actually</em> crawls a <code>rustc_hir::Crate</code> to get the first
intermediate representation, defined in <code>doctree.rs</code>. This pass is mainly to
get a few intermediate wrappers around the HIR types and to process visibility
and inlining. This is where <code>#[doc(inline)]</code>, <code>#[doc(no_inline)]</code>, and
<code>#[doc(hidden)]</code> are processed, as well as the logic for whether a <code>pub use</code>
should get the full page or a &quot;Reexport&quot; line in the module page.</p>
<p>The other major thing that happens in <code>clean/mod.rs</code> is the collection of doc
comments and <code>#[doc=&quot;&quot;]</code> attributes into a separate field of the Attributes
struct, present on anything that gets hand-written documentation. This makes it
easier to collect this documentation later in the process.</p>
<p>The primary output of this process is a <code>clean::Crate</code> with a tree of Items
which describe the publicly-documentable items in the target crate.</p>
<h3><a class="header" href="#hot-potato" id="hot-potato">Hot potato</a></h3>
<p>Before moving on to the next major step, a few important &quot;passes&quot; occur over
the documentation.  These do things like combine the separate &quot;attributes&quot; into
a single string and strip leading whitespace to make the document easier on the
markdown parser, or drop items that are not public or deliberately hidden with
<code>#[doc(hidden)]</code>. These are all implemented in the <code>passes/</code> directory, one
file per pass. By default, all of these passes are run on a crate, but the ones
regarding dropping private/hidden items can be bypassed by passing
<code>--document-private-items</code> to rustdoc. Note that unlike the previous set of AST
transformations, the passes happen on the <em>cleaned</em> crate.</p>
<p>(Strictly speaking, you can fine-tune the passes run and even add your own, but
<a href="https://github.com/rust-lang/rust/issues/44136">we're trying to deprecate that</a>. If you need finer-grain control over
these passes, please let us know!)</p>
<p>Here is current (as of this writing) list of passes:</p>
<ul>
<li><code>propagate-doc-cfg</code> - propagates <code>#[doc(cfg(...))]</code> to child items.</li>
<li><code>collapse-docs</code> concatenates all document attributes into one document
attribute. This is necessary because each line of a doc comment is given as a
separate doc attribute, and this will combine them into a single string with
line breaks between each attribute.</li>
<li><code>unindent-comments</code> removes excess indentation on comments in order for
markdown to like it. This is necessary because the convention for writing
documentation is to provide a space between the <code>///</code> or <code>//!</code> marker and the
text, and stripping that leading space will make the text easier to parse by
the Markdown parser. (In the past, the markdown parser used was not
Commonmark- compliant, which caused annoyances with extra whitespace but this
seems to be less of an issue today.)</li>
<li><code>strip-priv-imports</code> strips all private import statements (<code>use</code>, <code>extern crate</code>) from a crate. This is necessary because rustdoc will handle <em>public</em>
imports by either inlining the item's documentation to the module or creating
a &quot;Reexports&quot; section with the import in it. The pass ensures that all of
these imports are actually relevant to documentation.</li>
<li><code>strip-hidden</code> and <code>strip-private</code> strip all <code>doc(hidden)</code> and private items
from the output. <code>strip-private</code> implies <code>strip-priv-imports</code>. Basically, the
goal is to remove items that are not relevant for public documentation.</li>
</ul>
<h2><a class="header" href="#from-clean-to-crate" id="from-clean-to-crate">From clean to crate</a></h2>
<p>This is where the &quot;second phase&quot; in rustdoc begins. This phase primarily lives
in the <code>html/</code> folder, and it all starts with <code>run()</code> in <code>html/render.rs</code>. This
code is responsible for setting up the <code>Context</code>, <code>SharedContext</code>, and <code>Cache</code>
which are used during rendering, copying out the static files which live in
every rendered set of documentation (things like the fonts, CSS, and JavaScript
that live in <code>html/static/</code>), creating the search index, and printing out the
source code rendering, before beginning the process of rendering all the
documentation for the crate.</p>
<p>Several functions implemented directly on <code>Context</code> take the <code>clean::Crate</code> and
set up some state between rendering items or recursing on a module's child
items. From here the &quot;page rendering&quot; begins, via an enormous <code>write!()</code> call
in <code>html/layout.rs</code>. The parts that actually generate HTML from the items and
documentation occurs within a series of <code>std::fmt::Display</code> implementations and
functions that pass around a <code>&amp;mut std::fmt::Formatter</code>. The top-level
implementation that writes out the page body is the <code>impl&lt;'a&gt; fmt::Display for Item&lt;'a&gt;</code> in <code>html/render.rs</code>, which switches out to one of several <code>item_*</code>
functions based on the kind of <code>Item</code> being rendered.</p>
<p>Depending on what kind of rendering code you're looking for, you'll probably
find it either in <code>html/render.rs</code> for major items like &quot;what sections should I
print for a struct page&quot; or <code>html/format.rs</code> for smaller component pieces like
&quot;how should I print a where clause as part of some other item&quot;.</p>
<p>Whenever rustdoc comes across an item that should print hand-written
documentation alongside, it calls out to <code>html/markdown.rs</code> which interfaces
with the Markdown parser. This is exposed as a series of types that wrap a
string of Markdown, and implement <code>fmt::Display</code> to emit HTML text. It takes
special care to enable certain features like footnotes and tables and add
syntax highlighting to Rust code blocks (via <code>html/highlight.rs</code>) before
running the Markdown parser. There's also a function in here
(<code>find_testable_code</code>) that specifically scans for Rust code blocks so the
test-runner code can find all the doctests in the crate.</p>
<h3><a class="header" href="#from-soup-to-nuts" id="from-soup-to-nuts">From soup to nuts</a></h3>
<p>(alternate title: <a href="https://www.youtube.com/watch?v=hOLAGYmUQV0">&quot;An unbroken thread that stretches from those first <code>Cell</code>s
to us&quot;</a>)</p>
<p>It's important to note that the AST cleaning can ask the compiler for
information (crucially, <code>DocContext</code> contains a <code>TyCtxt</code>), but page rendering
cannot. The <code>clean::Crate</code> created within <code>run_core</code> is passed outside the
compiler context before being handed to <code>html::render::run</code>. This means that a
lot of the &quot;supplementary data&quot; that isn't immediately available inside an
item's definition, like which trait is the <code>Deref</code> trait used by the language,
needs to be collected during cleaning, stored in the <code>DocContext</code>, and passed
along to the <code>SharedContext</code> during HTML rendering.  This manifests as a bunch
of shared state, context variables, and <code>RefCell</code>s.</p>
<p>Also of note is that some items that come from &quot;asking the compiler&quot; don't go
directly into the <code>DocContext</code> - for example, when loading items from a foreign
crate, rustdoc will ask about trait implementations and generate new <code>Item</code>s
for the impls based on that information. This goes directly into the returned
<code>Crate</code> rather than roundabout through the <code>DocContext</code>. This way, these
implementations can be collected alongside the others, right before rendering
the HTML.</p>
<h2><a class="header" href="#other-tricks-up-its-sleeve" id="other-tricks-up-its-sleeve">Other tricks up its sleeve</a></h2>
<p>All this describes the process for generating HTML documentation from a Rust
crate, but there are couple other major modes that rustdoc runs in. It can also
be run on a standalone Markdown file, or it can run doctests on Rust code or
standalone Markdown files. For the former, it shortcuts straight to
<code>html/markdown.rs</code>, optionally including a mode which inserts a Table of
Contents to the output HTML.</p>
<p>For the latter, rustdoc runs a similar partial-compilation to get relevant
documentation in <code>test.rs</code>, but instead of going through the full clean and
render process, it runs a much simpler crate walk to grab <em>just</em> the
hand-written documentation. Combined with the aforementioned
&quot;<code>find_testable_code</code>&quot; in <code>html/markdown.rs</code>, it builds up a collection of
tests to run before handing them off to the libtest test runner. One notable
location in <code>test.rs</code> is the function <code>make_test</code>, which is where hand-written
doctests get transformed into something that can be executed.</p>
<p>Some extra reading about <code>make_test</code> can be found
<a href="https://quietmisdreavus.net/code/2018/02/23/how-the-doctests-get-made/">here</a>.</p>
<h2><a class="header" href="#dotting-is-and-crossing-ts" id="dotting-is-and-crossing-ts">Dotting i's and crossing t's</a></h2>
<p>So that's rustdoc's code in a nutshell, but there's more things in the repo
that deal with it. Since we have the full <code>compiletest</code> suite at hand, there's
a set of tests in <code>src/test/rustdoc</code> that make sure the final HTML is what we
expect in various situations. These tests also use a supplementary script,
<code>src/etc/htmldocck.py</code>, that allows it to look through the final HTML using
XPath notation to get a precise look at the output. The full description of all
the commands available to rustdoc tests is in <code>htmldocck.py</code>.</p>
<p>In addition, there are separate tests for the search index and rustdoc's
ability to query it. The files in <code>src/test/rustdoc-js</code> each contain a
different search query and the expected results, broken out by search tab.
These files are processed by a script in <code>src/tools/rustdoc-js</code> and the Node.js
runtime. These tests don't have as thorough of a writeup, but a broad example
that features results in all tabs can be found in <code>basic.js</code>. The basic idea is
that you match a given <code>QUERY</code> with a set of <code>EXPECTED</code> results, complete with
the full item path of each item.</p>
<h1><a class="header" href="#example-type-checking-through-rustc_interface" id="example-type-checking-through-rustc_interface">Example: Type checking through <code>rustc_interface</code></a></h1>
<p><code>rustc_interface</code> allows you to interact with Rust code at various stages of compilation.</p>
<h2><a class="header" href="#getting-the-type-of-an-expression" id="getting-the-type-of-an-expression">Getting the type of an expression</a></h2>
<p>To get the type of an expression, use the <code>global_ctxt</code> to get a <code>TyCtxt</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// See https://github.com/rust-lang/rustc-dev-guide/blob/master/examples/rustc-driver-interacting-with-the-ast.rs for complete program.
let config = rustc_interface::Config {
    input: config::Input::Str {
        name: source_map::FileName::Custom(&quot;main.rs&quot;.to_string()),
        input: &quot;fn main() { let message = \&quot;Hello, world!\&quot;; println!(\&quot;{}\&quot;, message); }&quot;
            .to_string(),
    },
    /* other config */
};
rustc_interface::run_compiler(config, |compiler| {
    compiler.enter(|queries| {
        // Analyze the crate and inspect the types under the cursor.
        queries.global_ctxt().unwrap().take().enter(|tcx| {
            // Every compilation contains a single crate.
            let krate = tcx.hir().krate();
            // Iterate over the top-level items in the crate, looking for the main function.
            for (_, item) in &amp;krate.items {
                // Use pattern-matching to find a specific node inside the main function.
                if let rustc_hir::ItemKind::Fn(_, _, body_id) = item.kind {
                    let expr = &amp;tcx.hir().body(body_id).value;
                    if let rustc_hir::ExprKind::Block(block, _) = expr.kind {
                        if let rustc_hir::StmtKind::Local(local) = block.stmts[0].kind {
                            if let Some(expr) = local.init {
                                let hir_id = expr.hir_id; // hir_id identifies the string &quot;Hello, world!&quot;
                                let def_id = tcx.hir().local_def_id(item.hir_id); // def_id identifies the main function
                                let ty = tcx.typeck_tables_of(def_id).node_type(hir_id);
                                println!(&quot;{:?}: {:?}&quot;, expr, ty); // prints expr(HirId { owner: DefIndex(3), local_id: 4 }: &quot;Hello, world!&quot;): &amp;'static str
                            }
                        }
                    }
                }
            }
        })
    });
});
</code></pre></pre>
<h1><a class="header" href="#example-getting-diagnostic-through-rustc_interface" id="example-getting-diagnostic-through-rustc_interface">Example: Getting diagnostic through <code>rustc_interface</code></a></h1>
<p><code>rustc_interface</code> allows you to intercept diagnostics that would otherwise be printed to stderr.</p>
<h2><a class="header" href="#getting-diagnostics" id="getting-diagnostics">Getting diagnostics</a></h2>
<p>To get diagnostics from the compiler, 
configure <code>rustc_interface::Config</code> to output diagnostic to a buffer, 
and run <code>TyCtxt.analysis</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// See https://github.com/rust-lang/rustc-dev-guide/blob/master/examples/rustc-driver-getting-diagnostics.rs for complete program.
let buffer = sync::Arc::new(sync::Mutex::new(Vec::new()));
let config = rustc_interface::Config {
    opts: config::Options {
        // Configure the compiler to emit diagnostics in compact JSON format.
        error_format: config::ErrorOutputType::Json {
            pretty: false,
            json_rendered: rustc_errors::emitter::HumanReadableErrorType::Default(
                rustc_errors::emitter::ColorConfig::Never,
            ),
        },
        /* other config */
    },
    // Redirect the diagnostic output of the compiler to a buffer.
    diagnostic_output: rustc_session::DiagnosticOutput::Raw(Box::from(DiagnosticSink(
        buffer.clone(),
    ))),
    /* other config */
};
rustc_interface::run_compiler(config, |compiler| {
    compiler.enter(|queries| {
        queries.global_ctxt().unwrap().take().enter(|tcx| {
            // Run the analysis phase on the local crate to trigger the type error.
            tcx.analysis(rustc_hir::def_id::LOCAL_CRATE);
        });
    });
});
// Read buffered diagnostics.
let diagnostics = String::from_utf8(buffer.lock().unwrap().clone()).unwrap();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#syntax-and-the-ast" id="syntax-and-the-ast">Syntax and the AST</a></h1>
<p>Working directly with source code is very inconvenient and error-prone. Thus,
before we do anything else, we convert raw source code into an AST. It turns
out that doing even this involves a lot of work, including lexing, parsing,
macro expansion, name resolution, conditional compilation, feature-gate
checking, and validation of the AST. In this chapter, we take a look at all
of these steps.</p>
<p>Notably, there isn't always a clean ordering between these tasks. For example,
macro expansion relies on name resolution to resolve the names of macros and
imports. And parsing requires macro expansion, which in turn may require
parsing the output of the macro.</p>
<h1><a class="header" href="#lexing-and-parsing" id="lexing-and-parsing">Lexing and Parsing</a></h1>
<blockquote>
<p>The parser and lexer are currently undergoing a lot of refactoring, so parts
of this chapter may be out of date.</p>
</blockquote>
<p>The very first thing the compiler does is take the program (in Unicode
characters) and turn it into something the compiler can work with more
conveniently than strings. This happens in two stages: Lexing and Parsing.</p>
<p>Lexing takes strings and turns them into streams of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/token/index.html">tokens</a>. For example,
<code>a.b + c</code> would be turned into the tokens <code>a</code>, <code>.</code>, <code>b</code>, <code>+</code>, and <code>c</code>.
The lexer lives in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lexer/index.html"><code>librustc_lexer</code></a>.</p>
<p>Parsing then takes streams of tokens and turns them into a structured
form which is easier for the compiler to work with, usually called an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>Abstract
Syntax Tree</em></a> (AST). An AST mirrors the structure of a Rust program in memory,
using a <code>Span</code> to link a particular AST node back to its source text.</p>
<p>The AST is defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>librustc_ast</code></a>, along with some definitions for
tokens and token streams, data structures/traits for mutating ASTs, and shared
definitions for other AST-related parts of the compiler (like the lexer and
macro-expansion).</p>
<p>The parser is defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/index.html"><code>librustc_parse</code></a>, along with a
high-level interface to the lexer and some validation routines that run after
macro expansion. In particular, the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/index.html"><code>rustc_parse::parser</code></a> contains
the parser implementation.</p>
<p>The main entrypoint to the parser is via the various <code>parse_*</code> functions in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/index.html">parser</a>. They let you do things like turn a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.SourceFile.html"><code>SourceFile</code></a>
(e.g. the source in a single file) into a token stream, create a parser from
the token stream, and then execute the parser to get a <code>Crate</code> (the root AST
node).</p>
<p>To minimise the amount of copying that is done, both the <code>StringReader</code> and
<code>Parser</code> have lifetimes which bind them to the parent <code>ParseSess</code>. This contains
all the information needed while parsing, as well as the <code>SourceMap</code> itself.</p>
<p>Note that while parsing, we may encounter macro definitions or invocations. We
set these aside to be expanded (see <a href="./macro-expansion.html">this chapter</a>).
Expansion may itself require parsing the output of the macro, which may reveal
more macros to be expanded, and so on.</p>
<h2><a class="header" href="#more-on-lexical-analysis" id="more-on-lexical-analysis">More on Lexical Analysis</a></h2>
<p>Code for lexical analysis is split between two crates:</p>
<ul>
<li>
<p><code>rustc_lexer</code> crate is responsible for breaking a <code>&amp;str</code> into chunks
constituting tokens. Although it is popular to implement lexers as generated
finite state machines, the lexer in <code>rustc_lexer</code> is hand-written.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/lexer/struct.StringReader.html"><code>StringReader</code></a> from <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>librustc_ast</code></a> integrates <code>rustc_lexer</code> with <code>rustc</code>
specific data structures. Specifically, it adds <code>Span</code> information to tokens
returned by <code>rustc_lexer</code> and interns identifiers.</p>
</li>
</ul>
<h1><a class="header" href="#macro-expansion" id="macro-expansion">Macro expansion</a></h1>
<blockquote>
<p><code>librustc_ast</code>, <code>librustc_expand</code>, and <code>librustc_builtin_macros</code> are all undergoing
refactoring, so some of the links in this chapter may be broken.</p>
</blockquote>
<p>Rust has a very powerful macro system. In the previous chapter, we saw how the
parser sets aside macros to be expanded (it temporarily uses <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/placeholders/index.html">placeholders</a>).
This chapter is about the process of expanding those macros iteratively until
we have a complete AST for our crate with no unexpanded macros (or a compile
error).</p>
<p>First, we will discuss the algorithm that expands and integrates macro output
into ASTs. Next, we will take a look at how hygiene data is collected. Finally,
we will look at the specifics of expanding different types of macros.</p>
<p>Many of the algorithms and data structures described below are in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/index.html"><code>rustc_expand</code></a>,
with basic data structures in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/index.html"><code>rustc_expand::base</code></a>.</p>
<p>Also of note, <code>cfg</code> and <code>cfg_attr</code> are treated specially from other macros, and are
handled in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/config/index.html"><code>rustc_expand::config</code></a>.</p>
<h2><a class="header" href="#expansion-and-ast-integration" id="expansion-and-ast-integration">Expansion and AST Integration</a></h2>
<p>First of all, expansion happens at the crate level. Given a raw source code for
a crate, the compiler will produce a massive AST with all macros expanded, all
modules inlined, etc. The primary entry point for this process is the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>MacroExpander::fully_expand_fragment</code></a> method. With few exceptions, we
use this method on the whole crate (see <a href="macro-expansion.html#eager-expansion">&quot;Eager Expansion&quot;</a>
below for more detailed discussion of edge case expansion issues).</p>
<p>At a high level, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>fully_expand_fragment</code></a> works in iterations. We keep a
queue of unresolved macro invocations (that is, macros we haven't found the
definition of yet). We repeatedly try to pick a macro from the queue, resolve
it, expand it, and integrate it back. If we can't make progress in an
iteration, this represents a compile error.  Here is the <a href="https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049">algorithm</a>:</p>
<ol start="0">
<li>Initialize an <code>queue</code> of unresolved macros.</li>
<li>Repeat until <code>queue</code> is empty (or we make no progress, which is an error):
<ol start="0">
<li><a href="./name-resolution.html">Resolve</a> imports in our partially built crate as
much as possible.</li>
<li>Collect as many macro <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.Invocation.html"><code>Invocation</code>s</a> as possible from our
partially built crate (fn-like, attributes, derives) and add them to the
queue.</li>
<li>Dequeue the first element, and attempt to resolve it.</li>
<li>If it's resolved:
<ol start="0">
<li>Run the macro's expander function that consumes a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/struct.TokenStream.html"><code>TokenStream</code></a> or
AST and produces a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/struct.TokenStream.html"><code>TokenStream</code></a> or <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/enum.AstFragment.html"><code>AstFragment</code></a> (depending on
the macro kind). (A <code>TokenStream</code> is a collection of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/enum.TokenTree.html"><code>TokenTree</code>s</a>,
each of which are a token (punctuation, identifier, or literal) or a
delimited group (anything inside <code>()</code>/<code>[]</code>/<code>{}</code>)).
<ul>
<li>At this point, we know everything about the macro itself and can
call <code>set_expn_data</code> to fill in its properties in the global data;
that is the hygiene data associated with <code>ExpnId</code>. (See <a href="macro-expansion.html#hygiene-and-hierarchies">the
&quot;Hygiene&quot; section below</a>).</li>
</ul>
</li>
<li>Integrate that piece of AST into the big existing partially built
AST. This is essentially where the &quot;token-like mass&quot; becomes a
proper set-in-stone AST with side-tables. It happens as follows:
<ul>
<li>If the macro produces tokens (e.g. a proc macro), we parse into
an AST, which may produce parse errors.</li>
<li>During expansion, we create <code>SyntaxContext</code>s (hierarchy 2). (See
<a href="macro-expansion.html#hygiene-and-hierarchies">the &quot;Hygiene&quot; section below</a>)</li>
<li>These three passes happen one after another on every AST fragment
freshly expanded from a macro:
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/node_id/struct.NodeId.html"><code>NodeId</code></a>s are assigned by <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.InvocationCollector.html"><code>InvocationCollector</code></a>. This
also collects new macro calls from this new AST piece and
adds them to the queue.</li>
<li><a href="https://rustc-dev-guide.rust-lang.org/hir.html?highlight=def,path#identifiers-in-the-hir">&quot;Def paths&quot;</a> are created and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html"><code>DefId</code></a>s are
assigned to them by <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/def_collector/struct.DefCollector.html"><code>DefCollector</code></a>.</li>
<li>Names are put into modules (from the resolver's point of
view) by <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/build_reduced_graph/struct.BuildReducedGraphVisitor.html"><code>BuildReducedGraphVisitor</code></a>.</li>
</ul>
</li>
</ul>
</li>
<li>After expanding a single macro and integrating its output, continue
to the next iteration of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>fully_expand_fragment</code></a>.</li>
</ol>
</li>
<li>If it's not resolved:
<ol start="0">
<li>Put the macro back in the queue</li>
<li>Continue to next iteration...</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3><a class="header" href="#error-recovery" id="error-recovery">Error Recovery</a></h3>
<p>If we make no progress in an iteration, then we have reached a compilation
error (e.g. an undefined macro). We attempt to recover from failures
(unresolved macros or imports) for the sake of diagnostics. This allows
compilation to continue past the first error, so that we can report more errors
at a time. Recovery can't cause compilation to suceed. We know that it will
fail at this point. The recovery happens by expanding unresolved macros into
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/enum.ExprKind.html#variant.Err"><code>ExprKind::Err</code></a>.</p>
<h3><a class="header" href="#name-resolution" id="name-resolution">Name Resolution</a></h3>
<p>Notice that name resolution is involved here: we need to resolve imports and
macro names in the above algorithm. This is done in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/macros/index.html"><code>rustc_resolve::macros</code></a>, which resolves macro paths, validates
those resolutions, and reports various errors (e.g. &quot;not found&quot; or &quot;found, but
it's unstable&quot; or &quot;expected x, found y&quot;). However, we don't try to resolve
other names yet. This happens later, as we will see in the <a href="./name-resolution.html">next
chapter</a>.</p>
<h3><a class="header" href="#eager-expansion" id="eager-expansion">Eager Expansion</a></h3>
<p><em>Eager expansion</em> means that we expand the arguments of a macro invocation
before the macro invocation itself. This is implemented only for a few special
built-in macros that expect literals; expanding arguments first for some of
these macro results in a smoother user experience.  As an example, consider the
following:</p>
<pre><code class="language-rust ignore">macro bar($i: ident) { $i }
macro foo($i: ident) { $i }

foo!(bar!(baz));
</code></pre>
<p>A lazy expansion would expand <code>foo!</code> first. An eager expansion would expand
<code>bar!</code> first.</p>
<p>Eager expansion is not a generally available feature of Rust.  Implementing
eager expansion more generally would be challenging, but we implement it for a
few special built-in macros for the sake of user experience.  The built-in
macros are implemented in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_builtin_macros/index.html"><code>rustc_builtin_macros</code></a>, along with some other early
code generation facilities like injection of standard library imports or
generation of test harness. There are some additional helpers for building
their AST fragments in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/build/index.html"><code>rustc_expand::build</code></a>. Eager expansion generally
performs a subset of the things that lazy (normal) expansion. It is done by
invoking <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/struct.MacroExpander.html#method.fully_expand_fragment"><code>fully_expand_fragment</code></a> on only part of a crate (as opposed to
whole crate, like we normally do).</p>
<h3><a class="header" href="#other-data-structures" id="other-data-structures">Other Data Structures</a></h3>
<p>Here are some other notable data structures involved in expansion and integration:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.Resolver.html"><code>Resolver</code></a> - a trait used to break crate dependencies. This allows the
resolver services to be used in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>rustc_ast</code></a>, despite <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/index.html"><code>rustc_resolve</code></a> and
pretty much everything else depending on <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>rustc_ast</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/struct.ExtCtxt.html"><code>ExtCtxt</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/struct.ExpansionData.html"><code>ExpansionData</code></a> - various intermediate data kept and used by expansion
infrastructure in the process of its work</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/enum.Annotatable.html"><code>Annotatable</code></a> - a piece of AST that can be an attribute target, almost same
thing as AstFragment except for types and patterns that can be produced by
macros but cannot be annotated with attributes</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.MacResult.html"><code>MacResult</code></a> - a &quot;polymorphic&quot; AST fragment, something that can turn into a
different <code>AstFragment</code> depending on its <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/expand/enum.AstFragmentKind.html"><code>AstFragmentKind</code></a> - item,
or expression, or pattern etc.</li>
</ul>
<h2><a class="header" href="#hygiene-and-hierarchies" id="hygiene-and-hierarchies">Hygiene and Hierarchies</a></h2>
<p>If you have ever used C/C++ preprocessor macros, you know that there are some
annoying and hard-to-debug gotchas! For example, consider the following C code:</p>
<pre><code class="language-c">#define DEFINE_FOO struct Bar {int x;}; struct Foo {Bar bar;};

// Then, somewhere else
struct Bar {
    ...
};

DEFINE_FOO
</code></pre>
<p>Most people avoid writing C like this – and for good reason: it doesn't
compile. The <code>struct Bar</code> defined by the macro clashes names with the <code>struct Bar</code> defined in the code. Consider also the following example:</p>
<pre><code class="language-c">#define DO_FOO(x) {\
    int y = 0;\
    foo(x, y);\
    }

// Then elsewhere
int y = 22;
DO_FOO(y);
</code></pre>
<p>Do you see the problem? We wanted to generate a call <code>foo(22, 0)</code>, but instead
we got <code>foo(0, 0)</code> because the macro defined its own <code>y</code>!</p>
<p>These are both examples of <em>macro hygiene</em> issues. <em>Hygiene</em> relates to how to
handle names defined <em>within a macro</em>. In particular, a hygienic macro system
prevents errors due to names introduced within a macro. Rust macros are hygienic
in that they do not allow one to write the sorts of bugs above.</p>
<p>At a high level, hygiene within the rust compiler is accomplished by keeping
track of the context where a name is introduced and used. We can then
disambiguate names based on that context. Future iterations of the macro system
will allow greater control to the macro author to use that context. For example,
a macro author may want to introduce a new name to the context where the macro
was called. Alternately, the macro author may be defining a variable for use
only within the macro (i.e. it should not be visible outside the macro).</p>
<p>The context is attached to AST nodes. All AST nodes generated by macros have
context attached. Additionally, there may be other nodes that have context
attached, such as some desugared syntax (non-macro-expanded nodes are
considered to just have the &quot;root&quot; context, as described below).
Throughout the compiler, we use <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>librustc_span::Span</code>s</a> to refer to code locations.
This struct also has hygiene information attached to it, as we will see later.</p>
<p>Because macros invocations and definitions can be nested, the syntax context of
a node must be a hierarchy. For example, if we expand a macro and there is
another macro invocation or definition in the generated output, then the syntax
context should reflex the nesting.</p>
<p>However, it turns out that there are actually a few types of context we may
want to track for different purposes. Thus, there are not just one but <em>three</em>
expansion hierarchies that together comprise the hygiene information for a
crate.</p>
<p>All of these hierarchies need some sort of &quot;macro ID&quot; to identify individual
elements in the chain of expansions. This ID is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnId.html"><code>ExpnId</code></a>.  All macros receive
an integer ID, assigned continuously starting from 0 as we discover new macro
calls.  All hierarchies start at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnId.html#method.root"><code>ExpnId::root()</code></a>, which is its own
parent.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/index.html"><code>rustc_span::hygiene</code></a> contains all of the hygiene-related algorithms
(with the exception of some hacks in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/struct.Resolver.html#method.resolve_crate_root"><code>Resolver::resolve_crate_root</code></a>)
and structures related to hygiene and expansion that are kept in global data.</p>
<p>The actual hierarchies are stored in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.HygieneData.html"><code>HygieneData</code></a>. This is a global
piece of data containing hygiene and expansion info that can be accessed from
any <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html"><code>Ident</code></a> without any context.</p>
<h3><a class="header" href="#the-expansion-order-hierarchy" id="the-expansion-order-hierarchy">The Expansion Order Hierarchy</a></h3>
<p>The first hierarchy tracks the order of expansions, i.e., when a macro
invocation is in the output of another macro.</p>
<p>Here, the children in the hierarchy will be the &quot;innermost&quot; tokens.  The
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnData.html"><code>ExpnData</code></a> struct itself contains a subset of properties from both macro
definition and macro call available through global data.
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnData.html#structfield.parent"><code>ExpnData::parent</code></a> tracks the child -&gt; parent link in this hierarchy.</p>
<p>For example,</p>
<pre><code class="language-rust ignore">macro_rules! foo { () =&gt; { println!(); } }

fn main() { foo!(); }
</code></pre>
<p>In this code, the AST nodes that are finally generated would have hierarchy:</p>
<pre><code>root
    expn_id_foo
        expn_id_println
</code></pre>
<h3><a class="header" href="#the-macro-definition-hierarchy" id="the-macro-definition-hierarchy">The Macro Definition Hierarchy</a></h3>
<p>The second hierarchy tracks the order of macro definitions, i.e., when we are
expanding one macro another macro definition is revealed in its output.  This
one is a bit tricky and more complex than the other two hierarchies.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html"><code>SyntaxContext</code></a> represents a whole chain in this hierarchy via an ID.
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContextData.html"><code>SyntaxContextData</code></a> contains data associated with the given
<code>SyntaxContext</code>; mostly it is a cache for results of filtering that chain in
different ways.  <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContextData.html#structfield.parent"><code>SyntaxContextData::parent</code></a> is the child -&gt; parent
link here, and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContextData.html#structfield.outer_expn"><code>SyntaxContextData::outer_expns</code></a> are individual
elements in the chain.  The &quot;chaining operator&quot; is
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html#method.apply_mark"><code>SyntaxContext::apply_mark</code></a> in compiler code.</p>
<p>A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>Span</code></a>, mentioned above, is actually just a compact representation of
a code location and <code>SyntaxContext</code>. Likewise, an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html"><code>Ident</code></a> is just an interned
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html"><code>Symbol</code></a> + <code>Span</code> (i.e. an interned string + hygiene data).</p>
<p>For built-in macros, we use the context:
<code>SyntaxContext::empty().apply_mark(expn_id)</code>, and such macros are considered to
be defined at the hierarchy root. We do the same for proc-macros because we
haven't implemented cross-crate hygiene yet.</p>
<p>If the token had context <code>X</code> before being produced by a macro then after being
produced by the macro it has context <code>X -&gt; macro_id</code>. Here are some examples:</p>
<p>Example 0:</p>
<pre><code class="language-rust ignore">macro m() { ident }

m!();
</code></pre>
<p>Here <code>ident</code> originally has context <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html#method.root"><code>SyntaxContext::root()</code></a>. <code>ident</code> has
context <code>ROOT -&gt; id(m)</code> after it's produced by <code>m</code>.</p>
<p>Example 1:</p>
<pre><code class="language-rust ignore">macro m() { macro n() { ident } }

m!();
n!();
</code></pre>
<p>In this example the <code>ident</code> has context <code>ROOT</code> originally, then <code>ROOT -&gt; id(m)</code>
after the first expansion, then <code>ROOT -&gt; id(m) -&gt; id(n)</code>.</p>
<p>Example 2:</p>
<p>Note that these chains are not entirely determined by their last element, in
other words <code>ExpnId</code> is not isomorphic to <code>SyntaxContext</code>.</p>
<pre><code class="language-rust ignore">macro m($i: ident) { macro n() { ($i, bar) } }

m!(foo);
</code></pre>
<p>After all expansions, <code>foo</code> has context <code>ROOT -&gt; id(n)</code> and <code>bar</code> has context
<code>ROOT -&gt; id(m) -&gt; id(n)</code>.</p>
<p>Finally, one last thing to mention is that currently, this hierarchy is subject
to the <a href="https://github.com/rust-lang/rust/pull/51762#issuecomment-401400732">&quot;context transplantation hack&quot;</a>. Basically, the more modern (and
experimental) <code>macro</code> macros have stronger hygiene than the older MBE system,
but this can result in weird interactions between the two. The hack is intended
to make things &quot;just work&quot; for now.</p>
<h3><a class="header" href="#the-call-site-hierarchy" id="the-call-site-hierarchy">The Call-site Hierarchy</a></h3>
<p>The third and final hierarchy tracks the location of macro invocations.</p>
<p>In this hierarchy <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/struct.ExpnData.html#structfield.call_site"><code>ExpnData::call_site</code></a> is the child -&gt; parent link.</p>
<p>Here is an example:</p>
<pre><code class="language-rust ignore">macro bar($i: ident) { $i }
macro foo($i: ident) { $i }

foo!(bar!(baz));
</code></pre>
<p>For the <code>baz</code> AST node in the final output, the first hierarchy is <code>ROOT -&gt; id(foo) -&gt; id(bar) -&gt; baz</code>, while the third hierarchy is <code>ROOT -&gt; baz</code>.</p>
<h3><a class="header" href="#macro-backtraces" id="macro-backtraces">Macro Backtraces</a></h3>
<p>Macro backtraces are implemented in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/index.html"><code>rustc_span</code></a> using the hygiene machinery
in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/hygiene/index.html"><code>rustc_span::hygiene</code></a>.</p>
<h2><a class="header" href="#producing-macro-output" id="producing-macro-output">Producing Macro Output</a></h2>
<p>Above, we saw how the output of a macro is integrated into the AST for a crate,
and we also saw how the hygiene data for a crate is generated. But how do we
actually produce the output of a macro? It depends on the type of macro.</p>
<p>There are two types of macros in Rust:
<code>macro_rules!</code> macros (a.k.a. &quot;Macros By Example&quot; (MBE)) and procedural macros
(or &quot;proc macros&quot;; including custom derives). During the parsing phase, the normal
Rust parser will set aside the contents of macros and their invocations. Later,
macros are expanded using these portions of the code.</p>
<p>Some important data structures/interfaces here:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/struct.SyntaxExtension.html"><code>SyntaxExtension</code></a> - a lowered macro representation, contains its expander
function, which transforms a <code>TokenStream</code> or AST into another <code>TokenStream</code>
or AST + some additional data like stability, or a list of unstable features
allowed inside the macro.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/enum.SyntaxExtensionKind.html"><code>SyntaxExtensionKind</code></a> - expander functions may have several different
signatures (take one token stream, or two, or a piece of AST, etc). This is
an enum that lists them.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.ProcMacro.html"><code>ProcMacro</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.TTMacroExpander.html"><code>TTMacroExpander</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.AttrProcMacro.html"><code>AttrProcMacro</code></a>/<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/base/trait.MultiItemModifier.html"><code>MultiItemModifier</code></a> -
traits representing the expander function signatures.</li>
</ul>
<h2><a class="header" href="#macros-by-example" id="macros-by-example">Macros By Example</a></h2>
<p>MBEs have their own parser distinct from the normal Rust parser. When macros
are expanded, we may invoke the MBE parser to parse and expand a macro.  The
MBE parser, in turn, may call the normal Rust parser when it needs to bind a
metavariable (e.g.  <code>$my_expr</code>) while parsing the contents of a macro
invocation. The code for macro expansion is in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_expand/mbe"><code>src/librustc_expand/mbe/</code></a>.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<p>It's helpful to have an example to refer to. For the remainder of this chapter,
whenever we refer to the &quot;example <em>definition</em>&quot;, we mean the following:</p>
<pre><code class="language-rust ignore">macro_rules! printer {
    (print $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
    };
    (print twice $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
        println!(&quot;{}&quot;, $mvar);
    };
}
</code></pre>
<p><code>$mvar</code> is called a <em>metavariable</em>. Unlike normal variables, rather than
binding to a value in a computation, a metavariable binds <em>at compile time</em> to
a tree of <em>tokens</em>.  A <em>token</em> is a single &quot;unit&quot; of the grammar, such as an
identifier (e.g. <code>foo</code>) or punctuation (e.g. <code>=&gt;</code>). There are also other
special tokens, such as <code>EOF</code>, which indicates that there are no more tokens.
Token trees resulting from paired parentheses-like characters (<code>(</code>...<code>)</code>,
<code>[</code>...<code>]</code>, and <code>{</code>...<code>}</code>) – they include the open and close and all the tokens
in between (we do require that parentheses-like characters be balanced). Having
macro expansion operate on token streams rather than the raw bytes of a source
file abstracts away a lot of complexity. The macro expander (and much of the
rest of the compiler) doesn't really care that much about the exact line and
column of some syntactic construct in the code; it cares about what constructs
are used in the code. Using tokens allows us to care about <em>what</em> without
worrying about <em>where</em>. For more information about tokens, see the
<a href="./the-parser.html">Parsing</a> chapter of this book.</p>
<p>Whenever we refer to the &quot;example <em>invocation</em>&quot;, we mean the following snippet:</p>
<pre><code class="language-rust ignore">printer!(print foo); // Assume `foo` is a variable defined somewhere else...
</code></pre>
<p>The process of expanding the macro invocation into the syntax tree
<code>println!(&quot;{}&quot;, foo)</code> and then expanding that into a call to <code>Display::fmt</code> is
called <em>macro expansion</em>, and it is the topic of this chapter.</p>
<h3><a class="header" href="#the-mbe-parser" id="the-mbe-parser">The MBE parser</a></h3>
<p>There are two parts to MBE expansion: parsing the definition and parsing the
invocations. Interestingly, both are done by the macro parser.</p>
<p>Basically, the MBE parser is like an NFA-based regex parser. It uses an
algorithm similar in spirit to the <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsing
algorithm</a>. The macro parser is
defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_parser"><code>src/librustc_expand/mbe/macro_parser.rs</code></a>.</p>
<p>The interface of the macro parser is as follows (this is slightly simplified):</p>
<pre><code class="language-rust ignore">fn parse_tt(
    parser: &amp;mut Cow&lt;Parser&gt;,
    ms: &amp;[TokenTree],
) -&gt; NamedParseResult
</code></pre>
<p>We use these items in macro parser:</p>
<ul>
<li><code>parser</code> is a reference to the state of a normal Rust parser, including the
token stream and parsing session. The token stream is what we are about to
ask the MBE parser to parse. We will consume the raw stream of tokens and
output a binding of metavariables to corresponding token trees. The parsing
session can be used to report parser errros.</li>
<li><code>ms</code> a <em>matcher</em>. This is a sequence of token trees that we want to match
the token stream against.</li>
</ul>
<p>In the analogy of a regex parser, the token stream is the input and we are matching it
against the pattern <code>ms</code>. Using our examples, the token stream could be the stream of
tokens containing the inside of the example invocation <code>print foo</code>, while <code>ms</code>
might be the sequence of token (trees) <code>print $mvar:ident</code>.</p>
<p>The output of the parser is a <code>NamedParseResult</code>, which indicates which of
three cases has occurred:</p>
<ul>
<li>Success: the token stream matches the given matcher <code>ms</code>, and we have produced a binding
from metavariables to the corresponding token trees.</li>
<li>Failure: the token stream does not match <code>ms</code>. This results in an error message such as
&quot;No rule expected token <em>blah</em>&quot;.</li>
<li>Error: some fatal error has occurred <em>in the parser</em>. For example, this
happens if there are more than one pattern match, since that indicates
the macro is ambiguous.</li>
</ul>
<p>The full interface is defined <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_parser/fn.parse_tt.html">here</a>.</p>
<p>The macro parser does pretty much exactly the same as a normal regex parser with
one exception: in order to parse different types of metavariables, such as
<code>ident</code>, <code>block</code>, <code>expr</code>, etc., the macro parser must sometimes call back to the
normal Rust parser.</p>
<p>As mentioned above, both definitions and invocations of macros are parsed using
the macro parser. This is extremely non-intuitive and self-referential. The code
to parse macro <em>definitions</em> is in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_rules"><code>src/librustc_expand/mbe/macro_rules.rs</code></a>. It defines the pattern for
matching for a macro definition as <code>$( $lhs:tt =&gt; $rhs:tt );+</code>. In other words,
a <code>macro_rules</code> definition should have in its body at least one occurrence of a
token tree followed by <code>=&gt;</code> followed by another token tree. When the compiler
comes to a <code>macro_rules</code> definition, it uses this pattern to match the two token
trees per rule in the definition of the macro <em>using the macro parser itself</em>.
In our example definition, the metavariable <code>$lhs</code> would match the patterns of
both arms: <code>(print $mvar:ident)</code> and <code>(print twice $mvar:ident)</code>.  And <code>$rhs</code>
would match the bodies of both arms: <code>{ println!(&quot;{}&quot;, $mvar); }</code> and <code>{ println!(&quot;{}&quot;, $mvar); println!(&quot;{}&quot;, $mvar); }</code>. The parser would keep this
knowledge around for when it needs to expand a macro invocation.</p>
<p>When the compiler comes to a macro invocation, it parses that invocation using
the same NFA-based macro parser that is described above. However, the matcher
used is the first token tree (<code>$lhs</code>) extracted from the arms of the macro
<em>definition</em>. Using our example, we would try to match the token stream <code>print foo</code> from the invocation against the matchers <code>print $mvar:ident</code> and <code>print twice $mvar:ident</code> that we previously extracted from the definition.  The
algorithm is exactly the same, but when the macro parser comes to a place in the
current matcher where it needs to match a <em>non-terminal</em> (e.g. <code>$mvar:ident</code>),
it calls back to the normal Rust parser to get the contents of that
non-terminal. In this case, the Rust parser would look for an <code>ident</code> token,
which it finds (<code>foo</code>) and returns to the macro parser. Then, the macro parser
proceeds in parsing as normal. Also, note that exactly one of the matchers from
the various arms should match the invocation; if there is more than one match,
the parse is ambiguous, while if there are no matches at all, there is a syntax
error.</p>
<p>For more information about the macro parser's implementation, see the comments
in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/mbe/macro_parser"><code>src/librustc_expand/mbe/macro_parser.rs</code></a>.</p>
<h3><a class="header" href="#macros-and-macros-20" id="macros-and-macros-20"><code>macro</code>s and Macros 2.0</a></h3>
<p>There is an old and mostly undocumented effort to improve the MBE system, give
it more hygiene-related features, better scoping and visibility rules, etc. There
hasn't been a lot of work on this recently, unfortunately. Internally, <code>macro</code>
macros use the same machinery as today's MBEs; they just have additional
syntactic sugar and are allowed to be in namespaces.</p>
<h2><a class="header" href="#procedural-macros" id="procedural-macros">Procedural Macros</a></h2>
<p>Precedural macros are also expanded during parsing, as mentioned above.
However, they use a rather different mechanism. Rather than having a parser in
the compiler, procedural macros are implemented as custom, third-party crates.
The compiler will compile the proc macro crate and specially annotated
functions in them (i.e. the proc macro itself), passing them a stream of tokens.</p>
<p>The proc macro can then transform the token stream and output a new token
stream, which is synthesized into the AST.</p>
<p>It's worth noting that the token stream type used by proc macros is <em>stable</em>,
so <code>rustc</code> does not use it internally (since our internal data structures are
unstable). The compiler's token stream is
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/struct.TokenStream.html"><code>rustc_ast::tokenstream::TokenStream</code></a>, as previously. This is
converted into the stable <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>proc_macro::TokenStream</code></a> and back in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/proc_macro/index.html"><code>rustc_expand::proc_macro</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_expand/proc_macro_server/index.html"><code>rustc_expand::proc_macro_server</code></a>.
Because the Rust ABI is unstable, we use the C ABI for this conversion.</p>
<p>TODO: more here.</p>
<h3><a class="header" href="#custom-derive" id="custom-derive">Custom Derive</a></h3>
<p>Custom derives are a special type of proc macro.</p>
<p>TODO: more?</p>
<h1><a class="header" href="#name-resolution-1" id="name-resolution-1">Name resolution</a></h1>
<p>In the previous chapters, we saw how the AST is built with all macros expanded.
We saw how doing that requires doing some name resolution to resolve imports
and macro names. In this chapter, we show how this is actually done and more.</p>
<p>In fact, we don't do full name resolution during macro expansion -- we only
resolve imports and macros at that time. This is required to know what to even
expand. Later, after we have the whole AST, we due full name resolution to
resolve all names in the crate. This happens in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/late/index.html"><code>rustc_resolve::late</code></a>.
Unlike during macro expansion, in this late expansion, we only need to try to
resolve a name once, since no new names can be added. If we fail to resolve a
name now, then it is a compiler error.</p>
<p>Name resolution can be complex. There are a few different namespaces (e.g.
macros, values, types, lifetimes), and names my be valid at different (nested)
scopes. Also, different types of names can fail to be resolved differently, and
failures can happen differently at different scopes. For example, for a module
scope, failure means no unexpanded macros and no unresolved glob imports in
that module. On the other hand, in a function body, failure requires that a
name be absent from the block we are in, all outer scopes, and the global
scope.</p>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>In our programs we can refer to variables, types, functions, etc, by giving them
a name. These names are not always unique. For example, take this valid Rust
program:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type x = u32;
let x: x = 1;
let y: x = 2;
<span class="boring">}
</span></code></pre></pre>
<p>How do we know on line 3 whether <code>x</code> is a type (u32) or a value (1)? These
conflicts are resolved during name resolution. In this specific case, name
resolution defines that type names and variable names live in separate
namespaces and therefore can co-exist.</p>
<p>The name resolution in Rust is a two-phase process. In the first phase, which runs
during macro expansion, we build a tree of modules and resolve imports. Macro
expansion and name resolution communicate with each other via the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast_lowering/trait.Resolver.html"><code>Resolver</code></a> trait.</p>
<p>The input to the second phase is the syntax tree, produced by parsing input
files and expanding macros. This phase produces links from all the names in the
source to relevant places where the name was introduced. It also generates
helpful error messages, like typo suggestions, traits to import or lints about
unused items.</p>
<p>A successful run of the second phase (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/struct.Resolver.html#method.resolve_crate"><code>Resolver::resolve_crate</code></a>) creates kind
of an index the rest of the compilation may use to ask about the present names
(through the <code>hir::lowering::Resolver</code> interface).</p>
<p>The name resolution lives in the <code>librustc_resolve</code> crate, with the meat in
<code>lib.rs</code> and some helpers or symbol-type specific logic in the other modules.</p>
<h2><a class="header" href="#namespaces" id="namespaces">Namespaces</a></h2>
<p>Different kind of symbols live in different namespaces ‒ e.g. types don't
clash with variables. This usually doesn't happen, because variables start with
lower-case letter while types with upper case one, but this is only a
convention. This is legal Rust code that'll compile (with warnings):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type x = u32;
let x: x = 1;
let y: x = 2; // See? x is still a type here.
<span class="boring">}
</span></code></pre></pre>
<p>To cope with this, and with slightly different scoping rules for these
namespaces, the resolver keeps them separated and builds separate structures for
them.</p>
<p>In other words, when the code talks about namespaces, it doesn't mean the module
hierarchy, it's types vs. values vs. macros.</p>
<h2><a class="header" href="#scopes-and-ribs" id="scopes-and-ribs">Scopes and ribs</a></h2>
<p>A name is visible only in certain area in the source code. This forms a
hierarchical structure, but not necessarily a simple one ‒ if one scope is
part of another, it doesn't mean the name visible in the outer one is also
visible in the inner one, or that it refers to the same thing.</p>
<p>To cope with that, the compiler introduces the concept of Ribs. This is
abstraction of a scope. Every time the set of visible names potentially changes,
a new rib is pushed onto a stack. The places where this can happen includes for
example:</p>
<ul>
<li>The obvious places ‒ curly braces enclosing a block, function boundaries,
modules.</li>
<li>Introducing a let binding ‒ this can shadow another binding with the same
name.</li>
<li>Macro expansion border ‒ to cope with macro hygiene.</li>
</ul>
<p>When searching for a name, the stack of ribs is traversed from the innermost
outwards. This helps to find the closest meaning of the name (the one not
shadowed by anything else). The transition to outer rib may also change the
rules what names are usable ‒ if there are nested functions (not closures),
the inner one can't access parameters and local bindings of the outer one,
even though they should be visible by ordinary scoping rules. An example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn do_something&lt;T: Default&gt;(val: T) { // &lt;- New rib in both types and values (1)
    // `val` is accessible, as is the helper function
    // `T` is accessible
    let helper = || { // New rib on `helper` (2) and another on the block (3)
        // `val` is accessible here
    }; // End of (3)
    // `val` is accessible, `helper` variable shadows `helper` function
    fn helper() { // &lt;- New rib in both types and values (4)
        // `val` is not accessible here, (4) is not transparent for locals)
        // `T` is not accessible here
    } // End of (4)
    let val = T::default(); // New rib (5)
    // `val` is the variable, not the parameter here
} // End of (5), (2) and (1)
<span class="boring">}
</span></code></pre></pre>
<p>Because the rules for different namespaces are a bit different, each namespace
has its own independent rib stack that is constructed in parallel to the others.
In addition, there's also a rib stack for local labels (e.g. names of loops or
blocks), which isn't a full namespace in its own right.</p>
<h2><a class="header" href="#overall-strategy" id="overall-strategy">Overall strategy</a></h2>
<p>To perform the name resolution of the whole crate, the syntax tree is traversed
top-down and every encountered name is resolved. This works for most kinds of
names, because at the point of use of a name it is already introduced in the Rib
hierarchy.</p>
<p>There are some exceptions to this. Items are bit tricky, because they can be
used even before encountered ‒ therefore every block needs to be first scanned
for items to fill in its Rib.</p>
<p>Other, even more problematic ones, are imports which need recursive fixed-point
resolution and macros, that need to be resolved and expanded before the rest of
the code can be processed.</p>
<p>Therefore, the resolution is performed in multiple stages.</p>
<h2><a class="header" href="#todo" id="todo">TODO:</a></h2>
<p>This is a result of the first pass of learning the code. It is definitely
incomplete and not detailed enough. It also might be inaccurate in places.
Still, it probably provides useful first guidepost to what happens in there.</p>
<ul>
<li>What exactly does it link to and how is that published and consumed by
following stages of compilation?</li>
<li>Who calls it and how it is actually used.</li>
<li>Is it a pass and then the result is only used, or can it be computed
incrementally (e.g. for RLS)?</li>
<li>The overall strategy description is a bit vague.</li>
<li>Where does the name <code>Rib</code> come from?</li>
<li>Does this thing have its own tests, or is it tested only as part of some e2e
testing?</li>
</ul>
<h3><a class="header" href="#the-test-attribute" id="the-test-attribute">The <code>#[test]</code> attribute</a></h3>
<p>Today, rust programmers rely on a built in attribute called <code>#[test]</code>. All
you have to do is mark a function as a test and include some asserts like so:</p>
<pre><code class="language-rust ignore">#[test]
fn my_test() {
    assert!(2+2 == 4);
}
</code></pre>
<p>When this program is compiled using <code>rustc --test</code> or <code>cargo test</code>, it will
produce an executable that can run this, and any other test function. This
method of testing allows tests to live alongside code in an organic way. You
can even put tests inside private modules:</p>
<pre><code class="language-rust ignore">mod my_priv_mod {
    fn my_priv_func() -&gt; bool {}

    #[test]
    fn test_priv_func() {
        assert!(my_priv_func());
    }
}
</code></pre>
<p>Private items can thus be easily tested without worrying about how to expose
them to any sort of external testing apparatus. This is key to the
ergonomics of testing in Rust. Semantically, however, it's rather odd.
How does any sort of <code>main</code> function invoke these tests if they're not visible?
What exactly is <code>rustc --test</code> doing?</p>
<p><code>#[test]</code> is implemented as a syntactic transformation inside the compiler's
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_ast"><code>librustc_ast</code> crate</a>. Essentially, it's a fancy macro, that
rewrites the crate in 3 steps:</p>
<h4><a class="header" href="#step-1-re-exporting" id="step-1-re-exporting">Step 1: Re-Exporting</a></h4>
<p>As mentioned earlier, tests can exist inside private modules, so we need a
way of exposing them to the main function, without breaking any existing
code. To that end, <code>librustc_ast</code> will create local modules called
<code>__test_reexports</code> that recursively reexport tests. This expansion translates
the above example into:</p>
<pre><code class="language-rust ignore">mod my_priv_mod {
    fn my_priv_func() -&gt; bool {}

    pub fn test_priv_func() {
        assert!(my_priv_func());
    }

    pub mod __test_reexports {
        pub use super::test_priv_func;
    }
}
</code></pre>
<p>Now, our test can be accessed as
<code>my_priv_mod::__test_reexports::test_priv_func</code>. For deeper module
structures, <code>__test_reexports</code> will reexport modules that contain tests, so a
test at <code>a::b::my_test</code> becomes
<code>a::__test_reexports::b::__test_reexports::my_test</code>. While this process seems
pretty safe, what happens if there is an existing <code>__test_reexports</code> module?
The answer: nothing.</p>
<p>To explain, we need to understand <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html">how the AST represents
identifiers</a>. The name of every function, variable, module, etc. is
not stored as a string, but rather as an opaque <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html">Symbol</a> which is
essentially an ID number for each identifier. The compiler keeps a separate
hashtable that allows us to recover the human-readable name of a Symbol when
necessary (such as when printing a syntax error). When the compiler generates
the <code>__test_reexports</code> module, it generates a new Symbol for the identifier,
so while the compiler-generated <code>__test_reexports</code> may share a name with your
hand-written one, it will not share a Symbol. This technique prevents name
collision during code generation and is the foundation of Rust's macro
hygiene.</p>
<h4><a class="header" href="#step-2-harness-generation" id="step-2-harness-generation">Step 2: Harness Generation</a></h4>
<p>Now that our tests are accessible from the root of our crate, we need to do
something with them. <code>librustc_ast</code> generates a module like so:</p>
<pre><code class="language-rust ignore">#[main]
pub fn main() {
    extern crate test;
    test::test_main_static(&amp;[&amp;path::to::test1, /*...*/]);
}
</code></pre>
<p>where <code>path::to::test1</code> is a constant of type <code>test::TestDescAndFn</code>.</p>
<p>While this transformation is simple, it gives us a lot of insight into how
tests are actually run. The tests are aggregated into an array and passed to
a test runner called <code>test_main_static</code>. We'll come back to exactly what
<code>TestDescAndFn</code> is, but for now, the key takeaway is that there is a crate
called <a href="https://doc.rust-lang.org/test/index.html"><code>test</code></a> that is part of Rust core, that implements all of the
runtime for testing. <code>test</code>'s interface is unstable, so the only stable way
to interact with it is through the <code>#[test]</code> macro.</p>
<h4><a class="header" href="#step-3-test-object-generation" id="step-3-test-object-generation">Step 3: Test Object Generation</a></h4>
<p>If you've written tests in Rust before, you may be familiar with some of the
optional attributes available on test functions. For example, a test can be
annotated with <code>#[should_panic]</code> if we expect the test to cause a panic. It
looks something like this:</p>
<pre><code class="language-rust ignore">#[test]
#[should_panic]
fn foo() {
    panic!(&quot;intentional&quot;);
}
</code></pre>
<p>This means our tests are more than just simple functions, they have
configuration information as well. <code>test</code> encodes this configuration data
into a struct called <a href="https://doc.rust-lang.org/test/struct.TestDesc.html"><code>TestDesc</code></a>. For each test function in a
crate, <code>librustc_ast</code> will parse its attributes and generate a <code>TestDesc</code>
instance. It then combines the <code>TestDesc</code> and test function into the
predictably named <code>TestDescAndFn</code> struct, that <code>test_main_static</code> operates
on. For a given test, the generated <code>TestDescAndFn</code> instance looks like so:</p>
<pre><code class="language-rust ignore">self::test::TestDescAndFn{
  desc: self::test::TestDesc{
    name: self::test::StaticTestName(&quot;foo&quot;),
    ignore: false,
    should_panic: self::test::ShouldPanic::Yes,
    allow_fail: false,
  },
  testfn: self::test::StaticTestFn(||
    self::test::assert_test_result(::crate::__test_reexports::foo())),
}
</code></pre>
<p>Once we've constructed an array of these test objects, they're passed to the
test runner via the harness generated in step 2.</p>
<h3><a class="header" href="#inspecting-the-generated-code" id="inspecting-the-generated-code">Inspecting the generated code</a></h3>
<p>On nightly rust, there's an unstable flag called <code>unpretty</code> that you can use
to print out the module source after macro expansion:</p>
<pre><code class="language-bash">$ rustc my_mod.rs -Z unpretty=hir
</code></pre>
<h3><a class="header" href="#panicking-in-rust" id="panicking-in-rust">Panicking in rust</a></h3>
<h4><a class="header" href="#step-1-invocation-of-the-panic-macro" id="step-1-invocation-of-the-panic-macro">Step 1: Invocation of the <code>panic!</code> macro.</a></h4>
<p>There are actually two panic macros - one defined in <code>libcore</code>, and one defined in <code>libstd</code>.
This is due to the fact that code in <code>libcore</code> can panic. <code>libcore</code> is built before <code>libstd</code>,
but we want panics to use the same machinery at runtime, whether they originate in <code>libcore</code>
or <code>libstd</code>.</p>
<h5><a class="header" href="#libcore-definition-of-panic" id="libcore-definition-of-panic">libcore definition of panic!</a></h5>
<p>The <code>libcore</code> <code>panic!</code> macro eventually makes the following call (in <code>src/libcore/panicking.rs</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call
extern &quot;Rust&quot; {
    #[lang = &quot;panic_impl&quot;]
    fn panic_impl(pi: &amp;PanicInfo&lt;'_&gt;) -&gt; !;
}

let pi = PanicInfo::internal_constructor(Some(&amp;fmt), location);
unsafe { panic_impl(&amp;pi) }
<span class="boring">}
</span></code></pre></pre>
<p>Actually resolving this goes through several layers of indirection:</p>
<ol>
<li>
<p>In <code>src/librustc_middle/middle/weak_lang_items.rs</code>, <code>panic_impl</code> is declared as 'weak lang item',
with the symbol <code>rust_begin_unwind</code>. This is used in <code>librustc_typeck/collect.rs</code>
to set the actual symbol name to <code>rust_begin_unwind</code>.</p>
<p>Note that <code>panic_impl</code> is declared in an <code>extern &quot;Rust&quot;</code> block,
which means that libcore will attempt to call a foreign symbol called <code>rust_begin_unwind</code>
(to be resolved at link time)</p>
</li>
<li>
<p>In <code>src/libstd/panicking.rs</code>, we have this definition:</p>
</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Entry point of panic from the libcore crate.
#[cfg(not(test))]
#[panic_handler]
#[unwind(allowed)]
pub fn begin_panic_handler(info: &amp;PanicInfo&lt;'_&gt;) -&gt; ! {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The special <code>panic_handler</code> attribute is resolved via <code>src/librustc_middle/middle/lang_items</code>.
The <code>extract</code> function converts the <code>panic_handler</code> attribute to a <code>panic_impl</code> lang item.</p>
<p>Now, we have a matching <code>panic_handler</code> lang item in the <code>libstd</code>. This function goes
through the same process as the <code>extern { fn panic_impl }</code> definition in <code>libcore</code>, ending
up with a symbol name of <code>rust_begin_unwind</code>. At link time, the symbol reference in <code>libcore</code>
will be resolved to the definition of <code>libstd</code> (the function called <code>begin_panic_handler</code> in the
Rust source).</p>
<p>Thus, control flow will pass from libcore to std at runtime. This allows panics from <code>libcore</code>
to go through the same infrastructure that other panics use (panic hooks, unwinding, etc)</p>
<h5><a class="header" href="#libstd-implementation-of-panic" id="libstd-implementation-of-panic">libstd implementation of panic!</a></h5>
<p>This is where the actual panic-related logic begins. In <code>src/libstd/panicking.rs</code>,
control passes to <code>rust_panic_with_hook</code>. This method is responsible
for invoking the global panic hook, and checking for double panics. Finally,
we call <code>__rust_start_panic</code>, which is provided by the panic runtime.</p>
<p>The call to <code>__rust_start_panic</code> is very weird - it is passed a <code>*mut &amp;mut dyn BoxMeUp</code>,
converted to an <code>usize</code>. Let's break this type down:</p>
<ol>
<li>
<p><code>BoxMeUp</code> is an internal trait. It is implemented for <code>PanicPayload</code>
(a wrapper around the user-supplied payload type), and has a method
<code>fn box_me_up(&amp;mut self) -&gt; *mut (dyn Any + Send)</code>.
This method takes the user-provided payload (<code>T: Any + Send</code>),
boxes it, and converts the box to a raw pointer.</p>
</li>
<li>
<p>When we call <code>__rust_start_panic</code>, we have an <code>&amp;mut dyn BoxMeUp</code>.
However, this is a fat pointer (twice the size of a <code>usize</code>).
To pass this to the panic runtime across an FFI boundary, we take a mutable
reference <em>to this mutable reference</em> (<code>&amp;mut &amp;mut dyn BoxMeUp</code>), and convert it to a raw pointer
(<code>*mut &amp;mut dyn BoxMeUp</code>). The outer raw pointer is a thin pointer, since it points to a <code>Sized</code>
type (a mutable reference). Therefore, we can convert this thin pointer into a <code>usize</code>, which
is suitable for passing across an FFI boundary.</p>
</li>
</ol>
<p>Finally, we call <code>__rust_start_panic</code> with this <code>usize</code>. We have now entered the panic runtime.</p>
<h4><a class="header" href="#step-2-the-panic-runtime" id="step-2-the-panic-runtime">Step 2: The panic runtime</a></h4>
<p>Rust provides two panic runtimes: <code>libpanic_abort</code> and <code>libpanic_unwind</code>. The user chooses
between them at build time via their <code>Cargo.toml</code></p>
<p><code>libpanic_abort</code> is extremely simple: its implementation of <code>__rust_start_panic</code> just aborts,
as you would expect.</p>
<p><code>libpanic_unwind</code> is the more interesting case. </p>
<p>In its implementation of <code>__rust_start_panic</code>, we take the <code>usize</code>, convert
it back to a <code>*mut &amp;mut dyn BoxMeUp</code>, dereference it, and call <code>box_me_up</code>
on the <code>&amp;mut dyn BoxMeUp</code>. At this point, we have a raw pointer to the payload
itself (a <code>*mut (dyn Send + Any)</code>): that is, a raw pointer to the actual value
provided by the user who called <code>panic!</code>.</p>
<p>At this point, the platform-independent code ends. We now call into
platform-specific unwinding logic (e.g <code>libunwind</code>). This code is
responsible for unwinding the stack, running any 'landing pads' associated
with each frame (currently, running destructors), and transferring control
to the <code>catch_unwind</code> frame.</p>
<p>Note that all panics either abort the process or get caught by some call to <code>catch_unwind</code>:
in <code>src/libstd/rt.rs</code>, the call to the user-provided <code>main</code> function is wrapped in <code>catch_unwind</code>.</p>
<h1><a class="header" href="#ast-validation" id="ast-validation">AST Validation</a></h1>
<p>AST validation is the process of checking various correctness properties about
the AST after macro expansion.</p>
<p><strong>TODO</strong>: write this chapter.</p>
<h1><a class="header" href="#feature-gate-checking" id="feature-gate-checking">Feature Gate Checking</a></h1>
<p><strong>TODO</strong>: this chapter</p>
<h1><a class="header" href="#the-hir" id="the-hir">The HIR</a></h1>
<p>The HIR – &quot;High-Level Intermediate Representation&quot; – is the primary IR used
in most of rustc. It is a compiler-friendly representation of the abstract
syntax tree (AST) that is generated after parsing, macro expansion, and name
resolution (see <a href="./lowering.html">Lowering</a> for how the HIR is created).
Many parts of HIR resemble Rust surface syntax quite closely, with
the exception that some of Rust's expression forms have been desugared away.
For example, <code>for</code> loops are converted into a <code>loop</code> and do not appear in
the HIR. This makes HIR more amenable to analysis than a normal AST.</p>
<p>This chapter covers the main concepts of the HIR.</p>
<p>You can view the HIR representation of your code by passing the
<code>-Zunpretty=hir-tree</code> flag to rustc:</p>
<pre><code class="language-bash">cargo rustc -- -Zunpretty=hir-tree
</code></pre>
<h3><a class="header" href="#out-of-band-storage-and-the-crate-type" id="out-of-band-storage-and-the-crate-type">Out-of-band storage and the <code>Crate</code> type</a></h3>
<p>The top-level data-structure in the HIR is the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Crate.html"><code>Crate</code></a>, which stores
the contents of the crate currently being compiled (we only ever
construct HIR for the current crate). Whereas in the AST the crate
data structure basically just contains the root module, the HIR
<code>Crate</code> structure contains a number of maps and other things that
serve to organize the content of the crate for easier access.</p>
<p>For example, the contents of individual items (e.g. modules,
functions, traits, impls, etc) in the HIR are not immediately
accessible in the parents. So, for example, if there is a module item
<code>foo</code> containing a function <code>bar()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod foo {
    fn bar() { }
}
<span class="boring">}
</span></code></pre></pre>
<p>then in the HIR the representation of module <code>foo</code> (the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Mod.html"><code>Mod</code></a>
struct) would only have the <strong><code>ItemId</code></strong> <code>I</code> of <code>bar()</code>. To get the
details of the function <code>bar()</code>, we would lookup <code>I</code> in the
<code>items</code> map.</p>
<p>One nice result from this representation is that one can iterate
over all items in the crate by iterating over the key-value pairs
in these maps (without the need to trawl through the whole HIR).
There are similar maps for things like trait items and impl items,
as well as &quot;bodies&quot; (explained below).</p>
<p>The other reason to set up the representation this way is for better
integration with incremental compilation. This way, if you gain access
to an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Item.html"><code>&amp;rustc_hir::Item</code></a> (e.g. for the mod <code>foo</code>), you do not immediately
gain access to the contents of the function <code>bar()</code>. Instead, you only
gain access to the <strong>id</strong> for <code>bar()</code>, and you must invoke some
function to lookup the contents of <code>bar()</code> given its id; this gives
the compiler a chance to observe that you accessed the data for
<code>bar()</code>, and then record the dependency.</p>
<p><a name="hir-id"></a></p>
<h3><a class="header" href="#identifiers-in-the-hir" id="identifiers-in-the-hir">Identifiers in the HIR</a></h3>
<p>Most of the code that has to deal with things in HIR tends not to
carry around references into the HIR, but rather to carry around
<em>identifier numbers</em> (or just &quot;ids&quot;). Right now, you will find four
sorts of identifiers in active use:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html"><code>DefId</code></a>, which primarily names &quot;definitions&quot; or top-level items.
<ul>
<li>You can think of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html"><code>DefId</code></a> as being shorthand for a very explicit
and complete path, like <code>std::collections::HashMap</code>. However,
these paths are able to name things that are not nameable in
normal Rust (e.g. impls), and they also include extra information
about the crate (such as its version number, as two versions of
the same crate can co-exist).</li>
<li>A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html"><code>DefId</code></a> really consists of two parts, a <code>CrateNum</code> (which
identifies the crate) and a <code>DefIndex</code> (which indexes into a list
of items that is maintained per crate).</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/hir_id/struct.HirId.html"><code>HirId</code></a>, which combines the index of a particular item with an
offset within that item.
<ul>
<li>the key point of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/hir_id/struct.HirId.html"><code>HirId</code></a> is that it is <em>relative</em> to some item
(which is named via a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html"><code>DefId</code></a>).</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.BodyId.html"><code>BodyId</code></a>, this is an identifier that refers to a specific
body (definition of a function or constant) in the crate. It is currently
effectively a &quot;newtype'd&quot; <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/hir_id/struct.HirId.html"><code>HirId</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/node_id/struct.NodeId.html"><code>NodeId</code></a>, which is an absolute id that identifies a single node in the HIR
tree.
<ul>
<li>While these are still in common use, <strong>they are being slowly phased out</strong>.</li>
<li>Since they are absolute within the crate, adding a new node anywhere in the
tree causes the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/node_id/struct.NodeId.html"><code>NodeId</code></a>s of all subsequent code in the crate to change.
This is terrible for incremental compilation, as you can perhaps imagine.</li>
</ul>
</li>
</ul>
<p>We also have an internal map to go from <code>DefId</code> to what’s called &quot;Def path&quot;. &quot;Def path&quot; is like a
module path but a bit more rich. For example, it may be <code>crate::foo::MyStruct</code> that identifies
this definition uniquely. It’s a bit different than a module path because it might include a type
parameter <code>T</code>, which you can't write in normal rust, like <code>crate::foo::MyStruct::T</code>. These are used
in incremental compilation.</p>
<h3><a class="header" href="#the-hir-map" id="the-hir-map">The HIR Map</a></h3>
<p>Most of the time when you are working with the HIR, you will do so via
the <strong>HIR Map</strong>, accessible in the tcx via <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.GlobalCtxt.html#structfield.hir_map"><code>tcx.hir_map</code></a> (and defined in
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/index.html"><code>hir::map</code></a> module). The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html">HIR map</a> contains a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#methods">number of methods</a> to
convert between IDs of various kinds and to lookup data associated
with an HIR node.</p>
<p>For example, if you have a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html"><code>DefId</code></a>, and you would like to convert it
to a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/node_id/struct.NodeId.html"><code>NodeId</code></a>, you can use
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#method.as_local_node_id"><code>tcx.hir.as_local_node_id(def_id)</code></a>. This returns
an <code>Option&lt;NodeId&gt;</code> – this will be <code>None</code> if the def-id refers to
something outside of the current crate (since then it has no HIR
node), but otherwise returns <code>Some(n)</code> where <code>n</code> is the node-id of the
definition.</p>
<p>Similarly, you can use <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#method.find"><code>tcx.hir.find(n)</code></a> to lookup the node for a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/node_id/struct.NodeId.html"><code>NodeId</code></a>. This returns a <code>Option&lt;Node&lt;'tcx&gt;&gt;</code>, where <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.Node.html"><code>Node</code></a> is an enum
defined in the map; by matching on this you can find out what sort of
node the node-id referred to and also get a pointer to the data
itself. Often, you know what sort of node <code>n</code> is – e.g. if you know
that <code>n</code> must be some HIR expression, you can do
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#method.expect_expr"><code>tcx.hir.expect_expr(n)</code></a>, which will extract and return the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Expr.html"><code>&amp;hir::Expr</code></a>, panicking if <code>n</code> is not in fact an expression.</p>
<p>Finally, you can use the HIR map to find the parents of nodes, via
calls like <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#method.get_parent_node"><code>tcx.hir.get_parent_node(n)</code></a>.</p>
<h3><a class="header" href="#hir-bodies" id="hir-bodies">HIR Bodies</a></h3>
<p>A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Body.html"><code>rustc_hir::Body</code></a> represents some kind of executable code, such as the body
of a function/closure or the definition of a constant. Bodies are
associated with an <strong>owner</strong>, which is typically some kind of item
(e.g. an <code>fn()</code> or <code>const</code>), but could also be a closure expression
(e.g. <code>|x, y| x + y</code>). You can use the HIR map to find the body
associated with a given def-id (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#method.maybe_body_owned_by"><code>maybe_body_owned_by</code></a>) or to find
the owner of a body (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/map/struct.Map.html#method.body_owner_def_id"><code>body_owner_def_id</code></a>).</p>
<h1><a class="header" href="#lowering" id="lowering">Lowering</a></h1>
<p>The lowering step converts AST to <a href="hir.html">HIR</a>.
This means many structures are removed if they are irrelevant
for type analysis or similar syntax agnostic analyses. Examples
of such structures include but are not limited to</p>
<ul>
<li>Parenthesis
<ul>
<li>Removed without replacement, the tree structure makes order explicit</li>
</ul>
</li>
<li><code>for</code> loops and <code>while (let)</code> loops
<ul>
<li>Converted to <code>loop</code> + <code>match</code> and some <code>let</code> bindings</li>
</ul>
</li>
<li><code>if let</code>
<ul>
<li>Converted to <code>match</code></li>
</ul>
</li>
<li>Universal <code>impl Trait</code>
<ul>
<li>Converted to generic arguments
(but with some flags, to know that the user didn't write them)</li>
</ul>
</li>
<li>Existential <code>impl Trait</code>
<ul>
<li>Converted to a virtual <code>existential type</code> declaration</li>
</ul>
</li>
</ul>
<p>Lowering needs to uphold several invariants in order to not trigger the
sanity checks in <code>src/librustc_middle/hir/map/hir_id_validator.rs</code>:</p>
<ol>
<li>A <code>HirId</code> must be used if created. So if you use the <code>lower_node_id</code>,
you <em>must</em> use the resulting <code>NodeId</code> or <code>HirId</code> (either is fine, since
any <code>NodeId</code>s in the <code>HIR</code> are checked for existing <code>HirId</code>s)</li>
<li>Lowering a <code>HirId</code> must be done in the scope of the <em>owning</em> item.
This means you need to use <code>with_hir_id_owner</code> if you are creating parts
of an item other than the one being currently lowered. This happens for
example during the lowering of existential <code>impl Trait</code></li>
<li>A <code>NodeId</code> that will be placed into a HIR structure must be lowered,
even if its <code>HirId</code> is unused. Calling
<code>let _ = self.lower_node_id(node_id);</code> is perfectly legitimate.</li>
<li>If you are creating new nodes that didn't exist in the <code>AST</code>, you <em>must</em>
create new ids for them. This is done by calling the <code>next_id</code> method,
which produces both a new <code>NodeId</code> as well as automatically lowering it
for you so you also get the <code>HirId</code>.</li>
</ol>
<p>If you are creating new <code>DefId</code>s, since each <code>DefId</code> needs to have a
corresponding <code>NodeId</code>, it is advisable to add these <code>NodeId</code>s to the
<code>AST</code> so you don't have to generate new ones during lowering. This has
the advantage of creating a way to find the <code>DefId</code> of something via its
<code>NodeId</code>. If lowering needs this <code>DefId</code> in multiple places, you can't
generate a new <code>NodeId</code> in all those places because you'd also get a new
<code>DefId</code> then. With a <code>NodeId</code> from the <code>AST</code> this is not an issue.</p>
<p>Having the <code>NodeId</code> also allows the <code>DefCollector</code> to generate the <code>DefId</code>s
instead of lowering having to do it on the fly. Centralizing the <code>DefId</code>
generation in one place makes it easier to refactor and reason about.</p>
<h1><a class="header" href="#hir-debugging" id="hir-debugging">HIR Debugging</a></h1>
<p>The <code>-Zunpretty=hir-tree</code> flag will dump out the HIR.</p>
<p>If you are trying to correlate <code>NodeId</code>s or <code>DefId</code>s with source code, the
<code>--pretty expanded,identified</code> flag may be useful.</p>
<p>TODO: anything else?</p>
<h1><a class="header" href="#the-mir-mid-level-ir" id="the-mir-mid-level-ir">The MIR (Mid-level IR)</a></h1>
<p>MIR is Rust's <em>Mid-level Intermediate Representation</em>. It is
constructed from <a href="mir/../hir.html">HIR</a>. MIR was introduced in
<a href="https://rust-lang.github.io/rfcs/1211-mir.html">RFC 1211</a>. It is a radically simplified form of Rust that is used for
certain flow-sensitive safety checks – notably the borrow checker! –
and also for optimization and code generation.</p>
<p>If you'd like a very high-level introduction to MIR, as well as some
of the compiler concepts that it relies on (such as control-flow
graphs and desugaring), you may enjoy the
<a href="https://blog.rust-lang.org/2016/04/19/MIR.html">rust-lang blog post that introduced MIR</a>.</p>
<h2><a class="header" href="#introduction-to-mir" id="introduction-to-mir">Introduction to MIR</a></h2>
<p>MIR is defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_middle/mir"><code>src/librustc_middle/mir/</code></a> module, but much of the code
that manipulates it is found in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir"><code>src/librustc_mir</code></a>.</p>
<p>Some of the key characteristics of MIR are:</p>
<ul>
<li>It is based on a <a href="mir/../appendix/background.html#cfg">control-flow graph</a>.</li>
<li>It does not have nested expressions.</li>
<li>All types in MIR are fully explicit.</li>
</ul>
<h2><a class="header" href="#key-mir-vocabulary" id="key-mir-vocabulary">Key MIR vocabulary</a></h2>
<p>This section introduces the key concepts of MIR, summarized here:</p>
<ul>
<li><strong>Basic blocks</strong>: units of the control-flow graph, consisting of:
<ul>
<li><strong>statements:</strong> actions with one successor</li>
<li><strong>terminators:</strong> actions with potentially multiple successors; always at
the end of a block</li>
<li>(if you're not familiar with the term <em>basic block</em>, see the <a href="mir/../appendix/background.html#cfg">background
chapter</a>)</li>
</ul>
</li>
<li><strong>Locals:</strong> Memory locations allocated on the stack (conceptually, at
least), such as function arguments, local variables, and
temporaries. These are identified by an index, written with a
leading underscore, like <code>_1</code>. There is also a special &quot;local&quot;
(<code>_0</code>) allocated to store the return value.</li>
<li><strong>Places:</strong> expressions that identify a location in memory, like <code>_1</code> or
<code>_1.f</code>.</li>
<li><strong>Rvalues:</strong> expressions that produce a value. The &quot;R&quot; stands for
the fact that these are the &quot;right-hand side&quot; of an assignment.
<ul>
<li><strong>Operands:</strong> the arguments to an rvalue, which can either be a
constant (like <code>22</code>) or a place (like <code>_1</code>).</li>
</ul>
</li>
</ul>
<p>You can get a feeling for how MIR is structed by translating simple
programs into MIR and reading the pretty printed output. In fact, the
playground makes this easy, since it supplies a MIR button that will
show you the MIR for your program. Try putting this program into play
(or <a href="https://play.rust-lang.org/?gist=30074856e62e74e91f06abd19bd72ece&amp;version=stable">clicking on this link</a>), and then clicking the &quot;MIR&quot;
button on the top:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);
}
</code></pre></pre>
<p>You should see something like:</p>
<pre><code class="language-mir">// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -&gt; () {
    ...
}
</code></pre>
<p>This is the MIR format for the <code>main</code> function.</p>
<p><strong>Variable declarations.</strong> If we drill in a bit, we'll see it begins
with a bunch of variable declarations. They look like this:</p>
<pre><code class="language-mir">let mut _0: ();                      // return place
let mut _1: std::vec::Vec&lt;i32&gt;;      // in scope 0 at src/main.rs:2:9: 2:16
let mut _2: ();
let mut _3: &amp;mut std::vec::Vec&lt;i32&gt;;
let mut _4: ();
let mut _5: &amp;mut std::vec::Vec&lt;i32&gt;;
</code></pre>
<p>You can see that variables in MIR don't have names, they have indices,
like <code>_0</code> or <code>_1</code>.  We also intermingle the user's variables (e.g.,
<code>_1</code>) with temporary values (e.g., <code>_2</code> or <code>_3</code>). You can tell apart
user-defined variables because they have debuginfo associated to them (see below).</p>
<p><strong>User variable debuginfo.</strong> Below the variable declarations, we find the only
hint that <code>_1</code> represents a user variable:</p>
<pre><code class="language-mir">scope 1 {
    debug vec =&gt; _1;                 // in scope 1 at src/main.rs:2:9: 2:16
}
</code></pre>
<p>Each <code>debug &lt;Name&gt; =&gt; &lt;Place&gt;;</code> annotation describes a named user variable,
and where (i.e. the place) a debugger can find the data of that variable.
Here the mapping is trivial, but optimizations may complicate the place,
or lead to multiple user variables sharing the same place.
Additionally, closure captures are described using the same system, and so
they're complicated even without optimizations, e.g.: <code>debug x =&gt; (*((*_1).0: &amp;T));</code>.</p>
<p>The &quot;scope&quot; blocks (e.g., <code>scope 1 { .. }</code>) describe the lexical structure of
the source program (which names were in scope when), so any part of the program
annotated with <code>// in scope 0</code> would be missing <code>vec</code>, if you were stepping
through the code in a debugger, for example.</p>
<p><strong>Basic blocks.</strong> Reading further, we see our first <strong>basic block</strong> (naturally
it may look slightly different when you view it, and I am ignoring some of the
comments):</p>
<pre><code class="language-mir">bb0: {
    StorageLive(_1);
    _1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
}
</code></pre>
<p>A basic block is defined by a series of <strong>statements</strong> and a final
<strong>terminator</strong>.  In this case, there is one statement:</p>
<pre><code class="language-mir">StorageLive(_1);
</code></pre>
<p>This statement indicates that the variable <code>_1</code> is &quot;live&quot;, meaning
that it may be used later – this will persist until we encounter a
<code>StorageDead(_1)</code> statement, which indicates that the variable <code>_1</code> is
done being used. These &quot;storage statements&quot; are used by LLVM to
allocate stack space.</p>
<p>The <strong>terminator</strong> of the block <code>bb0</code> is the call to <code>Vec::new</code>:</p>
<pre><code class="language-mir">_1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
</code></pre>
<p>Terminators are different from statements because they can have more
than one successor – that is, control may flow to different
places. Function calls like the call to <code>Vec::new</code> are always
terminators because of the possibility of unwinding, although in the
case of <code>Vec::new</code> we are able to see that indeed unwinding is not
possible, and hence we list only one successor block, <code>bb2</code>.</p>
<p>If we look ahead to <code>bb2</code>, we will see it looks like this:</p>
<pre><code class="language-mir">bb2: {
    StorageLive(_3);
    _3 = &amp;mut _1;
    _2 = const &lt;std::vec::Vec&lt;T&gt;&gt;::push(move _3, const 1i32) -&gt; [return: bb3, unwind: bb4];
}
</code></pre>
<p>Here there are two statements: another <code>StorageLive</code>, introducing the <code>_3</code>
temporary, and then an assignment:</p>
<pre><code class="language-mir">_3 = &amp;mut _1;
</code></pre>
<p>Assignments in general have the form:</p>
<pre><code class="language-text">&lt;Place&gt; = &lt;Rvalue&gt;
</code></pre>
<p>A place is an expression like <code>_3</code>, <code>_3.f</code> or <code>*_3</code> – it denotes a
location in memory.  An <strong>Rvalue</strong> is an expression that creates a
value: in this case, the rvalue is a mutable borrow expression, which
looks like <code>&amp;mut &lt;Place&gt;</code>. So we can kind of define a grammar for
rvalues like so:</p>
<pre><code class="language-text">&lt;Rvalue&gt;  = &amp; (mut)? &lt;Place&gt;
          | &lt;Operand&gt; + &lt;Operand&gt;
          | &lt;Operand&gt; - &lt;Operand&gt;
          | ...

&lt;Operand&gt; = Constant
          | copy Place
          | move Place
</code></pre>
<p>As you can see from this grammar, rvalues cannot be nested – they can
only reference places and constants. Moreover, when you use a place,
we indicate whether we are <strong>copying it</strong> (which requires that the
place have a type <code>T</code> where <code>T: Copy</code>) or <strong>moving it</strong> (which works
for a place of any type). So, for example, if we had the expression <code>x = a + b + c</code> in Rust, that would get compiled to two statements and a
temporary:</p>
<pre><code class="language-mir">TMP1 = a + b
x = TMP1 + c
</code></pre>
<p>(<a href="https://play.rust-lang.org/?gist=1751196d63b2a71f8208119e59d8a5b6&amp;version=stable">Try it and see</a>, though you may want to do release mode to skip
over the overflow checks.)</p>
<h2><a class="header" href="#mir-data-types" id="mir-data-types">MIR data types</a></h2>
<p>The MIR data types are defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_middle/mir"><code>src/librustc_middle/mir/</code></a>
module.  Each of the key concepts mentioned in the previous section
maps in a fairly straightforward way to a Rust type.</p>
<p>The main MIR data type is <code>Mir</code>. It contains the data for a single
function (along with sub-instances of Mir for &quot;promoted constants&quot;,
but <a href="mir/index.html#promoted">you can read about those below</a>).</p>
<ul>
<li><strong>Basic blocks</strong>: The basic blocks are stored in the field
<code>basic_blocks</code>; this is a vector of <code>BasicBlockData</code>
structures. Nobody ever references a basic block directly: instead,
we pass around <code>BasicBlock</code> values, which are
<a href="mir/../appendix/glossary.html#newtype">newtype'd</a> indices into this vector.</li>
<li><strong>Statements</strong> are represented by the type <code>Statement</code>.</li>
<li><strong>Terminators</strong> are represented by the <code>Terminator</code>.</li>
<li><strong>Locals</strong> are represented by a <a href="mir/../appendix/glossary.html#newtype">newtype'd</a> index type <code>Local</code>. The
data for a local variable is found in the <code>Mir</code> (the <code>local_decls</code>
vector). There is also a special constant <code>RETURN_PLACE</code> identifying
the special &quot;local&quot; representing the return value.</li>
<li><strong>Places</strong> are identified by the enum <code>Place</code>. There are a few variants:
<ul>
<li>Local variables like <code>_1</code></li>
<li>Static variables <code>FOO</code></li>
<li><strong>Projections</strong>, which are fields or other things that &quot;project
out&quot; from a base place. So e.g. the place <code>_1.f</code> is a projection,
with <code>f</code> being the &quot;projection element and <code>_1</code> being the base
path. <code>*_1</code> is also a projection, with the <code>*</code> being represented
by the <code>ProjectionElem::Deref</code> element.</li>
</ul>
</li>
<li><strong>Rvalues</strong> are represented by the enum <code>Rvalue</code>.</li>
<li><strong>Operands</strong> are represented by the enum <code>Operand</code>.</li>
</ul>
<h2><a class="header" href="#representing-constants" id="representing-constants">Representing constants</a></h2>
<p><em>to be written</em></p>
<p><a name="promoted"></a></p>
<h3><a class="header" href="#promoted-constants" id="promoted-constants">Promoted constants</a></h3>
<p><em>to be written</em></p>
<h1><a class="header" href="#hair-and-mir-construction" id="hair-and-mir-construction">HAIR and MIR construction</a></h1>
<p>The lowering of <a href="mir/../hir.html">HIR</a> to <a href="mir/./index.html">MIR</a> occurs for the following (probably incomplete)
list of items:</p>
<ul>
<li>Function and Closure bodies</li>
<li>Initializers of <code>static</code> and <code>const</code> items</li>
<li>Initializers of enum discriminants</li>
<li>Glue and Shims of any kind
<ul>
<li>Tuple struct initializer functions</li>
<li>Drop code (the <code>Drop::drop</code> function is not called directly)</li>
<li>Drop implementations of types without an explicit <code>Drop</code> implementation</li>
</ul>
</li>
</ul>
<p>The lowering is triggered by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/build/fn.mir_built.html"><code>mir_built</code></a> query.
There is an intermediate representation
between <a href="mir/../hir.html">HIR</a> and <a href="mir/./index.html">MIR</a> called the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/index.html">HAIR</a> that is only used during the lowering.
The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/index.html">HAIR</a>'s most important feature is that the various adjustments (which happen
without explicit syntax) like coercions, autoderef, autoref and overloaded method
calls have become explicit casts, deref operations, reference expressions or
concrete function calls.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/index.html">HAIR</a> has datatypes that mirror the <a href="mir/../hir.html">HIR</a> datatypes, but instead of e.g. <code>-x</code>
being a <code>hair::ExprKind::Neg(hair::Expr)</code> it is a <code>hair::ExprKind::Neg(hir::Expr)</code>.
This shallowness enables the <code>HAIR</code> to represent all datatypes that <a href="mir/../hir.html">HIR</a> has, but
without having to create an in-memory copy of the entire <a href="mir/../hir.html">HIR</a>.
<a href="mir/./index.html">MIR</a> lowering will first convert the topmost expression from
<a href="mir/../hir.html">HIR</a> to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/index.html">HAIR</a> (in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/cx/expr/index.html"><code>rustc_mir_build::hair::cx::expr</code></a>) and then process
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/index.html">HAIR</a> expressions recursively.</p>
<p>The lowering creates local variables for every argument as specified in the signature.
Next it creates local variables for every binding specified (e.g. <code>(a, b): (i32, String)</code>)
produces 3 bindings, one for the argument, and two for the bindings. Next it generates
field accesses that read the fields from the argument and writes the value to the binding
variable.</p>
<p>With this initialization out of the way, the lowering triggers a recursive call
to a function that generates the MIR for the body (a <code>Block</code> expression) and
writes the result into the <code>RETURN_PLACE</code>.</p>
<h2><a class="header" href="#unpack-all-the-things" id="unpack-all-the-things"><code>unpack!</code> all the things</a></h2>
<p>Functions that generate MIR tend to fall into one of two patterns.
First, if the function generates only statements, then it will take a
basic block as argument onto which those statements should be appended.
It can then return a result as normal:</p>
<pre><code class="language-rust ignore">fn generate_some_mir(&amp;mut self, block: BasicBlock) -&gt; ResultType {
   ...
}
</code></pre>
<p>But there are other functions that may generate new basic blocks as well.
For example, lowering an expression like <code>if foo { 22 } else { 44 }</code>
requires generating a small &quot;diamond-shaped graph&quot;.
In this case, the functions take a basic block where their code starts
and return a (potentially) new basic block where the code generation ends.
The <code>BlockAnd</code> type is used to represent this:</p>
<pre><code class="language-rust ignore">fn generate_more_mir(&amp;mut self, block: BasicBlock) -&gt; BlockAnd&lt;ResultType&gt; {
    ...
}
</code></pre>
<p>When you invoke these functions, it is common to have a local variable <code>block</code>
that is effectively a &quot;cursor&quot;. It represents the point at which we are adding new MIR.
When you invoke <code>generate_more_mir</code>, you want to update this cursor.
You can do this manually, but it's tedious:</p>
<pre><code class="language-rust ignore">let mut block;
let v = match self.generate_more_mir(..) {
    BlockAnd { block: new_block, value: v } =&gt; {
        block = new_block;
        v
    }
};
</code></pre>
<p>For this reason, we offer a macro that lets you write
<code>let v = unpack!(block = self.generate_more_mir(...))</code>.
It simply extracts the new block and overwrites the
variable <code>block</code> that you named in the <code>unpack!</code>.</p>
<h2><a class="header" href="#lowering-expressions-into-the-desired-mir" id="lowering-expressions-into-the-desired-mir">Lowering expressions into the desired MIR</a></h2>
<p>There are essentially four kinds of representations one might want of an expression:</p>
<ul>
<li><code>Place</code> refers to a (or part of a) preexisting memory location (local, static, promoted)</li>
<li><code>Rvalue</code> is something that can be assigned to a <code>Place</code></li>
<li><code>Operand</code> is an argument to e.g. a <code>+</code> operation or a function call</li>
<li>a temporary variable containing a copy of the value</li>
</ul>
<p>The following image depicts a general overview of the interactions between the
representations:</p>
<img src="mir/mir_overview.svg">
<p><a href="mir/mir_detailed.svg">Click here for a more detailed view</a></p>
<p>We start out with lowering the function body to an <code>Rvalue</code> so we can create an
assignment to <code>RETURN_PLACE</code>, This <code>Rvalue</code> lowering will in turn trigger lowering to
<code>Operand</code> for its arguments (if any). <code>Operand</code> lowering either produces a <code>const</code>
operand, or moves/copies out of a <code>Place</code>, thus triggering a <code>Place</code> lowering. An
expression being lowered to a <code>Place</code> can in turn trigger a temporary to be created
if the expression being lowered contains operations. This is where the snake bites its
own tail and we need to trigger an <code>Rvalue</code> lowering for the expression to be written
into the local.</p>
<h2><a class="header" href="#operator-lowering" id="operator-lowering">Operator lowering</a></h2>
<p>Operators on builtin types are not lowered to function calls (which would end up being
infinite recursion calls, because the trait impls just contain the operation itself
again). Instead there are <code>Rvalue</code>s for binary and unary operators and index operations.
These <code>Rvalue</code>s later get codegened to llvm primitive operations or llvm intrinsics.</p>
<p>Operators on all other types get lowered to a function call to their <code>impl</code> of the
operator's corresponding trait.</p>
<p>Regardless of the lowering kind, the arguments to the operator are lowered to <code>Operand</code>s.
This means all arguments are either constants, or refer to an already existing value
somewhere in a local or static.</p>
<h2><a class="header" href="#method-call-lowering" id="method-call-lowering">Method call lowering</a></h2>
<p>Method calls are lowered to the same <code>TerminatorKind</code> that function calls are.
In <a href="mir/./index.html">MIR</a> there is no difference between method calls and function calls anymore.</p>
<h2><a class="header" href="#conditions" id="conditions">Conditions</a></h2>
<p><code>if</code> conditions and <code>match</code> statements for <code>enum</code>s without variants with fields are
lowered to <code>TerminatorKind::SwitchInt</code>. Each possible value (so <code>0</code> and <code>1</code> for <code>if</code>
conditions) has a corresponding <code>BasicBlock</code> to which the code continues.
The argument being branched on is (again) an <code>Operand</code> representing the value of
the if condition.</p>
<h3><a class="header" href="#pattern-matching" id="pattern-matching">Pattern matching</a></h3>
<p><code>match</code> statements for <code>enum</code>s with variants that have fields are lowered to
<code>TerminatorKind::SwitchInt</code>, too, but the <code>Operand</code> refers to a <code>Place</code> where the
discriminant of the value can be found. This often involves reading the discriminant
to a new temporary variable.</p>
<h2><a class="header" href="#aggregate-construction" id="aggregate-construction">Aggregate construction</a></h2>
<p>Aggregate values of any kind (e.g. structs or tuples) are built via <code>Rvalue::Aggregate</code>.
All fields are
lowered to <code>Operator</code>s. This is essentially equivalent to one assignment
statement per aggregate field plus an assignment to the discriminant in the
case of <code>enum</code>s.</p>
<h1><a class="header" href="#mir-visitor" id="mir-visitor">MIR visitor</a></h1>
<p>The MIR visitor is a convenient tool for traversing the MIR and either
looking for things or making changes to it. The visitor traits are
defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/index.html">the <code>rustc::mir::visit</code> module</a> – there are two of
them, generated via a single macro: <code>Visitor</code> (which operates on a
<code>&amp;Mir</code> and gives back shared references) and <code>MutVisitor</code> (which
operates on a <code>&amp;mut Mir</code> and gives back mutable references).</p>
<p>To implement a visitor, you have to create a type that represents
your visitor. Typically, this type wants to &quot;hang on&quot; to whatever
state you will need while processing MIR:</p>
<pre><code class="language-rust ignore">struct MyVisitor&lt;...&gt; {
    tcx: TyCtxt&lt;'tcx&gt;,
    ...
}
</code></pre>
<p>and you then implement the <code>Visitor</code> or <code>MutVisitor</code> trait for that type:</p>
<pre><code class="language-rust ignore">impl&lt;'tcx&gt; MutVisitor&lt;'tcx&gt; for NoLandingPads {
    fn visit_foo(&amp;mut self, ...) {
        ...
        self.super_foo(...);
    }
}
</code></pre>
<p>As shown above, within the impl, you can override any of the
<code>visit_foo</code> methods (e.g., <code>visit_terminator</code>) in order to write some
code that will execute whenever a <code>foo</code> is found. If you want to
recursively walk the contents of the <code>foo</code>, you then invoke the
<code>super_foo</code> method. (NB. You never want to override <code>super_foo</code>.)</p>
<p>A very simple example of a visitor can be found in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/no_landing_pads/struct.NoLandingPads.html"><code>NoLandingPads</code></a>.
That visitor doesn't even require any state: it just visits all
terminators and removes their <code>unwind</code> successors.</p>
<h2><a class="header" href="#traversal" id="traversal">Traversal</a></h2>
<p>In addition the visitor, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/traversal/index.html">the <code>rustc::mir::traversal</code> module</a>
contains useful functions for walking the MIR CFG in
<a href="https://en.wikipedia.org/wiki/Tree_traversal">different standard orders</a> (e.g. pre-order, reverse
post-order, and so forth).</p>
<h1><a class="header" href="#mir-passes" id="mir-passes">MIR passes</a></h1>
<p>If you would like to get the MIR for a function (or constant, etc),
you can use the <code>optimized_mir(def_id)</code> query. This will give you back
the final, optimized MIR. For foreign def-ids, we simply read the MIR
from the other crate's metadata. But for local def-ids, the query will
construct the MIR and then iteratively optimize it by applying a
series of passes. This section describes how those passes work and how
you can extend them.</p>
<p>To produce the <code>optimized_mir(D)</code> for a given def-id <code>D</code>, the MIR
passes through several suites of optimizations, each represented by a
query. Each suite consists of multiple optimizations and
transformations. These suites represent useful intermediate points
where we want to access the MIR for type checking or other purposes:</p>
<ul>
<li><code>mir_build(D)</code> – not a query, but this constructs the initial MIR</li>
<li><code>mir_const(D)</code> – applies some simple transformations to make MIR ready for
constant evaluation;</li>
<li><code>mir_validated(D)</code> – applies some more transformations, making MIR ready for
borrow checking;</li>
<li><code>optimized_mir(D)</code> – the final state, after all optimizations have been
performed.</li>
</ul>
<h3><a class="header" href="#implementing-and-registering-a-pass" id="implementing-and-registering-a-pass">Implementing and registering a pass</a></h3>
<p>A <code>MirPass</code> is some bit of code that processes the MIR, typically –
but not always – transforming it along the way somehow. For example,
it might perform an optimization. The <code>MirPass</code> trait itself is found
in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/">the <code>rustc_mir::transform</code> module</a>, and it
basically consists of one method, <code>run_pass</code>, that simply gets an
<code>&amp;mut Mir</code> (along with the tcx and some information about where it
came from). The MIR is therefore modified in place (which helps to
keep things efficient).</p>
<p>A good example of a basic MIR pass is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/no_landing_pads/struct.NoLandingPads.html"><code>NoLandingPads</code></a>, which walks
the MIR and removes all edges that are due to unwinding – this is
used when configured with <code>panic=abort</code>, which never unwinds. As you
can see from its source, a MIR pass is defined by first defining a
dummy type, a struct with no fields, something like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MyPass;
<span class="boring">}
</span></code></pre></pre>
<p>for which you then implement the <code>MirPass</code> trait. You can then insert
this pass into the appropriate list of passes found in a query like
<code>optimized_mir</code>, <code>mir_validated</code>, etc. (If this is an optimization, it
should go into the <code>optimized_mir</code> list.)</p>
<p>If you are writing a pass, there's a good chance that you are going to
want to use a <a href="mir/./visitor.html">MIR visitor</a>. MIR visitors are a handy way to walk all
the parts of the MIR, either to search for something or to make small
edits.</p>
<h3><a class="header" href="#stealing" id="stealing">Stealing</a></h3>
<p>The intermediate queries <code>mir_const()</code> and <code>mir_validated()</code> yield up
a <code>&amp;'tcx Steal&lt;Mir&lt;'tcx&gt;&gt;</code>, allocated using
<code>tcx.alloc_steal_mir()</code>. This indicates that the result may be
<strong>stolen</strong> by the next suite of optimizations – this is an
optimization to avoid cloning the MIR. Attempting to use a stolen
result will cause a panic in the compiler. Therefore, it is important
that you do not read directly from these intermediate queries except as
part of the MIR processing pipeline.</p>
<p>Because of this stealing mechanism, some care must also be taken to
ensure that, before the MIR at a particular phase in the processing
pipeline is stolen, anyone who may want to read from it has already
done so. Concretely, this means that if you have some query <code>foo(D)</code>
that wants to access the result of <code>mir_const(D)</code> or
<code>mir_validated(D)</code>, you need to have the successor pass &quot;force&quot;
<code>foo(D)</code> using <code>ty::queries::foo::force(...)</code>. This will force a query
to execute even though you don't directly require its result.</p>
<p>As an example, consider MIR const qualification. It wants to read the
result produced by the <code>mir_const()</code> suite. However, that result will
be <strong>stolen</strong> by the <code>mir_validated()</code> suite. If nothing was done,
then <code>mir_const_qualif(D)</code> would succeed if it came before
<code>mir_validated(D)</code>, but fail otherwise. Therefore, <code>mir_validated(D)</code>
will <strong>force</strong> <code>mir_const_qualif</code> before it actually steals, thus
ensuring that the reads have already happened (remember that
<a href="mir/../query.html">queries are memoized</a>, so executing a query twice
simply loads from a cache the second time):</p>
<pre><code class="language-text">mir_const(D) --read-by--&gt; mir_const_qualif(D)
     |                       ^
  stolen-by                  |
     |                    (forces)
     v                       |
mir_validated(D) ------------+
</code></pre>
<p>This mechanism is a bit dodgy. There is a discussion of more elegant
alternatives in <a href="https://github.com/rust-lang/rust/issues/41710">rust-lang/rust#41710</a>.</p>
<h1><a class="header" href="#closure-expansion-in-rustc" id="closure-expansion-in-rustc">Closure Expansion in rustc</a></h1>
<p>This section describes how rustc handles closures. Closures in Rust are
effectively &quot;desugared&quot; into structs that contain the values they use (or
references to the values they use) from their creator's stack frame. rustc has
the job of figuring out which values a closure uses and how, so it can decide
whether to capture a given variable by shared reference, mutable reference, or
by move. rustc also has to figure out which the closure traits (<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, or <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>) a closure is capable of
implementing.</p>
<p>Let's start with a few examples:</p>
<h3><a class="header" href="#example-1" id="example-1">Example 1</a></h3>
<p>To start, let's take a look at how the closure in the following example is desugared:</p>
<pre><pre class="playpen"><code class="language-rust">fn closure(f: impl Fn()) {
    f();
}

fn main() {
    let x: i32 = 10;
    closure(|| println!(&quot;Hi {}&quot;, x));  // The closure just reads x.
    println!(&quot;Value of x after return {}&quot;, x);
}
</code></pre></pre>
<p>Let's say the above is the content of a file called <code>immut.rs</code>. If we compile
<code>immut.rs</code> using the following command. The <a href="./mir/passes.html"><code>-Zdump-mir=all</code></a> flag will cause
<code>rustc</code> to generate and dump the <a href="./mir/index.html">MIR</a> to a directory called <code>mir_dump</code>.</p>
<pre><code class="language-console">&gt; rustc +stage1 immut.rs -Zdump-mir=all
</code></pre>
<p>After we run this command, we will see a newly generated directory in our
current working directory called <code>mir_dump</code>, which will contain several files.
If we look at file <code>rustc.main.-------.mir_map.0.mir</code>, we will find, among
other things, it also contains this line:</p>
<pre><code class="language-rust ignore">_4 = &amp;_1;
_3 = [closure@immut.rs:7:13: 7:36] { x: move _4 };
</code></pre>
<p>Note that in the MIR examples in this chapter, <code>_1</code> is <code>x</code>.</p>
<p>Here in first line <code>_4 = &amp;_1;</code>, the <code>mir_dump</code> tells us that <code>x</code> was borrowed
as an immutable reference.  This is what we would hope as our closure just
reads <code>x</code>.</p>
<h3><a class="header" href="#example-2" id="example-2">Example 2</a></h3>
<p>Here is another example:</p>
<pre><pre class="playpen"><code class="language-rust">fn closure(mut f: impl FnMut()) {
    f();
}

fn main() {
    let mut x: i32 = 10;
    closure(|| {
        x += 10;  // The closure mutates the value of x
        println!(&quot;Hi {}&quot;, x)
    });
    println!(&quot;Value of x after return {}&quot;, x);
}
</code></pre></pre>
<pre><code class="language-rust ignore">_4 = &amp;mut _1;
_3 = [closure@mut.rs:7:13: 10:6] { x: move _4 };
</code></pre>
<p>This time along, in the line <code>_4 = &amp;mut _1;</code>, we see that the borrow is changed to mutable borrow.
Fair enough! The closure increments <code>x</code> by 10.</p>
<h3><a class="header" href="#example-3" id="example-3">Example 3</a></h3>
<p>One more example:</p>
<pre><pre class="playpen"><code class="language-rust">fn closure(f: impl FnOnce()) {
    f();
}

fn main() {
    let x = vec![21];
    closure(|| {
        drop(x);  // Makes x unusable after the fact.
    });
    // println!(&quot;Value of x after return {:?}&quot;, x);
}
</code></pre></pre>
<pre><code class="language-rust ignore">_6 = [closure@move.rs:7:13: 9:6] { x: move _1 }; // bb16[3]: scope 1 at move.rs:7:13: 9:6
</code></pre>
<p>Here, <code>x</code> is directly moved into the closure and the access to it will not be permitted after the
closure.</p>
<h2><a class="header" href="#inferences-in-the-compiler" id="inferences-in-the-compiler">Inferences in the compiler</a></h2>
<p>Now let's dive into rustc code and see how all these inferences are done by the compiler.</p>
<p>Let's start with defining a term that we will be using quite a bit in the rest of the discussion -
<em>upvar</em>. An <strong>upvar</strong> is a variable that is local to the function where the closure is defined. So,
in the above examples, <strong>x</strong> will be an upvar to the closure. They are also sometimes referred to as
the <em>free variables</em> meaning they are not bound to the context of the closure.
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/query/queries/struct.upvars.html"><code>src/librustc_middle/ty/query/mod.rs</code></a> defines a query called <em>upvars</em> for this purpose.</p>
<p>Other than lazy invocation, one other thing that the distinguishes a closure from a
normal function is that it can use the upvars. It borrows these upvars from its surrounding
context; therefore the compiler has to determine the upvar's borrow type. The compiler starts with
assigning an immutable borrow type and lowers the restriction (that is, changes it from
<strong>immutable</strong> to <strong>mutable</strong> to <strong>move</strong>) as needed, based on the usage. In the Example 1 above, the
closure only uses the variable for printing but does not modify it in any way and therefore, in the
<code>mir_dump</code>, we find the borrow type for the upvar <code>x</code> to be immutable.  In example 2, however, the
closure modifies <code>x</code> and increments it by some value.  Because of this mutation, the compiler, which
started off assigning <code>x</code> as an immutable reference type, has to adjust it as a mutable reference.
Likewise in the third example, the closure drops the vector and therefore this requires the variable
<code>x</code> to be moved into the closure. Depending on the borrow kind, the closure has to implement the
appropriate trait: <code>Fn</code> trait for immutable borrow, <code>FnMut</code> for mutable borrow,
and <code>FnOnce</code> for move semantics.</p>
<p>Most of the code related to the closure is in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/upvar/index.html"><code>src/librustc_typeck/check/upvar.rs</code></a> file and the data structures are
declared in the file <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/index.html"><code>src/librustc_middle/ty/mod.rs</code></a>.</p>
<p>Before we go any further, let's discuss how we can examine the flow of control through the rustc
codebase. For closures specifically, set the <code>RUST_LOG</code> env variable as below and collect the
output in a file:</p>
<pre><code class="language-console">&gt; RUST_LOG=rustc_typeck::check::upvar rustc +stage1 -Zdump-mir=all \
    &lt;.rs file to compile&gt; 2&gt; &lt;file where the output will be dumped&gt;
</code></pre>
<p>This uses the stage1 compiler and enables <code>debug!</code> logging for the
<code>rustc_typeck::check::upvar</code> module.</p>
<p>The other option is to step through the code using lldb or gdb.</p>
<ol>
<li><code>rust-lldb build/x86_64-apple-darwin/stage1/bin/rustc test.rs</code></li>
<li>In lldb:
<ol>
<li><code>b upvar.rs:134</code>  // Setting the breakpoint on a certain line in the upvar.rs file`</li>
<li><code>r</code>  // Run the program until it hits the breakpoint</li>
</ol>
</li>
</ol>
<p>Let's start with <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/upvar/index.html"><code>upvar.rs</code></a>. This file has something called
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/expr_use_visitor/struct.ExprUseVisitor.html"><code>euv::ExprUseVisitor</code></a> which walks the source of the closure and
invokes a callbackfor each upvar that is borrowed, mutated, or moved.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = vec![21];
    let _cl = || {
        let y = x[0];  // 1.
        x[0] += 1;  // 2.
    };
}
</code></pre></pre>
<p>In the above example, our visitor will be called twice, for the lines marked 1 and 2, once for a
shared borrow and another one for a mutable borrow. It will also tell us what was borrowed.</p>
<p>The callbacks are defined by implementing the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/expr_use_visitor/trait.Delegate.html"><code>Delegate</code></a> trait. The
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/upvar/struct.InferBorrowKind.html"><code>InferBorrowKind</code></a> type implements <code>Delegate</code> and keeps a map that
records for each upvar which mode of borrow was required. The modes of borrow
can be <code>ByValue</code> (moved) or <code>ByRef</code> (borrowed). For <code>ByRef</code> borrows, it can be
<code>shared</code>, <code>shallow</code>, <code>unique</code> or <code>mut</code> as defined in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/index.html"><code>src/librustc_middle/mir/mod.rs</code></a>.</p>
<p><code>Delegate</code> defines a few different methods (the different callbacks):
<strong>consume</strong>: for <em>move</em> of a variable, <strong>borrow</strong> for a <em>borrow</em> of some kind
(shared or mutable), and <strong>mutate</strong> when we see an <em>assignment</em> of something.</p>
<p>All of these callbacks have a common argument <em>cmt</em> which stands for Category,
Mutability and Type and is defined in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/mem_categorization/index.html"><code>src/librustc_middle/middle/mem_categorization.rs</code></a>. Borrowing from the code
comments, &quot;<code>cmt</code> is a complete categorization of a value indicating where it
originated and how it is located, as well as the mutability of the memory in
which the value is stored&quot;. Based on the callback (consume, borrow etc.), we
will call the relevant <em>adjust_upvar_borrow_kind_for_<something></em> and pass the
<code>cmt</code> along. Once the borrow type is adjusted, we store it in the table, which
basically says what borrows were made for each closure.</p>
<pre><code class="language-rust ignore">self.tables
    .borrow_mut()
    .upvar_capture_map
    .extend(delegate.adjust_upvar_captures);
</code></pre>
<h1><a class="header" href="#part-4-analysis" id="part-4-analysis">Part 4: Analysis</a></h1>
<p>This part discusses the many analyses that the compiler uses to check various
properties of the code and to inform later stages. Typically, this is what people
mean when they talk about &quot;Rust's type system&quot;. This includes the
representation, inference, and checking of types, the trait system, and the
borrow checker. These analyses do not happen as one big pass or set of
contiguous passes. Rather, they are spread out throughout various parts of the
compilation process and use different intermediate representations. For example,
type checking happens on the HIR, while borrow checking happens on the MIR.
Nonetheless, for the sake of presentation, we will discuss all of these
analyses in this part of the guide.</p>
<h1><a class="header" href="#the-ty-module-representing-types" id="the-ty-module-representing-types">The <code>ty</code> module: representing types</a></h1>
<p>The <code>ty</code> module defines how the Rust compiler represents types internally. It also defines the
<em>typing context</em> (<code>tcx</code> or <code>TyCtxt</code>), which is the central data structure in the compiler.</p>
<h2><a class="header" href="#tyty-1" id="tyty-1"><code>ty::Ty</code></a></h2>
<p>When we talk about how rustc represents types,  we usually refer to a type called <code>Ty</code> . There are
quite a few modules and types for <code>Ty</code> in the compiler (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/index.html">Ty documentation</a>).</p>
<p>The specific <code>Ty</code> we are referring to is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>rustc::ty::Ty</code></a> (and not
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Ty.html"><code>rustc_hir::Ty</code></a>). The distinction is important, so we will discuss it first before going
into the details of <code>ty::Ty</code>.</p>
<h2><a class="header" href="#rustc_hirty-vs-tyty" id="rustc_hirty-vs-tyty"><code>rustc_hir::Ty</code> vs <code>ty::Ty</code></a></h2>
<p>The HIR in rustc can be thought of as the high-level intermediate representation. It is more or less
the AST (see <a href="hir.html">this chapter</a>) as it represents the
syntax that the user wrote, and is obtained after parsing and some <em>desugaring</em>. It has a
representation of types, but in reality it reflects more of what the user wrote, that is, what they
wrote so as to represent that type.</p>
<p>In contrast, <code>ty::Ty</code> represents the semantics of a type, that is, the <em>meaning</em> of what the user
wrote. For example, <code>rustc_hir::Ty</code> would record the fact that a user used the name <code>u32</code> twice
in their program, but the <code>ty::Ty</code> would record the fact that both usages refer to the same type.</p>
<p><strong>Example: <code>fn foo(x: u32) → u32 { }</code></strong> In this function we see that <code>u32</code> appears twice. We know
that that is the same type, i.e. the function takes an argument and returns an argument of the same
type, but from the point of view of the HIR there would be two distinct type instances because these
are occurring in two different places in the program. That is, they have two
different <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>Span</code>s</a> (locations).</p>
<p><strong>Example: <code>fn foo(x: &amp;u32) -&gt; &amp;u32)</code></strong> In addition, HIR might have information left out. This type
<code>&amp;u32</code> is incomplete, since in the full rust type there is actually a lifetime, but we didn’t need
to write those lifetimes. There are also some elision rules that insert information. The result may
look like  <code>fn foo&lt;'a&gt;(x: &amp;'a u32) -&gt; &amp;'a u32)</code>.</p>
<p>In the HIR level, these things are not spelled out and you can say the picture is rather incomplete.
However, at the <code>ty::Ty</code> level, these details are added and it is complete. Moreover, we will have
exactly one <code>ty::Ty</code> for a given type, like <code>u32</code>, and that <code>ty::Ty</code> is used for all <code>u32</code>s in the
whole program, not a specific usage, unlike <code>rustc_hir::Ty</code>.</p>
<p>Here is a summary:</p>
<table><thead><tr><th><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Ty.html"><code>rustc_hir::Ty</code></a></th><th><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>ty::Ty</code></a></th></tr></thead><tbody>
<tr><td>Describe the <em>syntax</em> of a type: what the user wrote (with some desugaring).</td><td>Describe the <em>semantics</em> of a type: the meaning of what the user wrote.</td></tr>
<tr><td>Each <code>rustc_hir::Ty</code> has its own spans corresponding to the appropriate place in the program.</td><td>Doesn’t correspond to a single place in the user’s program.</td></tr>
<tr><td><code>rustc_hir::Ty</code> has generics and lifetimes; however, some of those lifetimes are special markers like <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.LifetimeName.html#variant.Implicit"><code>LifetimeName::Implicit</code></a>.</td><td><code>ty::Ty</code> has the full type, including generics and lifetimes, even if the user left them out</td></tr>
<tr><td><code>fn foo(x: u32) → u32 { }</code> - Two <code>rustc_hir::Ty</code> representing each usage of <code>u32</code>. Each has its own <code>Span</code>s, etc.- <code>rustc_hir::Ty</code> doesn’t tell us that both are the same type</td><td><code>fn foo(x: u32) → u32 { }</code> - One <code>ty::Ty</code> for all instances of <code>u32</code> throughout the program.- <code>ty::Ty</code> tells us that both usages of <code>u32</code> mean the same type.</td></tr>
<tr><td><code>fn foo(x: &amp;u32) -&gt; &amp;u32)</code>- Two <code>rustc_hir::Ty</code> again.- Lifetimes for the references show up in the <code>rustc_hir::Ty</code>s using a special marker, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.LifetimeName.html#variant.Implicit"><code>LifetimeName::Implicit</code></a>.</td><td><code>fn foo(x: &amp;u32) -&gt; &amp;u32)</code>- A single <code>ty::Ty</code>.- The <code>ty::Ty</code> has the hidden lifetime param</td></tr>
</tbody></table>
<p><strong>Order</strong> HIR is built directly from the AST, so it happens before any <code>ty::Ty</code> is produced. After
HIR is built, some basic type inference and type checking is done. During the type inference, we
figure out what the <code>ty::Ty</code> of everything is and we also check if the type of something is
ambiguous. The <code>ty::Ty</code> then, is used for type checking while making sure everything has the
expected type. The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/astconv/index.html"><code>astconv</code> module</a>, is where the code responsible for converting a
<code>rustc_hir::Ty</code> into a <code>ty::Ty</code> is located. This occurs during the type-checking phase,
but also in other parts of the compiler that want to ask questions like &quot;what argument types does
this function expect&quot;?.</p>
<p><strong>How semantics drive the two instances of <code>Ty</code></strong> You can think of HIR as the perspective
of the type information that assumes the least. We assume two things are distinct until they are
proven to be the same thing. In other words, we know less about them, so we should assume less about
them.</p>
<p>They are syntactically two strings: <code>&quot;u32&quot;</code> at line N column 20 and <code>&quot;u32&quot;</code> at line N column 35. We
don’t know that they are the same yet. So, in the HIR we treat them as if they are different. Later,
we determine that they semantically are the same type and that’s the <code>ty::Ty</code> we use.</p>
<p>Consider another example: <code>fn foo&lt;T&gt;(x: T) -&gt; u32</code> and suppose that someone invokes <code>foo::&lt;u32&gt;(0)</code>.
This means that <code>T</code> and <code>u32</code> (in this invocation) actually turns out to be the same type, so we
would eventually end up with the same <code>ty::Ty</code> in the end, but we have distinct <code>rustc_hir::Ty</code>.
(This is a bit over-simplified, though, since during type checking, we would check the function
generically and would still have a <code>T</code> distinct from <code>u32</code>. Later, when doing code generation,
we would always be handling &quot;monomorphized&quot; (fully substituted) versions of each function,
and hence we would know what <code>T</code> represents (and specifically that it is <code>u32</code>).</p>
<p>Here is one more example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod a {
    type X = u32;
    pub fn foo(x: X) -&gt; i32 { 22 }
}
mod b {
    type X = i32;
    pub fn foo(x: X) -&gt; i32 { x }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the type <code>X</code> will vary depending on context, clearly. If you look at the <code>rustc_hir::Ty</code>,
you will get back that <code>X</code> is an alias in both cases (though it will be mapped via name resolution
to distinct aliases). But if you look at the <code>ty::Ty</code> signature, it will be either <code>fn(u32) -&gt; u32</code>
or <code>fn(i32) -&gt; i32</code> (with type aliases fully expanded).</p>
<h2><a class="header" href="#tyty-implementation" id="tyty-implementation"><code>ty::Ty</code> implementation</a></h2>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html"><code>rustc::ty::Ty</code></a> is actually a type alias to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html"><code>&amp;TyS</code></a> (more about that later). <code>TyS</code>
(Type Structure) is where the main functionality is located. You can ignore <code>TyS</code> struct in general;
you will basically never access it explicitly. We always pass it by reference using the <code>Ty</code> alias.
The only exception is to define inherent methods on types. In particular, <code>TyS</code> has a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html#structfield.kind"><code>kind</code></a>
field of type <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html"><code>TyKind</code></a>, which represents the key type information. <code>TyKind</code> is a big enum
which represents different kinds of types (e.g. primitives, references, abstract data types,
generics, lifetimes, etc). <code>TyS</code> also has 2 more fields, <code>flags</code> and <code>outer_exclusive_binder</code>. They
are convenient hacks for efficiency and summarize information about the type that we may want to
know, but they don’t come into the picture as much here. Finally, <code>ty::TyS</code>s
are <a href="./memory.html">interned</a>, so that the <code>ty::Ty</code> can be a thin pointer-like
type. This allows us to do cheap comparisons for equality, along with the other
benefits of interning.</p>
<h2><a class="header" href="#allocating-and-working-with-types" id="allocating-and-working-with-types">Allocating and working with types</a></h2>
<p>To allocate a new type, you can use the various <code>mk_</code> methods defined on the <code>tcx</code>. These have names
that correspond mostly to the various kinds of types. For example:</p>
<pre><code class="language-rust ignore">let array_ty = tcx.mk_array(elem_ty, len * 2);
</code></pre>
<p>These methods all return a <code>Ty&lt;'tcx&gt;</code> – note that the lifetime you get back is the lifetime of the
arena that this <code>tcx</code> has access to. Types are always canonicalized and interned (so we never
allocate exactly the same type twice).</p>
<blockquote>
<p>NB. Because types are interned, it is possible to compare them for equality efficiently using <code>==</code>
– however, this is almost never what you want to do unless you happen to be hashing and looking
for duplicates. This is because often in Rust there are multiple ways to represent the same type,
particularly once inference is involved. If you are going to be testing for type equality, you
probably need to start looking into the inference code to do it right.</p>
</blockquote>
<p>You can also find various common types in the <code>tcx</code> itself by accessing <code>tcx.types.bool</code>,
<code>tcx.types.char</code>, etc (see <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.CommonTypes.html"><code>CommonTypes</code></a> for more).</p>
<h2><a class="header" href="#tytykind-variants" id="tytykind-variants"><code>ty::TyKind</code> Variants</a></h2>
<p>Note: <code>TyKind</code> is <strong>NOT</strong> the functional programming concept of <em>Kind</em>.</p>
<p>Whenever working with a <code>Ty</code> in the compiler, it is common to match on the kind of type:</p>
<pre><code class="language-rust ignore">fn foo(x: Ty&lt;'tcx&gt;) {
  match x.kind {
    ...
  }
}
</code></pre>
<p>The <code>kind</code> field is of type <code>TyKind&lt;'tcx&gt;</code>, which is an enum defining all of the different kinds of
types in the compiler.</p>
<blockquote>
<p>N.B. inspecting the <code>kind</code> field on types during type inference can be risky, as there may be
inference variables and other things to consider, or sometimes types are not yet known and will
become known later.</p>
</blockquote>
<p>There are a lot of related types, and we’ll cover them in time (e.g regions/lifetimes,
“substitutions”, etc).</p>
<p>There are a bunch of variants on the <code>TyKind</code> enum, which you can see by looking at the rustdocs.
Here is a sampling:</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Adt"><strong>Algebraic Data Types (ADTs)</strong></a> An <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic Data Type</em></a> is a  <code>struct</code>,
<code>enum</code> or <code>union</code>.  Under the hood, <code>struct</code>, <code>enum</code> and <code>union</code> are actually implemented
the same way: they are all <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Adt"><code>ty::TyKind::Adt</code></a>.  It’s basically a user defined type.
We will talk more about these later.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Foreign"><strong>Foreign</strong></a> Corresponds to <code>extern type T</code>.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Str"><strong>Str</strong></a> Is the type str. When the user writes <code>&amp;str</code>, <code>Str</code> is the how we represent the
<code>str</code> part of that type.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Slice"><strong>Slice</strong></a> Corresponds to <code>[T]</code>.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Array"><strong>Array</strong></a> Corresponds to <code>[T; n]</code>.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.RawPtr"><strong>RawPtr</strong></a> Corresponds to <code>*mut T</code> or <code>*const T</code></p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Ref"><strong>Ref</strong></a> <code>Ref</code> stands for safe references, <code>&amp;'a mut T</code> or <code>&amp;'a T</code>. <code>Ref</code> has some
associated parts, like <code>Ty&lt;'tcx&gt;</code> which is the type that the reference references, <code>Region&lt;'tcx&gt;</code> is
the lifetime or region of the reference and <code>Mutability</code> if the reference is mutable or not.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Param"><strong>Param</strong></a> Represents a type parameter (e.g. the <code>T</code> in <code>Vec&lt;T&gt;</code>).</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Error"><strong>Error</strong></a> Represents a type error somewhere so that we can print better diagnostics. We
will discuss this more later.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variants"><strong>And Many More</strong>...</a></p>
<h2><a class="header" href="#import-conventions" id="import-conventions">Import conventions</a></h2>
<p>Although there is no hard and fast rule, the <code>ty</code> module tends to be used like so:</p>
<pre><code class="language-rust ignore">use ty::{self, Ty, TyCtxt};
</code></pre>
<p>In particular, since they are so common, the <code>Ty</code> and <code>TyCtxt</code> types are imported directly. Other
types are often referenced with an explicit <code>ty::</code> prefix (e.g. <code>ty::TraitRef&lt;'tcx&gt;</code>). But some
modules choose to import a larger or smaller set of names explicitly.</p>
<h2><a class="header" href="#adts-representation" id="adts-representation">ADTs Representation</a></h2>
<p>Let's consider the example of a type like <code>MyStruct&lt;u32&gt;</code>, where <code>MyStruct</code> is defined like so:</p>
<pre><code class="language-rust ignore">struct MyStruct&lt;T&gt; { x: u32, y: T }
</code></pre>
<p>The type <code>MyStruct&lt;u32&gt;</code> would be an instance of <code>TyKind::Adt</code>:</p>
<pre><code class="language-rust ignore">Adt(&amp;'tcx AdtDef, SubstsRef&lt;'tcx&gt;)
//  ------------  ---------------
//  (1)            (2)
//
// (1) represents the `MyStruct` part
// (2) represents the `&lt;u32&gt;`, or &quot;substitutions&quot; / generic arguments
</code></pre>
<p>There are two parts:</p>
<ul>
<li>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.AdtDef.html"><code>AdtDef</code></a> references the struct/enum/union but without the values for its type
parameters. In our example, this is the <code>MyStruct</code> part <em>without</em> the argument <code>u32</code>.
<ul>
<li>Note that in the HIR, structs, enums and unions are represented differently, but in <code>ty::Ty</code>,
they are all represented using <code>TyKind::Adt</code>.</li>
</ul>
</li>
<li>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/subst/type.SubstsRef.html"><code>SubstsRef</code></a> is an interned list of values that are to be substituted for the
generic parameters.  In our example of <code>MyStruct&lt;u32&gt;</code>, we would end up with a list like <code>[u32]</code>.
We’ll dig more into generics and substitutions in a little bit.</li>
</ul>
<p><strong><code>AdtDef</code> and <code>DefId</code></strong></p>
<p>For every type defined in the source code, there is a unique <code>DefId</code> (see <a href="hir.html#identifiers-in-the-hir">this
chapter</a>). This includes ADTs and generics. In the <code>MyStruct&lt;T&gt;</code>
definition we gave above, there are two <code>DefId</code>s: one for <code>MyStruct</code> and one for <code>T</code>.  Notice that
the code above does not generate a new <code>DefId</code> for <code>u32</code> because it is not defined in that code (it
is only referenced).</p>
<p><code>AdtDef</code> is more or less a wrapper around <code>DefId</code> with lots of useful helper methods. There is
essentially a one-to-one relationship between <code>AdtDef</code> and <code>DefId</code>. You can get the <code>AdtDef</code> for a
<code>DefId</code> with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html#method.adt_def"><code>tcx.adt_def(def_id)</code> query</a>.  The <code>AdtDef</code>s are all interned (as you can
see <code>'tcx</code> lifetime on it).</p>
<h2><a class="header" href="#type-errors" id="type-errors">Type errors</a></h2>
<p>There is a <code>TyKind::Error</code> that is produced when the user makes a type error. The idea is that
we would propagate this type and suppress other errors that come up due to it so as not to overwhelm
the user with cascading compiler error messages.</p>
<p>There is an <strong>important invariant</strong> for <code>TyKind::Error</code>. You should <strong>never</strong> return the 'error
type' unless you <strong>know</strong> that an error has already been reported to the user. This is usually
because (a) you just reported it right there or (b) you are propagating an existing Error type (in
which case the error should've been reported when that error type was produced).</p>
<p>It's important to maintain this invariant because the whole point of the <code>Error</code> type is to suppress
other errors -- i.e., we don't report them. If we were to produce an <code>Error</code> type without actually
emitting an error to the user, then this could cause later errors to be suppressed, and the
compilation might inadvertently succeed!</p>
<p>Sometimes there is a third case. You believe that an error has been reported, but you believe it
would've been reported earlier in the compilation, not locally. In that case, you can invoke
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/struct.Session.html#method.delay_span_bug"><code>delay_span_bug</code></a> This will make a note that you expect compilation to yield an error -- if however
compilation should succeed, then it will trigger a compiler bug report.</p>
<h2><a class="header" href="#question-why-not-substitute-inside-the-adtdef" id="question-why-not-substitute-inside-the-adtdef">Question: Why not substitute “inside” the <code>AdtDef</code>?</a></h2>
<p>Recall that we represent a generic struct with <code>(AdtDef, substs)</code>. So why bother with this scheme?</p>
<p>Well, the alternate way we could have choosen to represent types would be to always create a new,
fully-substituted form of the <code>AdtDef</code> where all the types are already substituted. This seems like
less of a hassle. However, the <code>(AdtDef, substs)</code> scheme has some advantages over this.</p>
<p>First, <code>(AdtDef, substs)</code> scheme has an efficiency win:</p>
<pre><code class="language-rust ignore">struct MyStruct&lt;T&gt; {
  ... 100s of fields ...
}

// Want to do: MyStruct&lt;A&gt; ==&gt; MyStruct&lt;B&gt;
</code></pre>
<p>in an example like this, we can subst from <code>MyStruct&lt;A&gt;</code> to <code>MyStruct&lt;B&gt;</code> (and so on) very cheaply,
by just replacing the one reference to <code>A</code> with <code>B</code>. But if we eagerly substituted all the fields,
that could be a lot more work because we might have to go through all of the fields in the <code>AdtDef</code>
and update all of their types.</p>
<p>A bit more deeply, this corresponds to structs in Rust being <a href="https://en.wikipedia.org/wiki/Nominal_type_system"><em>nominal</em> types</a> — which
means that they are defined by their <em>name</em> (and that their contents are then indexed from the
definition of that name, and not carried along “within” the type itself).</p>
<h1><a class="header" href="#generics-and-substitutions" id="generics-and-substitutions">Generics and substitutions</a></h1>
<p>Given a generic type <code>MyType&lt;A, B, …&gt;</code>, we may want to swap out the generics <code>A, B, …</code> for some
other types (possibly other generics or concrete types). We do this a lot while doing type
inference, type checking, and trait solving. Conceptually, during these routines, we may find out
that one type is equal to another type and want to swap one out for the other and then swap that out
for another type and so on until we eventually get some concrete types (or an error).</p>
<p>In rustc this is done using the <code>SubstsRef</code> that we mentioned above (“substs” = “substitutions”).
Conceptually, you can think of <code>SubstsRef</code> of a list of types that are to be substituted for the
generic type parameters of the ADT.</p>
<p><code>SubstsRef</code> is a type alias of <code>List&lt;GenericArg&lt;'tcx&gt;&gt;</code> (see <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.List.html"><code>List</code> rustdocs</a>).
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/subst/struct.GenericArg.html"><code>GenericArg</code></a> is essentially a space-efficient wrapper around <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/subst/enum.GenericArgKind.html"><code>GenericArgKind</code></a>, which is an enum
indicating what kind of generic the type parameter is (type, lifetime, or const).  Thus, <code>SubstsRef</code>
is conceptually like a <code>&amp;'tcx [GenericArgKind&lt;'tcx&gt;]</code> slice (but it is actually a <code>List</code>).</p>
<p>So why do we use this <code>List</code> type instead of making it really a slice? It has the length &quot;inline&quot;,
so <code>&amp;List</code> is only 32 bits. As a consequence, it cannot be &quot;subsliced&quot; (that only works if the
length is out of line).</p>
<p>This also implies that you can check two <code>List</code>s for equality via <code>==</code> (which would be not be
possible for ordinary slices). This is precisely because they never represent a &quot;sub-list&quot;, only the
complete <code>List</code>, which has been hashed and interned.</p>
<p>So pulling it all together, let’s go back to our example above:</p>
<pre><code class="language-rust ignore">struct MyStruct&lt;T&gt;
</code></pre>
<ul>
<li>There would be an <code>AdtDef</code> (and corresponding <code>DefId</code>) for <code>MyStruct</code>.</li>
<li>There would be a <code>TyKind::Param</code> (and corresponding <code>DefId</code>) for <code>T</code> (more later).</li>
<li>There would be a <code>SubstsRef</code> containing the list <code>[GenericArgKind::Type(Ty(T))]</code>
<ul>
<li>The <code>Ty(T)</code> here is my shorthand for entire other <code>ty::Ty</code> that has <code>TyKind::Param</code>, which we
mentioned in the previous point.</li>
</ul>
</li>
<li>This is one <code>TyKind::Adt</code> containing the <code>AdtDef</code> of <code>MyStruct</code> with the <code>SubstsRef</code> above.</li>
</ul>
<p>Finally, we will quickly mention the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Generics.html"><code>Generics</code></a> type. It
is used to give information about the type parameters of a type.</p>
<h3><a class="header" href="#unsubstituted-generics" id="unsubstituted-generics">Unsubstituted Generics</a></h3>
<p>So above, recall that in our example the <code>MyStruct</code> struct had a generic type <code>T</code>. When we are (for
example) type checking functions that use <code>MyStruct</code>, we will need to be able to refer to this type
<code>T</code> without actually knowing what it is. In general, this is true inside all generic definitions: we
need to be able to work with unknown types. This is done via <code>TyKind::Param</code> (which we mentioned in
the example above).</p>
<p>Each <code>TyKind::Param</code> contains two things: the name and the index. In general, the index fully
defines the parameter and is used by most of the code. The name is included for debug print-outs.
There are two reasons for this. First, the index is convenient, it allows you to include into the
list of generic arguments when substituting. Second, the index is more robust. For example, you
could in principle have two distinct type parameters that use the same name, e.g. <code>impl&lt;A&gt; Foo&lt;A&gt; { fn bar&lt;A&gt;() { .. } }</code>, although the rules against shadowing make this difficult (but those language
rules could change in the future).</p>
<p>The index of the type parameter is an integer indicating its order in the list of the type
parameters. Moreover, we consider the list to include all of the type parameters from outer scopes.
Consider the following example:</p>
<pre><code class="language-rust ignore">struct Foo&lt;A, B&gt; {
  // A would have index 0
  // B would have index 1

  .. // some fields
}
impl&lt;X, Y&gt; Foo&lt;X, Y&gt; {
  fn method&lt;Z&gt;() {
    // inside here, X, Y and Z are all in scope
    // X has index 0
    // Y has index 1
    // Z has index 2
  }
}
</code></pre>
<p>When we are working inside the generic definition, we will use <code>TyKind::Param</code> just like any other
<code>TyKind</code>; it is just a type after all. However, if we want to use the generic type somewhere, then
we will need to do substitutions.</p>
<p>For example suppose that the <code>Foo&lt;A, B&gt;</code> type from the previous example has a field that is a
<code>Vec&lt;A&gt;</code>. Observe that <code>Vec</code> is also a generic type. We want to tell the compiler that the type
parameter of <code>Vec</code> should be replaced with the <code>A</code> type parameter of <code>Foo&lt;A, B&gt;</code>. We do that with
substitutions:</p>
<pre><code class="language-rust ignore">struct Foo&lt;A, B&gt; { // Adt(Foo, &amp;[Param(0), Param(1)])
  x: Vec&lt;A&gt;, // Adt(Vec, &amp;[Param(0)])
  ..
}

fn bar(foo: Foo&lt;u32, f32&gt;) { // Adt(Foo, &amp;[u32, f32])
  let y = foo.x; // Vec&lt;Param(0)&gt; =&gt; Vec&lt;u32&gt;
}
</code></pre>
<p>This example has a few different substitutions:</p>
<ul>
<li>In the definition of <code>Foo</code>, in the type of the field <code>x</code>, we replace <code>Vec</code>'s type parameter with
<code>Param(0)</code>, the first parameter of <code>Foo&lt;A, B&gt;</code>, so that the type of <code>x</code> is <code>Vec&lt;A&gt;</code>.</li>
<li>In the function <code>bar</code>, we specify that we want a <code>Foo&lt;u32, f32&gt;</code>. This means that we will
substitute <code>Param(0)</code> and <code>Param(1)</code> with <code>u32</code> and <code>f32</code>.</li>
<li>In the body of <code>bar</code>, we access <code>foo.x</code>, which has type <code>Vec&lt;Param(0)&gt;</code>, but <code>Param(0)</code> has been
substituted for <code>u32</code>, so <code>foo.x</code> has type <code>Vec&lt;u32&gt;</code>.</li>
</ul>
<p>Let’s look a bit more closely at that last substitution to see why we use indexes. If we want to
find the type of <code>foo.x</code>, we can get generic type of <code>x</code>, which is <code>Vec&lt;Param(0)&gt;</code>. Now we can take
the index <code>0</code> and use it to find the right type substitution: looking at <code>Foo</code>'s <code>SubstsRef</code>, we
have the list <code>[u32, f32]</code> , since we want to replace index <code>0</code>, we take the 0-th index of this
list, which is <code>u32</code>. Voila!</p>
<p>You may have a couple of followup questions…</p>
<p><strong><code>type_of</code></strong> How do we get the “generic type of <code>x</code>&quot;? You can get the type of pretty much anything
with the   <code>tcx.type_of(def_id)</code> query. In this case, we would pass the <code>DefId</code> of the field <code>x</code>.
The <code>type_of</code> query always returns the definition with the generics that are in scope of the
definition. For example, <code>tcx.type_of(def_id_of_my_struct)</code> would return the “self-view” of
<code>MyStruct</code>: <code>Adt(Foo, &amp;[Param(0), Param(1)])</code>.</p>
<p><strong><code>subst</code></strong> How do we actually do the substitutions? There is a function for that too! You use
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/subst/trait.Subst.html"><code>subst</code></a> to
replace a <code>SubstRef</code> with another list of types.</p>
<p><a href="https://github.com/rust-lang/rust/blob/597f432489f12a3f33419daa039ccef11a12c4fd/src/librustc_typeck/astconv.rs#L942-L953">Here is an example of actually using <code>subst</code> in the compiler</a>.  The exact details are not
too important, but in this piece of code, we happen to be converting from the <code>rustc_hir::Ty</code> to
a real <code>ty::Ty</code>. You can see that we first get some substitutions (<code>substs</code>).  Then we call
<code>type_of</code> to get a type and call <code>ty.subst(substs)</code> to get a new version of <code>ty</code> with
the substitutions made.</p>
<p><strong>Note on indices:</strong> It is possible for the indices in <code>Param</code> to not match with what we expect. For
example, the index could be out of bounds or it could be the index of a lifetime when we were
expecting a type. These sorts of errors would be caught earlier in the compiler when translating
from a <code>rustc_hir::Ty</code> to a <code>ty::Ty</code>. If they occur later, that is a compiler bug.</p>
<h1><a class="header" href="#typefoldable-and-typefolder" id="typefoldable-and-typefolder"><code>TypeFoldable</code> and <code>TypeFolder</code></a></h1>
<p>How is this <code>subst</code> query actually implemented? As you can imagine, we might want to do
substitutions on a lot of different things. For example, we might want to do a substitution directly
on a type like we did with <code>Vec</code> above. But we might also have a more complex type with other types
nested inside that also need substitutions.</p>
<p>The answer is a couple of traits:
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/fold/trait.TypeFoldable.html"><code>TypeFoldable</code></a>
and
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/fold/trait.TypeFolder.html"><code>TypeFolder</code></a>.</p>
<ul>
<li><code>TypeFoldable</code> is implemented by types that embed type information. It allows you to recursively
process the contents of the <code>TypeFoldable</code> and do stuff to them.</li>
<li><code>TypeFolder</code> defines what you want to do with the types you encounter while processing the
<code>TypeFoldable</code>.</li>
</ul>
<p>For example, the <code>TypeFolder</code> trait has a method
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/fold/trait.TypeFolder.html#method.fold_ty"><code>fold_ty</code></a>
that takes a type as input a type and returns a new type as a result. <code>TypeFoldable</code> invokes the
<code>TypeFolder</code> <code>fold_foo</code> methods on itself, giving the <code>TypeFolder</code> access to its contents (the
types, regions, etc that are contained within).</p>
<p>You can think of it with this analogy to the iterator combinators we have come to love in rust:</p>
<pre><code class="language-rust ignore">vec.iter().map(|e1| foo(e2)).collect()
//             ^^^^^^^^^^^^ analogous to `TypeFolder`
//         ^^^ analogous to `TypeFoldable`
</code></pre>
<p>So to reiterate:</p>
<ul>
<li><code>TypeFolder</code>  is a trait that defines a “map” operation.</li>
<li><code>TypeFoldable</code>  is a trait that is implemented by things that embed types.</li>
</ul>
<p>In the case of <code>subst</code>, we can see that it is implemented as a <code>TypeFolder</code>:
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/subst/struct.SubstFolder.html"><code>SubstFolder</code></a>.
Looking at its implementation, we see where the actual substitutions are happening.</p>
<p>However, you might also notice that the implementation calls this <code>super_fold_with</code> method. What is
that? It is a method of <code>TypeFoldable</code>. Consider the following <code>TypeFoldable</code> type <code>MyFoldable</code>:</p>
<pre><code class="language-rust ignore">struct MyFoldable&lt;'tcx&gt; {
  def_id: DefId,
  ty: Ty&lt;'tcx&gt;,
}
</code></pre>
<p>The <code>TypeFolder</code> can call <code>super_fold_with</code> on <code>MyFoldable</code> if it just wants to replace some of the
fields of <code>MyFoldable</code> with new values. If it instead wants to replace the whole <code>MyFoldable</code> with a
different one, it would call <code>fold_with</code> instead (a different method on <code>TypeFoldable</code>).</p>
<p>In almost all cases, we don’t want to replace the whole struct; we only want to replace <code>ty::Ty</code>s in
the struct, so usually we call <code>super_fold_with</code>. A typical implementation that <code>MyFoldable</code> could
have might do something like this:</p>
<pre><code class="language-rust ignore">my_foldable: MyFoldable&lt;'tcx&gt;
my_foldable.subst(..., subst)

impl TypeFoldable for MyFoldable {
  fn super_fold_with(&amp;self, folder: &amp;mut impl TypeFolder&lt;'tcx&gt;) -&gt; MyFoldable {
    MyFoldable {
      def_id: self.def_id.fold_with(folder),
      ty: self.ty.fold_with(folder),
    }
  }

  fn super_visit_with(..) { }
}
</code></pre>
<p>Notice that here, we implement <code>super_fold_with</code> to go over the fields of <code>MyFoldable</code> and call
<code>fold_with</code> on <em>them</em>. That is, a folder may replace  <code>def_id</code> and <code>ty</code>, but not the whole
<code>MyFoldable</code> struct.</p>
<p>Here is another example to put things together: suppose we have a type like <code>Vec&lt;Vec&lt;X&gt;&gt;</code>. The
<code>ty::Ty</code> would look like: <code>Adt(Vec, &amp;[Adt(Vec, &amp;[Param(X)])])</code>. If we want to do <code>subst(X =&gt; u32)</code>,
then we would first look at the overall type. We would see that there are no substitutions to be
made at the outer level, so we would descend one level and look at <code>Adt(Vec, &amp;[Param(X)])</code>. There
are still no substitutions to be made here, so we would descend again. Now we are looking at
<code>Param(X)</code>, which can be substituted, so we replace it with <code>u32</code>. We can’t descend any more, so we
are done, and  the overall result is <code>Adt(Vec, &amp;[Adt(Vec, &amp;[u32])])</code>.</p>
<p>One last thing to mention: often when folding over a <code>TypeFoldable</code>, we don’t want to change most
things. We only want to do something when we reach a type. That means there may be a lot of
<code>TypeFoldable</code> types whose implementations basically just forward to their fields’ <code>TypeFoldable</code>
implementations. Such implementations of <code>TypeFoldable</code> tend to be pretty tedious to write by hand.
For this reason, there is a <code>derive</code> macro that allows you to <code>#![derive(TypeFoldable)]</code>. It is
defined
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_macros/src/type_foldable.rs">here</a>.</p>
<p><strong><code>subst</code></strong> In the case of substitutions the <a href="https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src/librustc_middle/ty/subst.rs#L440-L451">actual
folder</a>
is going to be doing the indexing we’ve already mentioned. There we define a <code>Folder</code> and call
<code>fold_with</code> on the <code>TypeFoldable</code> to process yourself.  Then
<a href="https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src/librustc_middle/ty/subst.rs#L512-L536">fold_ty</a>
the method that process each type it looks for a <code>ty::Param</code> and for those it replaces it for
something from the list of substitutions, otherwise recursively process the type.  To replace it,
calls
<a href="https://github.com/rust-lang/rust/blob/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6/src/librustc_middle/ty/subst.rs#L552-L587">ty_for_param</a>
and all that does is index into the list of substitutions with the index of the <code>Param</code>.</p>
<h1><a class="header" href="#generic-arguments" id="generic-arguments">Generic arguments</a></h1>
<p>A <code>ty::subst::GenericArg&lt;'tcx&gt;</code> represents some entity in the type system: a type
(<code>Ty&lt;'tcx&gt;</code>), lifetime (<code>ty::Region&lt;'tcx&gt;</code>) or constant (<code>ty::Const&lt;'tcx&gt;</code>).
<code>GenericArg</code> is used to perform substitutions of generic parameters for concrete
arguments, such as when calling a function with generic parameters explicitly
with type arguments. Substitutions are represented using the
<a href="generic_arguments.html#subst"><code>Subst</code> type</a> as described below.</p>
<h2><a class="header" href="#subst" id="subst"><code>Subst</code></a></h2>
<p><code>ty::subst::Subst&lt;'tcx&gt;</code> is intuitively simply a slice of <code>GenericArg&lt;'tcx&gt;</code>s,
acting as an ordered list of substitutions from generic parameters to
concrete arguments (such as types, lifetimes and consts).</p>
<p>For example, given a <code>HashMap&lt;K, V&gt;</code> with two type parameters, <code>K</code> and <code>V</code>, an
instantiation of the parameters, for example <code>HashMap&lt;i32, u32&gt;</code>, would be
represented by the substitution <code>&amp;'tcx [tcx.types.i32, tcx.types.u32]</code>.</p>
<p><code>Subst</code> provides various convenience methods to instantiate substitutions
given item definitions, which should generally be used rather than explicitly
constructing such substitution slices.</p>
<h2><a class="header" href="#genericarg" id="genericarg"><code>GenericArg</code></a></h2>
<p>The actual <code>GenericArg</code> struct is optimised for space, storing the type, lifetime or
const as an interned pointer containing a tag identifying its kind (in the
lowest 2 bits). Unless you are working with the <code>Subst</code> implementation
specifically, you should generally not have to deal with <code>GenericArg</code> and instead
make use of the safe <a href="generic_arguments.html#genericargkind"><code>GenericArgKind</code></a> abstraction.</p>
<h2><a class="header" href="#genericargkind" id="genericargkind"><code>GenericArgKind</code></a></h2>
<p>As <code>GenericArg</code> itself is not type-safe, the <code>GenericArgKind</code> enum provides a more
convenient and safe interface for dealing with generic arguments. An
<code>GenericArgKind</code> can be converted to a raw <code>GenericArg</code> using <code>GenericArg::from()</code>
(or simply <code>.into()</code> when the context is clear). As mentioned earlier, substitution
lists store raw <code>GenericArg</code>s, so before dealing with them, it is preferable to
convert them to <code>GenericArgKind</code>s first. This is done by calling the <code>.unpack()</code>
method.</p>
<pre><code class="language-rust ignore">// An example of unpacking and packing a generic argument.
fn deal_with_generic_arg&lt;'tcx&gt;(generic_arg: GenericArg&lt;'tcx&gt;) -&gt; GenericArg&lt;'tcx&gt; {
    // Unpack a raw `GenericArg` to deal with it safely.
    let new_generic_arg: GenericArgKind&lt;'tcx&gt; = match generic_arg.unpack() {
        GenericArgKind::Type(ty) =&gt; { /* ... */ }
        GenericArgKind::Lifetime(lt) =&gt; { /* ... */ }
        GenericArgKind::Const(ct) =&gt; { /* ... */ }
    };
    // Pack the `GenericArgKind` to store it in a substitution list.
    new_generic_arg.into()
}
</code></pre>
<h1><a class="header" href="#type-inference" id="type-inference">Type inference</a></h1>
<p>Type inference is the process of automatic detection of the type of an
expression.</p>
<p>It is what allows Rust to work with fewer or no type annotations,
making things easier for users:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut things = vec![];
    things.push(&quot;thing&quot;);
}
</code></pre></pre>
<p>Here, the type of <code>things</code> is <em>inferred</em> to be <code>Vec&lt;&amp;str&gt;</code> because of the value
we push into <code>things</code>.</p>
<p>The type inference is based on the standard Hindley-Milner (HM) type inference
algorithm, but extended in various way to accommodate subtyping, region
inference, and higher-ranked types.</p>
<h2><a class="header" href="#a-note-on-terminology" id="a-note-on-terminology">A note on terminology</a></h2>
<p>We use the notation <code>?T</code> to refer to inference variables, also called
existential variables.</p>
<p>We use the terms &quot;region&quot; and &quot;lifetime&quot; interchangeably. Both refer to
the <code>'a</code> in <code>&amp;'a T</code>.</p>
<p>The term &quot;bound region&quot; refers to a region that is bound in a function
signature, such as the <code>'a</code> in <code>for&lt;'a&gt; fn(&amp;'a u32)</code>. A region is
&quot;free&quot; if it is not bound.</p>
<h2><a class="header" href="#creating-an-inference-context" id="creating-an-inference-context">Creating an inference context</a></h2>
<p>You create and &quot;enter&quot; an inference context by doing something like
the following:</p>
<pre><code class="language-rust ignore">tcx.infer_ctxt().enter(|infcx| {
    // Use the inference context `infcx` here.
})
</code></pre>
<p>Within the closure, <code>infcx</code> has the type <code>InferCtxt&lt;'cx, 'tcx&gt;</code> for some
fresh <code>'cx</code>, while <code>'tcx</code> is the same as outside the inference context.
(Again, see the <a href="ty.html"><code>ty</code> chapter</a> for more details on this setup.)</p>
<p>The <code>tcx.infer_ctxt</code> method actually returns a builder, which means
there are some kinds of configuration you can do before the <code>infcx</code> is
created. See <code>InferCtxtBuilder</code> for more information.</p>
<p><a name="vars"></a></p>
<h2><a class="header" href="#inference-variables" id="inference-variables">Inference variables</a></h2>
<p>The main purpose of the inference context is to house a bunch of
<strong>inference variables</strong> – these represent types or regions whose precise
value is not yet known, but will be uncovered as we perform type-checking.</p>
<p>If you're familiar with the basic ideas of unification from H-M type
systems, or logic languages like Prolog, this is the same concept. If
you're not, you might want to read a tutorial on how H-M type
inference works, or perhaps this blog post on
<a href="http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">unification in the Chalk project</a>.</p>
<p>All told, the inference context stores four kinds of inference variables as of
this writing:</p>
<ul>
<li>Type variables, which come in three varieties:
<ul>
<li>General type variables (the most common). These can be unified with any
type.</li>
<li>Integral type variables, which can only be unified with an integral type,
and arise from an integer literal expression like <code>22</code>.</li>
<li>Float type variables, which can only be unified with a float type, and
arise from a float literal expression like <code>22.0</code>.</li>
</ul>
</li>
<li>Region variables, which represent lifetimes, and arise all over the place.</li>
</ul>
<p>All the type variables work in much the same way: you can create a new
type variable, and what you get is <code>Ty&lt;'tcx&gt;</code> representing an
unresolved type <code>?T</code>. Then later you can apply the various operations
that the inferencer supports, such as equality or subtyping, and it
will possibly <strong>instantiate</strong> (or <strong>bind</strong>) that <code>?T</code> to a specific
value as a result.</p>
<p>The region variables work somewhat differently, and are described
below in a separate section.</p>
<h2><a class="header" href="#enforcing-equality--subtyping" id="enforcing-equality--subtyping">Enforcing equality / subtyping</a></h2>
<p>The most basic operations you can perform in the type inferencer is
<strong>equality</strong>, which forces two types <code>T</code> and <code>U</code> to be the same. The
recommended way to add an equality constraint is to use the <code>at</code>
method, roughly like so:</p>
<pre><code class="language-rust ignore">infcx.at(...).eq(t, u);
</code></pre>
<p>The first <code>at()</code> call provides a bit of context, i.e. why you are
doing this unification, and in what environment, and the <code>eq</code> method
performs the actual equality constraint.</p>
<p>When you equate things, you force them to be precisely equal. Equating
returns an <code>InferResult</code> – if it returns <code>Err(err)</code>, then equating
failed, and the enclosing <code>TypeError</code> will tell you what went wrong.</p>
<p>The success case is perhaps more interesting. The &quot;primary&quot; return
type of <code>eq</code> is <code>()</code> – that is, when it succeeds, it doesn't return a
value of any particular interest. Rather, it is executed for its
side-effects of constraining type variables and so forth. However, the
actual return type is not <code>()</code>, but rather <code>InferOk&lt;()&gt;</code>. The
<code>InferOk</code> type is used to carry extra trait obligations – your job is
to ensure that these are fulfilled (typically by enrolling them in a
fulfillment context). See the <a href="traits/resolution.html">trait chapter</a> for more background on that.</p>
<p>You can similarly enforce subtyping through <code>infcx.at(..).sub(..)</code>. The same
basic concepts as above apply.</p>
<h2><a class="header" href="#trying-equality" id="trying-equality">&quot;Trying&quot; equality</a></h2>
<p>Sometimes you would like to know if it is <em>possible</em> to equate two
types without error.  You can test that with <code>infcx.can_eq</code> (or
<code>infcx.can_sub</code> for subtyping). If this returns <code>Ok</code>, then equality
is possible – but in all cases, any side-effects are reversed.</p>
<p>Be aware, though, that the success or failure of these methods is always
<strong>modulo regions</strong>. That is, two types <code>&amp;'a u32</code> and <code>&amp;'b u32</code> will
return <code>Ok</code> for <code>can_eq</code>, even if <code>'a != 'b</code>.  This falls out from the
&quot;two-phase&quot; nature of how we solve region constraints.</p>
<h2><a class="header" href="#snapshots" id="snapshots">Snapshots</a></h2>
<p>As described in the previous section on <code>can_eq</code>, often it is useful
to be able to do a series of operations and then roll back their
side-effects. This is done for various reasons: one of them is to be
able to backtrack, trying out multiple possibilities before settling
on which path to take. Another is in order to ensure that a series of
smaller changes take place atomically or not at all.</p>
<p>To allow for this, the inference context supports a <code>snapshot</code> method.
When you call it, it will start recording changes that occur from the
operations you perform. When you are done, you can either invoke
<code>rollback_to</code>, which will undo those changes, or else <code>confirm</code>, which
will make them permanent. Snapshots can be nested as long as you follow
a stack-like discipline.</p>
<p>Rather than use snapshots directly, it is often helpful to use the
methods like <code>commit_if_ok</code> or <code>probe</code> that encapsulate higher-level
patterns.</p>
<h2><a class="header" href="#subtyping-obligations" id="subtyping-obligations">Subtyping obligations</a></h2>
<p>One thing worth discussing is subtyping obligations. When you force
two types to be a subtype, like <code>?T &lt;: i32</code>, we can often convert those
into equality constraints. This follows from Rust's rather limited notion
of subtyping: so, in the above case, <code>?T &lt;: i32</code> is equivalent to <code>?T = i32</code>.</p>
<p>However, in some cases we have to be more careful. For example, when
regions are involved. So if you have <code>?T &lt;: &amp;'a i32</code>, what we would do
is to first &quot;generalize&quot; <code>&amp;'a i32</code> into a type with a region variable:
<code>&amp;'?b i32</code>, and then unify <code>?T</code> with that (<code>?T = &amp;'?b i32</code>). We then
relate this new variable with the original bound:</p>
<pre><code class="language-text">&amp;'?b i32 &lt;: &amp;'a i32
</code></pre>
<p>This will result in a region constraint (see below) of <code>'?b: 'a</code>.</p>
<p>One final interesting case is relating two unbound type variables,
like <code>?T &lt;: ?U</code>.  In that case, we can't make progress, so we enqueue
an obligation <code>Subtype(?T, ?U)</code> and return it via the <code>InferOk</code>
mechanism. You'll have to try again when more details about <code>?T</code> or
<code>?U</code> are known.</p>
<h2><a class="header" href="#region-constraints" id="region-constraints">Region constraints</a></h2>
<p>Regions are inferenced somewhat differently from types. Rather than
eagerly unifying things, we simply collect constraints as we go, but
make (almost) no attempt to solve regions. These constraints have the
form of an &quot;outlives&quot; constraint:</p>
<pre><code class="language-text">'a: 'b
</code></pre>
<p>Actually the code tends to view them as a subregion relation, but it's the same
idea:</p>
<pre><code class="language-text">'b &lt;= 'a
</code></pre>
<p>(There are various other kinds of constraints, such as &quot;verifys&quot;; see
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/region_constraints/index.html"><code>region_constraints</code></a> module for details.)</p>
<p>There is one case where we do some amount of eager unification. If you have an
equality constraint between two regions</p>
<pre><code class="language-text">'a = 'b
</code></pre>
<p>we will record that fact in a unification table. You can then use
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/region_constraints/struct.RegionConstraintCollector.html#method.opportunistic_resolve_var"><code>opportunistic_resolve_var</code></a> to convert <code>'b</code> to <code>'a</code> (or vice
versa). This is sometimes needed to ensure termination of fixed-point
algorithms.</p>
<h2><a class="header" href="#extracting-region-constraints" id="extracting-region-constraints">Extracting region constraints</a></h2>
<p>Ultimately, region constraints are only solved at the very end of
type-checking, once all other constraints are known. There are two
ways to solve region constraints right now: lexical and
non-lexical. Eventually there will only be one.</p>
<p>To solve <strong>lexical</strong> region constraints, you invoke
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/struct.InferCtxt.html#method.resolve_regions_and_report_errors"><code>resolve_regions_and_report_errors</code></a>.  This &quot;closes&quot; the region
constraint process and invokes the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/lexical_region_resolve/index.html"><code>lexical_region_resolve</code></a> code. Once
this is done, any further attempt to equate or create a subtyping
relationship will yield an ICE.</p>
<p>Non-lexical region constraints are not handled within the inference
context. Instead, the NLL solver (actually, the MIR type-checker)
invokes <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/struct.InferCtxt.html#method.take_and_reset_region_constraints"><code>take_and_reset_region_constraints</code></a> periodically. This
extracts all of the outlives constraints from the region solver, but
leaves the set of variables intact. This is used to get <em>just</em> the
region constraints that resulted from some particular point in the
program, since the NLL solver needs to know not just <em>what</em> regions
were subregions, but also <em>where</em>. Finally, the NLL solver invokes
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/struct.InferCtxt.html#method.take_region_var_origins"><code>take_region_var_origins</code></a>, which &quot;closes&quot; the region constraint
process in the same way as normal solving.</p>
<h2><a class="header" href="#lexical-region-resolution" id="lexical-region-resolution">Lexical region resolution</a></h2>
<p>Lexical region resolution is done by initially assigning each region
variable to an empty value. We then process each outlives constraint
repeatedly, growing region variables until a fixed-point is reached.
Region variables can be grown using a least-upper-bound relation on
the region lattice in a fairly straightforward fashion.</p>
<h1><a class="header" href="#trait-resolution-old-style" id="trait-resolution-old-style">Trait resolution (old-style)</a></h1>
<p>This chapter describes the general process of <em>trait resolution</em> and points out
some non-obvious things.</p>
<p><strong>Note:</strong> This chapter (and its subchapters) describe how the trait
solver <strong>currently</strong> works. However, we are in the process of
designing a new trait solver. If you'd prefer to read about <em>that</em>,
see <a href="traits/./chalk.html"><em>this</em> subchapter</a>.</p>
<h2><a class="header" href="#major-concepts" id="major-concepts">Major concepts</a></h2>
<p>Trait resolution is the process of pairing up an impl with each
reference to a trait. So, for example, if there is a generic function like:</p>
<pre><code class="language-rust ignore">fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; { ... }
</code></pre>
<p>and then a call to that function:</p>
<pre><code class="language-rust ignore">let v: Vec&lt;isize&gt; = clone_slice(&amp;[1, 2, 3])
</code></pre>
<p>it is the job of trait resolution to figure out whether there exists an impl of
(in this case) <code>isize : Clone</code>.</p>
<p>Note that in some cases, like generic functions, we may not be able to
find a specific impl, but we can figure out that the caller must
provide an impl. For example, consider the body of <code>clone_slice</code>:</p>
<pre><code class="language-rust ignore">fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; {
    let mut v = Vec::new();
    for e in &amp;x {
        v.push((*e).clone()); // (*)
    }
}
</code></pre>
<p>The line marked <code>(*)</code> is only legal if <code>T</code> (the type of <code>*e</code>)
implements the <code>Clone</code> trait. Naturally, since we don't know what <code>T</code>
is, we can't find the specific impl; but based on the bound <code>T:Clone</code>,
we can say that there exists an impl which the caller must provide.</p>
<p>We use the term <em>obligation</em> to refer to a trait reference in need of
an impl. Basically, the trait resolution system resolves an obligation
by proving that an appropriate impl does exist.</p>
<p>During type checking, we do not store the results of trait selection.
We simply wish to verify that trait selection will succeed. Then
later, at trans time, when we have all concrete types available, we
can repeat the trait selection to choose an actual implementation, which
will then be generated in the output binary.</p>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>Trait resolution consists of three major parts:</p>
<ul>
<li>
<p><strong>Selection</strong>: Deciding how to resolve a specific obligation. For
example, selection might decide that a specific obligation can be
resolved by employing an impl which matches the <code>Self</code> type, or by using a
parameter bound (e.g. <code>T: Trait</code>). In the case of an impl, selecting one
obligation can create <em>nested obligations</em> because of where clauses
on the impl itself. It may also require evaluating those nested
obligations to resolve ambiguities.</p>
</li>
<li>
<p><strong>Fulfillment</strong>: The fulfillment code is what tracks that obligations
are completely fulfilled. Basically it is a worklist of obligations
to be selected: once selection is successful, the obligation is
removed from the worklist and any nested obligations are enqueued.</p>
</li>
<li>
<p><strong>Coherence</strong>: The coherence checks are intended to ensure that there
are never overlapping impls, where two impls could be used with
equal precedence.</p>
</li>
</ul>
<h2><a class="header" href="#selection" id="selection">Selection</a></h2>
<p>Selection is the process of deciding whether an obligation can be
resolved and, if so, how it is to be resolved (via impl, where clause, etc).
The main interface is the <code>select()</code> function, which takes an obligation
and returns a <code>SelectionResult</code>. There are three possible outcomes:</p>
<ul>
<li>
<p><code>Ok(Some(selection))</code> – yes, the obligation can be resolved, and
<code>selection</code> indicates how. If the impl was resolved via an impl,
then <code>selection</code> may also indicate nested obligations that are required
by the impl.</p>
</li>
<li>
<p><code>Ok(None)</code> – we are not yet sure whether the obligation can be
resolved or not. This happens most commonly when the obligation
contains unbound type variables.</p>
</li>
<li>
<p><code>Err(err)</code> – the obligation definitely cannot be resolved due to a
type error or because there are no impls that could possibly apply.</p>
</li>
</ul>
<p>The basic algorithm for selection is broken into two big phases:
candidate assembly and confirmation.</p>
<p>Note that because of how lifetime inference works, it is not possible to
give back immediate feedback as to whether a unification or subtype
relationship between lifetimes holds or not. Therefore, lifetime
matching is <em>not</em> considered during selection. This is reflected in
the fact that subregion assignment is infallible. This may yield
lifetime constraints that will later be found to be in error (in
contrast, the non-lifetime-constraints have already been checked
during selection and can never cause an error, though naturally they
may lead to other errors downstream).</p>
<h3><a class="header" href="#candidate-assembly" id="candidate-assembly">Candidate assembly</a></h3>
<p>Searches for impls/where-clauses/etc that might
possibly be used to satisfy the obligation. Each of those is called
a candidate. To avoid ambiguity, we want to find exactly one
candidate that is definitively applicable. In some cases, we may not
know whether an impl/where-clause applies or not – this occurs when
the obligation contains unbound inference variables.</p>
<p>The subroutines that decide whether a particular impl/where-clause/etc
applies to a particular obligation are collectively referred to as the
process of <em>matching</em>. At the moment, this amounts to
unifying the <code>Self</code> types, but in the future we may also recursively
consider some of the nested obligations, in the case of an impl.</p>
<p><strong>TODO</strong>: what does &quot;unifying the <code>Self</code> types&quot; mean? The <code>Self</code> of the
obligation with that of an impl?</p>
<p>The basic idea for candidate assembly is to do a first pass in which
we identify all possible candidates. During this pass, all that we do
is try and unify the type parameters. (In particular, we ignore any
nested where clauses.) Presuming that this unification succeeds, the
impl is added as a candidate.</p>
<p>Once this first pass is done, we can examine the set of candidates. If
it is a singleton set, then we are done: this is the only impl in
scope that could possibly apply. Otherwise, we can winnow down the set
of candidates by using where clauses and other conditions. If this
reduced set yields a single, unambiguous entry, we're good to go,
otherwise the result is considered ambiguous.</p>
<h4><a class="header" href="#the-basic-process-inferring-based-on-the-impls-we-see" id="the-basic-process-inferring-based-on-the-impls-we-see">The basic process: Inferring based on the impls we see</a></h4>
<p>This process is easier if we work through some examples. Consider
the following trait:</p>
<pre><code class="language-rust ignore">trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}
</code></pre>
<p>This trait just has one method. It's about as simple as it gets. It
converts from the (implicit) <code>Self</code> type to the <code>Target</code> type. If we
wanted to permit conversion between <code>isize</code> and <code>usize</code>, we might
implement <code>Convert</code> like so:</p>
<pre><code class="language-rust ignore">impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize
</code></pre>
<p>Now imagine there is some code like the following:</p>
<pre><code class="language-rust ignore">let x: isize = ...;
let y = x.convert();
</code></pre>
<p>The call to convert will generate a trait reference <code>Convert&lt;$Y&gt; for isize</code>, where <code>$Y</code> is the type variable representing the type of
<code>y</code>. Of the two impls we can see, the only one that matches is
<code>Convert&lt;usize&gt; for isize</code>. Therefore, we can
select this impl, which will cause the type of <code>$Y</code> to be unified to
<code>usize</code>. (Note that while assembling candidates, we do the initial
unifications in a transaction, so that they don't affect one another.)</p>
<p><strong>TODO</strong>: The example says we can &quot;select&quot; the impl, but this section is
talking specifically about candidate assembly. Does this mean we can sometimes
skip confirmation? Or is this poor wording?
<strong>TODO</strong>: Is the unification of <code>$Y</code> part of trait resolution or type
inference? Or is this not the same type of &quot;inference variable&quot; as in type
inference?</p>
<h4><a class="header" href="#winnowing-resolving-ambiguities" id="winnowing-resolving-ambiguities">Winnowing: Resolving ambiguities</a></h4>
<p>But what happens if there are multiple impls where all the types
unify? Consider this example:</p>
<pre><code class="language-rust ignore">trait Get {
    fn get(&amp;self) -&gt; Self;
}

impl&lt;T: Copy&gt; Get for T {
    fn get(&amp;self) -&gt; T {
        *self
    }
}

impl&lt;T: Get&gt; Get for Box&lt;T&gt; {
    fn get(&amp;self) -&gt; Box&lt;T&gt; {
        Box::new(&lt;T&gt;::get(self))
    }
}
</code></pre>
<p>What happens when we invoke <code>get_it(&amp;Box::new(1_u16))</code>, for example? In this
case, the <code>Self</code> type is <code>Box&lt;u16&gt;</code> – that unifies with both impls,
because the first applies to all types <code>T</code>, and the second to all
<code>Box&lt;T&gt;</code>. In order for this to be unambiguous, the compiler does a <em>winnowing</em>
pass that considers <code>where</code> clauses
and attempts to remove candidates. In this case, the first impl only
applies if <code>Box&lt;u16&gt; : Copy</code>, which doesn't hold. After winnowing,
then, we are left with just one candidate, so we can proceed.</p>
<h4><a class="header" href="#where-clauses" id="where-clauses"><code>where</code> clauses</a></h4>
<p>Besides an impl, the other major way to resolve an obligation is via a
where clause. The selection process is always given a <a href="traits/../param_env.html">parameter
environment</a> which contains a list of where clauses, which are
basically obligations that we can assume are satisfiable. We will iterate
over that list and check whether our current obligation can be found
in that list. If so, it is considered satisfied. More precisely, we
want to check whether there is a where-clause obligation that is for
the same trait (or some subtrait) and which can match against the obligation.</p>
<p>Consider this simple example:</p>
<pre><code class="language-rust ignore">trait A1 {
    fn do_a1(&amp;self);
}
trait A2 : A1 { ... }

trait B {
    fn do_b(&amp;self);
}

fn foo&lt;X:A2+B&gt;(x: X) {
    x.do_a1(); // (*)
    x.do_b();  // (#)
}
</code></pre>
<p>In the body of <code>foo</code>, clearly we can use methods of <code>A1</code>, <code>A2</code>, or <code>B</code>
on variable <code>x</code>. The line marked <code>(*)</code> will incur an obligation <code>X: A1</code>,
while the line marked <code>(#)</code> will incur an obligation <code>X: B</code>. Meanwhile,
the parameter environment will contain two where-clauses: <code>X : A2</code> and <code>X : B</code>.
For each obligation, then, we search this list of where-clauses. The
obligation <code>X: B</code> trivially matches against the where-clause <code>X: B</code>.
To resolve an obligation <code>X:A1</code>, we would note that <code>X:A2</code> implies that <code>X:A1</code>.</p>
<h3><a class="header" href="#confirmation" id="confirmation">Confirmation</a></h3>
<p><em>Confirmation</em> unifies the output type parameters of the trait with the
values found in the obligation, possibly yielding a type error.</p>
<p>Suppose we have the following variation of the <code>Convert</code> example in the
previous section:</p>
<pre><code class="language-rust ignore">trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}

impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize

let x: isize = ...;
let y: char = x.convert(); // NOTE: `y: char` now!
</code></pre>
<p>Confirmation is where an error would be reported because the impl specified
that <code>Target</code> would be <code>usize</code>, but the obligation reported <code>char</code>. Hence the
result of selection would be an error.</p>
<p>Note that the candidate impl is chosen based on the <code>Self</code> type, but
confirmation is done based on (in this case) the <code>Target</code> type parameter.</p>
<h3><a class="header" href="#selection-during-translation" id="selection-during-translation">Selection during translation</a></h3>
<p>As mentioned above, during type checking, we do not store the results of trait
selection. At trans time, we repeat the trait selection to choose a particular
impl for each method call. In this second selection, we do not consider any
where-clauses to be in scope because we know that each resolution will resolve
to a particular impl.</p>
<p>One interesting twist has to do with nested obligations. In general, in trans,
we only need to do a &quot;shallow&quot; selection for an obligation. That is, we wish to
identify which impl applies, but we do not (yet) need to decide how to select
any nested obligations. Nonetheless, we <em>do</em> currently do a complete resolution,
and that is because it can sometimes inform the results of type inference.
That is, we do not have the full substitutions in terms of the type variables
of the impl available to us, so we must run trait selection to figure
everything out.</p>
<p><strong>TODO</strong>: is this still talking about trans?</p>
<p>Here is an example:</p>
<pre><code class="language-rust ignore">trait Foo { ... }
impl&lt;U, T:Bar&lt;U&gt;&gt; Foo for Vec&lt;T&gt; { ... }

impl Bar&lt;usize&gt; for isize { ... }
</code></pre>
<p>After one shallow round of selection for an obligation like <code>Vec&lt;isize&gt; : Foo</code>, we would know which impl we want, and we would know that
<code>T=isize</code>, but we do not know the type of <code>U</code>.  We must select the
nested obligation <code>isize : Bar&lt;U&gt;</code> to find out that <code>U=usize</code>.</p>
<p>It would be good to only do <em>just as much</em> nested resolution as
necessary. Currently, though, we just do a full resolution.</p>
<h1><a class="header" href="#higher-ranked-trait-bounds" id="higher-ranked-trait-bounds">Higher-ranked trait bounds</a></h1>
<p>One of the more subtle concepts in trait resolution is <em>higher-ranked trait
bounds</em>. An example of such a bound is <code>for&lt;'a&gt; MyTrait&lt;&amp;'a isize&gt;</code>.
Let's walk through how selection on higher-ranked trait references
works.</p>
<h2><a class="header" href="#basic-matching-and-placeholder-leaks" id="basic-matching-and-placeholder-leaks">Basic matching and placeholder leaks</a></h2>
<p>Suppose we have a trait <code>Foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's say we have a function <code>want_hrtb</code> that wants a type which
implements <code>Foo&lt;&amp;'a isize&gt;</code> for any <code>'a</code>:</p>
<pre><code class="language-rust ignore">fn want_hrtb&lt;T&gt;() where T : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt; { ... }
</code></pre>
<p>Now we have a struct <code>AnyInt</code> that implements <code>Foo&lt;&amp;'a isize&gt;</code> for any
<code>'a</code>:</p>
<pre><code class="language-rust ignore">struct AnyInt;
impl&lt;'a&gt; Foo&lt;&amp;'a isize&gt; for AnyInt { }
</code></pre>
<p>And the question is, does <code>AnyInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code>? We want the
answer to be yes. The algorithm for figuring it out is closely related
to the subtyping for higher-ranked types (which is described <a href="traits/./hrtb.html">here</a>
and also in a <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/">paper by SPJ</a>. If you wish to understand higher-ranked
subtyping, we recommend you read the paper). There are a few parts:</p>
<ol>
<li>Replace bound regions in the obligation with placeholders.</li>
<li>Match the impl against the <a href="traits/../appendix/glossary.html#placeholder">placeholder</a> obligation.</li>
<li>Check for <em>placeholder leaks</em>.</li>
</ol>
<p>So let's work through our example.</p>
<ol>
<li>
<p>The first thing we would do is to
replace the bound region in the obligation with a placeholder, yielding 
<code>AnyInt : Foo&lt;&amp;'0 isize&gt;</code> (here <code>'0</code> represents placeholder region #0). 
Note that we now have no quantifiers;
in terms of the compiler type, this changes from a <code>ty::PolyTraitRef</code>
to a <code>TraitRef</code>. We would then create the <code>TraitRef</code> from the impl,
using fresh variables for it's bound regions (and thus getting
<code>Foo&lt;&amp;'$a isize&gt;</code>, where <code>'$a</code> is the inference variable for <code>'a</code>).</p>
</li>
<li>
<p>Next
we relate the two trait refs, yielding a graph with the constraint
that <code>'0 == '$a</code>.</p>
</li>
<li>
<p>Finally, we check for placeholder &quot;leaks&quot; – a
leak is basically any attempt to relate a placeholder region to another
placeholder region, or to any region that pre-existed the impl match.
The leak check is done by searching from the placeholder region to find
the set of regions that it is related to in any way. This is called
the &quot;taint&quot; set. To pass the check, that set must consist <em>solely</em> of
itself and region variables from the impl. If the taint set includes
any other region, then the match is a failure. In this case, the taint
set for <code>'0</code> is <code>{'0, '$a}</code>, and hence the check will succeed.</p>
</li>
</ol>
<p>Let's consider a failure case. Imagine we also have a struct</p>
<pre><code class="language-rust ignore">struct StaticInt;
impl Foo&lt;&amp;'static isize&gt; for StaticInt;
</code></pre>
<p>We want the obligation <code>StaticInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> to be
considered unsatisfied. The check begins just as before. <code>'a</code> is
replaced with a placeholder <code>'0</code> and the impl trait reference is instantiated to
<code>Foo&lt;&amp;'static isize&gt;</code>. When we relate those two, we get a constraint
like <code>'static == '0</code>. This means that the taint set for <code>'0</code> is <code>{'0, 'static}</code>, which fails the leak check.</p>
<p><strong>TODO</strong>: This is because <code>'static</code> is not a region variable but is in the
taint set, right?</p>
<h2><a class="header" href="#higher-ranked-trait-obligations" id="higher-ranked-trait-obligations">Higher-ranked trait obligations</a></h2>
<p>Once the basic matching is done, we get to another interesting topic:
how to deal with impl obligations. I'll work through a simple example
here. Imagine we have the traits <code>Foo</code> and <code>Bar</code> and an associated impl:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}

trait Bar&lt;X&gt; {
    fn bar(&amp;self, x: X) { }
}

impl&lt;X,F&gt; Foo&lt;X&gt; for F
    where F : Bar&lt;X&gt;
{
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let's say we have a obligation <code>Baz: for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> and we match
this impl. What obligation is generated as a result? We want to get
<code>Baz: for&lt;'a&gt; Bar&lt;&amp;'a isize&gt;</code>, but how does that happen?</p>
<p>After the matching, we are in a position where we have a placeholder
substitution like <code>X =&gt; &amp;'0 isize</code>. If we apply this substitution to the
impl obligations, we get <code>F : Bar&lt;&amp;'0 isize&gt;</code>. Obviously this is not
directly usable because the placeholder region <code>'0</code> cannot leak out of
our computation.</p>
<p>What we do is to create an inverse mapping from the taint set of <code>'0</code>
back to the original bound region (<code>'a</code>, here) that <code>'0</code> resulted
from. (This is done in <code>higher_ranked::plug_leaks</code>). We know that the
leak check passed, so this taint set consists solely of the placeholder
region itself plus various intermediate region variables. We then walk
the trait-reference and convert every region in that taint set back to
a late-bound region, so in this case we'd wind up with
<code>Baz: for&lt;'a&gt; Bar&lt;&amp;'a isize&gt;</code>.</p>
<h1><a class="header" href="#caching-and-subtle-considerations-therewith" id="caching-and-subtle-considerations-therewith">Caching and subtle considerations therewith</a></h1>
<p>In general, we attempt to cache the results of trait selection.  This
is a somewhat complex process. Part of the reason for this is that we
want to be able to cache results even when all the types in the trait
reference are not fully known. In that case, it may happen that the
trait selection process is also influencing type variables, so we have
to be able to not only cache the <em>result</em> of the selection process,
but <em>replay</em> its effects on the type variables.</p>
<h2><a class="header" href="#an-example" id="an-example">An example</a></h2>
<p>The high-level idea of how the cache works is that we first replace
all unbound inference variables with placeholder versions. Therefore,
if we had a trait reference <code>usize : Foo&lt;$t&gt;</code>, where <code>$t</code> is an unbound
inference variable, we might replace it with <code>usize : Foo&lt;$0&gt;</code>, where
<code>$0</code> is a placeholder type. We would then look this up in the cache.</p>
<p>If we found a hit, the hit would tell us the immediate next step to
take in the selection process (e.g. apply impl #22, or apply where
clause <code>X : Foo&lt;Y&gt;</code>).</p>
<p>On the other hand, if there is no hit, we need to go through the <a href="traits/./resolution.html#selection">selection
process</a> from scratch. Suppose, we come to the conclusion that the only
possible impl is this one, with def-id 22:</p>
<pre><code class="language-rust ignore">impl Foo&lt;isize&gt; for usize { ... } // Impl #22
</code></pre>
<p>We would then record in the cache <code>usize : Foo&lt;$0&gt; =&gt; ImplCandidate(22)</code>. Next
we would <a href="traits/./resolution.html#confirmation">confirm</a> <code>ImplCandidate(22)</code>, which would (as a side-effect) unify
<code>$t</code> with <code>isize</code>.</p>
<p>Now, at some later time, we might come along and see a <code>usize : Foo&lt;$u&gt;</code>. When replaced with a placeholder, this would yield <code>usize : Foo&lt;$0&gt;</code>, just as
before, and hence the cache lookup would succeed, yielding
<code>ImplCandidate(22)</code>. We would confirm <code>ImplCandidate(22)</code> which would
(as a side-effect) unify <code>$u</code> with <code>isize</code>.</p>
<h2><a class="header" href="#where-clauses-and-the-local-vs-global-cache" id="where-clauses-and-the-local-vs-global-cache">Where clauses and the local vs global cache</a></h2>
<p>One subtle interaction is that the results of trait lookup will vary
depending on what where clauses are in scope. Therefore, we actually
have <em>two</em> caches, a local and a global cache. The local cache is
attached to the <a href="traits/../param_env.html"><code>ParamEnv</code></a>, and the global cache attached to the
<a href="traits/../ty.html"><code>tcx</code></a>. We use the local cache whenever the result might depend on the
where clauses that are in scope. The determination of which cache to
use is done by the method <code>pick_candidate_cache</code> in <code>select.rs</code>. At
the moment, we use a very simple, conservative rule: if there are any
where-clauses in scope, then we use the local cache.  We used to try
and draw finer-grained distinctions, but that led to a serious of
annoying and weird bugs like <a href="https://github.com/rust-lang/rust/issues/22019">#22019</a> and <a href="https://github.com/rust-lang/rust/issues/18290">#18290</a>. This simple rule seems
to be pretty clearly safe and also still retains a very high hit rate
(~95% when compiling rustc).</p>
<p><strong>TODO</strong>: it looks like <code>pick_candidate_cache</code> no longer exists. In
general, is this section still accurate at all?</p>
<h1><a class="header" href="#specialization" id="specialization">Specialization</a></h1>
<p><strong>TODO</strong>: where does Chalk fit in? Should we mention/discuss it here?</p>
<p>Defined in the <code>specialize</code> module.</p>
<p>The basic strategy is to build up a <em>specialization graph</em> during
coherence checking (recall that coherence checking looks for overlapping
impls). Insertion into the graph locates the right place
to put an impl in the specialization hierarchy; if there is no right
place (due to partial overlap but no containment), you get an overlap
error. Specialization is consulted when selecting an impl (of course),
and the graph is consulted when propagating defaults down the
specialization hierarchy.</p>
<p>You might expect that the specialization graph would be used during
selection – i.e. when actually performing specialization. This is
not done for two reasons:</p>
<ul>
<li>
<p>It's merely an optimization: given a set of candidates that apply,
we can determine the most specialized one by comparing them directly
for specialization, rather than consulting the graph. Given that we
also cache the results of selection, the benefit of this
optimization is questionable.</p>
</li>
<li>
<p>To build the specialization graph in the first place, we need to use
selection (because we need to determine whether one impl specializes
another). Dealing with this reentrancy would require some additional
mode switch for selection. Given that there seems to be no strong
reason to use the graph anyway, we stick with a simpler approach in
selection, and use the graph only for propagating default
implementations.</p>
</li>
</ul>
<p>Trait impl selection can succeed even when multiple impls can apply,
as long as they are part of the same specialization family. In that
case, it returns a <em>single</em> impl on success – this is the most
specialized impl <em>known</em> to apply. However, if there are any inference
variables in play, the returned impl may not be the actual impl we
will use at trans time. Thus, we take special care to avoid projecting
associated types unless either (1) the associated type does not use
<code>default</code> and thus cannot be overridden or (2) all input types are
known concretely.</p>
<h2><a class="header" href="#additional-resources" id="additional-resources">Additional Resources</a></h2>
<p><a href="https://www.youtube.com/watch?v=rZqS4bLPL24">This talk</a> by @sunjay may be useful. Keep in mind that the talk only
gives a broad overview of the problem and the solution (it was presented about
halfway through @sunjay's work). Also, it was given in June 2018, and some
things may have changed by the time you watch it.</p>
<h1><a class="header" href="#chalk-based-trait-solving" id="chalk-based-trait-solving">Chalk-based trait solving</a></h1>
<p><a href="https://github.com/rust-lang/chalk">Chalk</a> is an experimental trait solver for rust that is currently
under development by the <a href="https://github.com/rust-lang/rust/issues/48416">Traits Working Group</a>. Its goal is
to enable a lot of trait system features and bug fixes that are
currently hard to implement (e.g. GATs or specialization).  if you 
would like to help in hacking on the new solver, you will find
instructions for getting involved in the
<a href="https://github.com/rust-lang/rust/issues/48416">Traits Working Group tracking issue</a>.</p>
<p>The new-style trait solver is based on the work done in <a href="https://github.com/rust-lang/chalk">chalk</a>. Chalk
recasts Rust's trait system explicitly in terms of logic programming. It does
this by &quot;lowering&quot; Rust code into a kind of logic program we can then execute
queries against.</p>
<p>The key observation here is that the Rust trait system is basically a
kind of logic, and it can be mapped onto standard logical inference
rules. We can then look for solutions to those inference rules in a
very similar fashion to how e.g. a <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> solver works. It turns out
that we can't <em>quite</em> use Prolog rules (also called Horn clauses) but
rather need a somewhat more expressive variant.</p>
<p>You can read more about chalk itself in the
<a href="https://rust-lang.github.io/chalk/book/">Chalk book</a> section.</p>
<h2><a class="header" href="#ongoing-work" id="ongoing-work">Ongoing work</a></h2>
<p>The design of the new-style trait solving currently happens in two places:</p>
<p><strong>chalk</strong>. The <a href="https://github.com/rust-lang/chalk">chalk</a> repository is where we experiment with new ideas
and designs for the trait system.</p>
<p><strong>rustc</strong>. Once we are happy with the logical rules, we proceed to
implementing them in rustc. We map our struct, trait, and impl declarations
into logical inference rules in the <a href="traits/./lowering-module.html">lowering module in rustc</a>.</p>
<h1><a class="header" href="#lowering-to-logic" id="lowering-to-logic">Lowering to logic</a></h1>
<p>The key observation here is that the Rust trait system is basically a
kind of logic, and it can be mapped onto standard logical inference
rules. We can then look for solutions to those inference rules in a
very similar fashion to how e.g. a <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> solver works. It turns out
that we can't <em>quite</em> use Prolog rules (also called Horn clauses) but
rather need a somewhat more expressive variant.</p>
<h2><a class="header" href="#rust-traits-and-logic" id="rust-traits-and-logic">Rust traits and logic</a></h2>
<p>One of the first observations is that the Rust trait system is
basically a kind of logic. As such, we can map our struct, trait, and
impl declarations into logical inference rules. For the most part,
these are basically Horn clauses, though we'll see that to capture the
full richness of Rust – and in particular to support generic
programming – we have to go a bit further than standard Horn clauses.</p>
<p>To see how this mapping works, let's start with an example. Imagine
we declare a trait and a few impls, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Clone { }
impl Clone for usize { }
impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
<span class="boring">}
</span></code></pre></pre>
<p>We could map these declarations to some Horn clauses, written in a
Prolog-like notation, as follows:</p>
<pre><code class="language-text">Clone(usize).
Clone(Vec&lt;?T&gt;) :- Clone(?T).

// The notation `A :- B` means &quot;A is true if B is true&quot;.
// Or, put another way, B implies A.
</code></pre>
<p>In Prolog terms, we might say that <code>Clone(Foo)</code> – where <code>Foo</code> is some
Rust type – is a <em>predicate</em> that represents the idea that the type
<code>Foo</code> implements <code>Clone</code>. These rules are <strong>program clauses</strong>; they
state the conditions under which that predicate can be proven (i.e.,
considered true). So the first rule just says &quot;Clone is implemented
for <code>usize</code>&quot;. The next rule says &quot;for any type <code>?T</code>, Clone is
implemented for <code>Vec&lt;?T&gt;</code> if clone is implemented for <code>?T</code>&quot;. So
e.g. if we wanted to prove that <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code>, we would do
so by applying the rules recursively:</p>
<ul>
<li><code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code> is provable if:
<ul>
<li><code>Clone(Vec&lt;usize&gt;)</code> is provable if:
<ul>
<li><code>Clone(usize)</code> is provable. (Which it is, so we're all good.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>But now suppose we tried to prove that <code>Clone(Vec&lt;Bar&gt;)</code>. This would
fail (after all, I didn't give an impl of <code>Clone</code> for <code>Bar</code>):</p>
<ul>
<li><code>Clone(Vec&lt;Bar&gt;)</code> is provable if:
<ul>
<li><code>Clone(Bar)</code> is provable. (But it is not, as there are no applicable rules.)</li>
</ul>
</li>
</ul>
<p>We can easily extend the example above to cover generic traits with
more than one input type. So imagine the <code>Eq&lt;T&gt;</code> trait, which declares
that <code>Self</code> is equatable with a value of type <code>T</code>:</p>
<pre><code class="language-rust ignore">trait Eq&lt;T&gt; { ... }
impl Eq&lt;usize&gt; for usize { }
impl&lt;T: Eq&lt;U&gt;&gt; Eq&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt; { }
</code></pre>
<p>That could be mapped as follows:</p>
<pre><code class="language-text">Eq(usize, usize).
Eq(Vec&lt;?T&gt;, Vec&lt;?U&gt;) :- Eq(?T, ?U).
</code></pre>
<p>So far so good.</p>
<h2><a class="header" href="#type-checking-normal-functions" id="type-checking-normal-functions">Type-checking normal functions</a></h2>
<p>OK, now that we have defined some logical rules that are able to
express when traits are implemented and to handle associated types,
let's turn our focus a bit towards <strong>type-checking</strong>. Type-checking is
interesting because it is what gives us the goals that we need to
prove. That is, everything we've seen so far has been about how we
derive the rules by which we can prove goals from the traits and impls
in the program; but we are also interested in how to derive the goals
that we need to prove, and those come from type-checking.</p>
<p>Consider type-checking the function <code>foo()</code> here:</p>
<pre><code class="language-rust ignore">fn foo() { bar::&lt;usize&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>This function is very simple, of course: all it does is to call
<code>bar::&lt;usize&gt;()</code>. Now, looking at the definition of <code>bar()</code>, we can see
that it has one where-clause <code>U: Eq&lt;U&gt;</code>. So, that means that <code>foo()</code> will
have to prove that <code>usize: Eq&lt;usize&gt;</code> in order to show that it can call <code>bar()</code>
with <code>usize</code> as the type argument.</p>
<p>If we wanted, we could write a Prolog predicate that defines the
conditions under which <code>bar()</code> can be called. We'll say that those
conditions are called being &quot;well-formed&quot;:</p>
<pre><code class="language-text">barWellFormed(?U) :- Eq(?U, ?U).
</code></pre>
<p>Then we can say that <code>foo()</code> type-checks if the reference to
<code>bar::&lt;usize&gt;</code> (that is, <code>bar()</code> applied to the type <code>usize</code>) is
well-formed:</p>
<pre><code class="language-text">fooTypeChecks :- barWellFormed(usize).
</code></pre>
<p>If we try to prove the goal <code>fooTypeChecks</code>, it will succeed:</p>
<ul>
<li><code>fooTypeChecks</code> is provable if:
<ul>
<li><code>barWellFormed(usize)</code>, which is provable if:
<ul>
<li><code>Eq(usize, usize)</code>, which is provable because of an impl.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ok, so far so good. Let's move on to type-checking a more complex function.</p>
<h2><a class="header" href="#type-checking-generic-functions-beyond-horn-clauses" id="type-checking-generic-functions-beyond-horn-clauses">Type-checking generic functions: beyond Horn clauses</a></h2>
<p>In the last section, we used standard Prolog horn-clauses (augmented with Rust's
notion of type equality) to type-check some simple Rust functions. But that only
works when we are type-checking non-generic functions. If we want to type-check
a generic function, it turns out we need a stronger notion of goal than what Prolog
can provide. To see what I'm talking about, let's revamp our previous
example to make <code>foo</code> generic:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Eq&lt;T&gt;&gt;() { bar::&lt;T&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>To type-check the body of <code>foo</code>, we need to be able to hold the type
<code>T</code> &quot;abstract&quot;.  That is, we need to check that the body of <code>foo</code> is
type-safe <em>for all types <code>T</code></em>, not just for some specific type. We might express
this like so:</p>
<pre><code class="language-text">fooTypeChecks :-
  // for all types T...
  forall&lt;T&gt; {
    // ...if we assume that Eq(T, T) is provable...
    if (Eq(T, T)) {
      // ...then we can prove that `barWellFormed(T)` holds.
      barWellFormed(T)
    }
  }.
</code></pre>
<p>This notation I'm using here is the notation I've been using in my
prototype implementation; it's similar to standard mathematical
notation but a bit Rustified. Anyway, the problem is that standard
Horn clauses don't allow universal quantification (<code>forall</code>) or
implication (<code>if</code>) in goals (though many Prolog engines do support
them, as an extension). For this reason, we need to accept something
called &quot;first-order hereditary harrop&quot; (FOHH) clauses – this long
name basically means &quot;standard Horn clauses with <code>forall</code> and <code>if</code> in
the body&quot;. But it's nice to know the proper name, because there is a
lot of work describing how to efficiently handle FOHH clauses; see for
example Gopalan Nadathur's excellent
<a href="https://rust-lang.github.io/chalk/book/bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
in <a href="https://rust-lang.github.io/chalk/book/bibliography.html">the bibliography of Chalk Book</a>.</p>
<p>It turns out that supporting FOHH is not really all that hard. And
once we are able to do that, we can easily describe the type-checking
rule for generic functions like <code>foo</code> in our logic.</p>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p>This page is a lightly adapted version of a
<a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">blog post by Nicholas Matsakis</a>.</p>
<h1><a class="header" href="#goals-and-clauses" id="goals-and-clauses">Goals and clauses</a></h1>
<p>In logic programming terms, a <strong>goal</strong> is something that you must
prove and a <strong>clause</strong> is something that you know is true. As
described in the <a href="traits/./lowering-to-logic.html">lowering to logic</a>
chapter, Rust's trait solver is based on an extension of hereditary
harrop (HH) clauses, which extend traditional Prolog Horn clauses with
a few new superpowers.</p>
<h2><a class="header" href="#goals-and-clauses-meta-structure" id="goals-and-clauses-meta-structure">Goals and clauses meta structure</a></h2>
<p>In Rust's solver, <strong>goals</strong> and <strong>clauses</strong> have the following forms
(note that the two definitions reference one another):</p>
<pre><code class="language-text">Goal = DomainGoal           // defined in the section below
        | Goal &amp;&amp; Goal
        | Goal || Goal
        | exists&lt;K&gt; { Goal }   // existential quantification
        | forall&lt;K&gt; { Goal }   // universal quantification
        | if (Clause) { Goal } // implication
        | true                 // something that's trivially true
        | ambiguous            // something that's never provable

Clause = DomainGoal
        | Clause :- Goal     // if can prove Goal, then Clause is true
        | Clause &amp;&amp; Clause
        | forall&lt;K&gt; { Clause }

K = &lt;type&gt;     // a &quot;kind&quot;
    | &lt;lifetime&gt;
</code></pre>
<p>The proof procedure for these sorts of goals is actually quite
straightforward.  Essentially, it's a form of depth-first search. The
paper
<a href="https://rust-lang.github.io/chalk/book/bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
gives the details.</p>
<p>In terms of code, these types are defined in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_middle/traits/mod.rs"><code>librustc_middle/traits/mod.rs</code></a> in rustc, and in
<a href="https://github.com/rust-lang/chalk/blob/master/chalk-ir/src/lib.rs"><code>chalk-ir/src/lib.rs</code></a> in chalk.</p>
<p><a name="domain-goals"></a></p>
<h2><a class="header" href="#domain-goals" id="domain-goals">Domain goals</a></h2>
<p><em>Domain goals</em> are the atoms of the trait logic. As can be seen in the
definitions given above, general goals basically consist in a combination of
domain goals.</p>
<p>Moreover, flattening a bit the definition of clauses given previously, one can
see that clauses are always of the form:</p>
<pre><code class="language-text">forall&lt;K1, ..., Kn&gt; { DomainGoal :- Goal }
</code></pre>
<p>hence domain goals are in fact clauses' LHS. That is, at the most granular level,
domain goals are what the trait solver will end up trying to prove.</p>
<p><a name="trait-ref"></a></p>
<p>To define the set of domain goals in our system, we need to first
introduce a few simple formulations. A <strong>trait reference</strong> consists of
the name of a trait along with a suitable set of inputs P0..Pn:</p>
<pre><code class="language-text">TraitRef = P0: TraitName&lt;P1..Pn&gt;
</code></pre>
<p>So, for example, <code>u32: Display</code> is a trait reference, as is <code>Vec&lt;T&gt;: IntoIterator</code>. Note that Rust surface syntax also permits some extra
things, like associated type bindings (<code>Vec&lt;T&gt;: IntoIterator&lt;Item = T&gt;</code>), that are not part of a trait reference.</p>
<p><a name="projection"></a></p>
<p>A <strong>projection</strong> consists of an associated item reference along with
its inputs P0..Pm:</p>
<pre><code class="language-text">Projection = &lt;P0 as TraitName&lt;P1..Pn&gt;&gt;::AssocItem&lt;Pn+1..Pm&gt;
</code></pre>
<p>Given these, we can define a <code>DomainGoal</code> as follows:</p>
<pre><code class="language-text">DomainGoal = Holds(WhereClause)
            | FromEnv(TraitRef)
            | FromEnv(Type)
            | WellFormed(TraitRef)
            | WellFormed(Type)
            | Normalize(Projection -&gt; Type)

WhereClause = Implemented(TraitRef)
            | ProjectionEq(Projection = Type)
            | Outlives(Type: Region)
            | Outlives(Region: Region)
</code></pre>
<p><code>WhereClause</code> refers to a <code>where</code> clause that a Rust user would actually be able
to write in a Rust program. This abstraction exists only as a convenience as we
sometimes want to only deal with domain goals that are effectively writable in
Rust.</p>
<p>Let's break down each one of these, one-by-one.</p>
<h4><a class="header" href="#implementedtraitref" id="implementedtraitref">Implemented(TraitRef)</a></h4>
<p>e.g. <code>Implemented(i32: Copy)</code></p>
<p>True if the given trait is implemented for the given input types and lifetimes.</p>
<h4><a class="header" href="#projectioneqprojection--type" id="projectioneqprojection--type">ProjectionEq(Projection = Type)</a></h4>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item = u8</code></p>
<p>The given associated type <code>Projection</code> is equal to <code>Type</code>; this can be proved
with either normalization or using placeholder associated types. See
<a href="https://rust-lang.github.io/chalk/book/clauses/type_equality.html">the section on associated types in Chalk Book</a>.</p>
<h4><a class="header" href="#normalizeprojection---type" id="normalizeprojection---type">Normalize(Projection -&gt; Type)</a></h4>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item -&gt; u8</code></p>
<p>The given associated type <code>Projection</code> can be <a href="https://rust-lang.github.io/chalk/book/clauses/type_equality.html#normalize">normalized</a> to <code>Type</code>.</p>
<p>As discussed in <a href="https://rust-lang.github.io/chalk/book/clauses/type_equality.html">the section on associated
types in Chalk Book</a>, <code>Normalize</code> implies <code>ProjectionEq</code>,
but not vice versa. In general, proving <code>Normalize(&lt;T as Trait&gt;::Item -&gt; U)</code>
also requires proving <code>Implemented(T: Trait)</code>.</p>
<h4><a class="header" href="#fromenvtraitref" id="fromenvtraitref">FromEnv(TraitRef)</a></h4>
<p>e.g. <code>FromEnv(Self: Add&lt;i32&gt;)</code></p>
<p>True if the inner <code>TraitRef</code> is <em>assumed</em> to be true,
that is, if it can be derived from the in-scope where clauses.</p>
<p>For example, given the following function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn loud_clone&lt;T: Clone&gt;(stuff: &amp;T) -&gt; T {
    println!(&quot;cloning!&quot;);
    stuff.clone()
}
<span class="boring">}
</span></code></pre></pre>
<p>Inside the body of our function, we would have <code>FromEnv(T: Clone)</code>. In-scope
where clauses nest, so a function body inside an impl body inherits the
impl body's where clauses, too.</p>
<p>This and the next rule are used to implement <a href="https://rust-lang.github.io/chalk/book/clauses/implied_bounds.html#implied-bounds">implied bounds</a>. As we'll see
in the section on lowering, <code>FromEnv(TraitRef)</code> implies <code>Implemented(TraitRef)</code>,
but not vice versa. This distinction is crucial to implied bounds.</p>
<h4><a class="header" href="#fromenvtype" id="fromenvtype">FromEnv(Type)</a></h4>
<p>e.g. <code>FromEnv(HashSet&lt;K&gt;)</code></p>
<p>True if the inner <code>Type</code> is <em>assumed</em> to be well-formed, that is, if it is an
input type of a function or an impl.</p>
<p>For example, given the following code:</p>
<pre><code class="language-rust ignore">struct HashSet&lt;K&gt; where K: Hash { ... }

fn loud_insert&lt;K&gt;(set: &amp;mut HashSet&lt;K&gt;, item: K) {
    println!(&quot;inserting!&quot;);
    set.insert(item);
}
</code></pre>
<p><code>HashSet&lt;K&gt;</code> is an input type of the <code>loud_insert</code> function. Hence, we assume it
to be well-formed, so we would have <code>FromEnv(HashSet&lt;K&gt;)</code> inside the body of our
function. As we'll see in the section on lowering, <code>FromEnv(HashSet&lt;K&gt;)</code> implies
<code>Implemented(K: Hash)</code> because the
<code>HashSet</code> declaration was written with a <code>K: Hash</code> where clause. Hence, we don't
need to repeat that bound on the <code>loud_insert</code> function: we rather automatically
assume that it is true.</p>
<h4><a class="header" href="#wellformeditem" id="wellformeditem">WellFormed(Item)</a></h4>
<p>These goals imply that the given item is <em>well-formed</em>.</p>
<p>We can talk about different types of items being well-formed:</p>
<ul>
<li>
<p><em>Types</em>, like <code>WellFormed(Vec&lt;i32&gt;)</code>, which is true in Rust, or
<code>WellFormed(Vec&lt;str&gt;)</code>, which is not (because <code>str</code> is not <code>Sized</code>.)</p>
</li>
<li>
<p><em>TraitRefs</em>, like <code>WellFormed(Vec&lt;i32&gt;: Clone)</code>.</p>
</li>
</ul>
<p>Well-formedness is important to <a href="https://rust-lang.github.io/chalk/book/clauses/implied_bounds.html#implied-bounds">implied bounds</a>. In particular, the reason
it is okay to assume <code>FromEnv(T: Clone)</code> in the <code>loud_clone</code> example is that we
<em>also</em> verify <code>WellFormed(T: Clone)</code> for each call site of <code>loud_clone</code>.
Similarly, it is okay to assume <code>FromEnv(HashSet&lt;K&gt;)</code> in the <code>loud_insert</code>
example because we will verify <code>WellFormed(HashSet&lt;K&gt;)</code> for each call site of
<code>loud_insert</code>. </p>
<h4><a class="header" href="#outlivestype-region-outlivesregion-region" id="outlivestype-region-outlivesregion-region">Outlives(Type: Region), Outlives(Region: Region)</a></h4>
<p>e.g. <code>Outlives(&amp;'a str: 'b)</code>, <code>Outlives('a: 'static)</code></p>
<p>True if the given type or region on the left outlives the right-hand region.</p>
<p><a name="coinductive"></a></p>
<h2><a class="header" href="#coinductive-goals" id="coinductive-goals">Coinductive goals</a></h2>
<p>Most goals in our system are &quot;inductive&quot;. In an inductive goal,
circular reasoning is disallowed. Consider this example clause:</p>
<pre><code class="language-text">    Implemented(Foo: Bar) :-
        Implemented(Foo: Bar).
</code></pre>
<p>Considered inductively, this clause is useless: if we are trying to
prove <code>Implemented(Foo: Bar)</code>, we would then recursively have to prove
<code>Implemented(Foo: Bar)</code>, and that cycle would continue ad infinitum
(the trait solver will terminate here, it would just consider that
<code>Implemented(Foo: Bar)</code> is not known to be true).</p>
<p>However, some goals are <em>co-inductive</em>. Simply put, this means that
cycles are OK. So, if <code>Bar</code> were a co-inductive trait, then the rule
above would be perfectly valid, and it would indicate that
<code>Implemented(Foo: Bar)</code> is true.</p>
<p><em>Auto traits</em> are one example in Rust where co-inductive goals are used.
Consider the <code>Send</code> trait, and imagine that we have this struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Foo {
    next: Option&lt;Box&lt;Foo&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>The default rules for auto traits say that <code>Foo</code> is <code>Send</code> if the
types of its fields are <code>Send</code>. Therefore, we would have a rule like</p>
<pre><code class="language-text">Implemented(Foo: Send) :-
    Implemented(Option&lt;Box&lt;Foo&gt;&gt;: Send).
</code></pre>
<p>As you can probably imagine, proving that <code>Option&lt;Box&lt;Foo&gt;&gt;: Send</code> is
going to wind up circularly requiring us to prove that <code>Foo: Send</code>
again. So this would be an example where we wind up in a cycle – but
that's ok, we <em>do</em> consider <code>Foo: Send</code> to hold, even though it
references itself.</p>
<p>In general, co-inductive traits are used in Rust trait solving when we
want to enumerate a fixed set of possibilities. In the case of auto
traits, we are enumerating the set of reachable types from a given
starting point (i.e., <code>Foo</code> can reach values of type
<code>Option&lt;Box&lt;Foo&gt;&gt;</code>, which implies it can reach values of type
<code>Box&lt;Foo&gt;</code>, and then of type <code>Foo</code>, and then the cycle is complete).</p>
<p>In addition to auto traits, <code>WellFormed</code> predicates are co-inductive.
These are used to achieve a similar &quot;enumerate all the cases&quot; pattern,
as described in the section on <a href="https://rust-lang.github.io/chalk/book/clauses/implied_bounds.html#implied-bounds">implied bounds</a>.</p>
<h2><a class="header" href="#incomplete-chapter" id="incomplete-chapter">Incomplete chapter</a></h2>
<p>Some topics yet to be written:</p>
<ul>
<li>Elaborate on the proof procedure</li>
<li>SLG solving – introduce negative reasoning</li>
</ul>
<h1><a class="header" href="#canonical-queries" id="canonical-queries">Canonical queries</a></h1>
<p>The &quot;start&quot; of the trait system is the <strong>canonical query</strong> (these are
both queries in the more general sense of the word – something you
would like to know the answer to – and in the
<a href="traits/../query.html">rustc-specific sense</a>).  The idea is that the type
checker or other parts of the system, may in the course of doing their
thing want to know whether some trait is implemented for some type
(e.g., is <code>u32: Debug</code> true?). Or they may want to
normalize some associated type.</p>
<p>This section covers queries at a fairly high level of abstraction. The
subsections look a bit more closely at how these ideas are implemented
in rustc.</p>
<h2><a class="header" href="#the-traditional-interactive-prolog-query" id="the-traditional-interactive-prolog-query">The traditional, interactive Prolog query</a></h2>
<p>In a traditional Prolog system, when you start a query, the solver
will run off and start supplying you with every possible answer it can
find. So given something like this:</p>
<pre><code class="language-text">?- Vec&lt;i32&gt;: AsRef&lt;?U&gt;
</code></pre>
<p>The solver might answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;[i32]&gt;
    continue? (y/n)
</code></pre>
<p>This <code>continue</code> bit is interesting. The idea in Prolog is that the
solver is finding <strong>all possible</strong> instantiations of your query that
are true. In this case, if we instantiate <code>?U = [i32]</code>, then the query
is true (note that a traditional Prolog interface does not, directly,
tell us a value for <code>?U</code>, but we can infer one by unifying the
response with our original query – Rust's solver gives back a
substitution instead). If we were to hit <code>y</code>, the solver might then
give us another possible answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;Vec&lt;i32&gt;&gt;
    continue? (y/n)
</code></pre>
<p>This answer derives from the fact that there is a reflexive impl
(<code>impl&lt;T&gt; AsRef&lt;T&gt; for T</code>) for <code>AsRef</code>. If were to hit <code>y</code> again,
then we might get back a negative response:</p>
<pre><code class="language-text">no
</code></pre>
<p>Naturally, in some cases, there may be no possible answers, and hence
the solver will just give me back <code>no</code> right away:</p>
<pre><code class="language-text">?- Box&lt;i32&gt;: Copy
    no
</code></pre>
<p>In some cases, there might be an infinite number of responses. So for
example if I gave this query, and I kept hitting <code>y</code>, then the solver
would never stop giving me back answers:</p>
<pre><code class="language-text">?- Vec&lt;?U&gt;: Clone
    Vec&lt;i32&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;i32&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;&gt;: Clone
        continue? (y/n)
</code></pre>
<p>As you can imagine, the solver will gleefully keep adding another
layer of <code>Box</code> until we ask it to stop, or it runs out of memory.</p>
<p>Another interesting thing is that queries might still have variables
in them. For example:</p>
<pre><code class="language-text">?- Rc&lt;?T&gt;: Clone
</code></pre>
<p>might produce the answer:</p>
<pre><code class="language-text">Rc&lt;?T&gt;: Clone
    continue? (y/n)
</code></pre>
<p>After all, <code>Rc&lt;?T&gt;</code> is true <strong>no matter what type <code>?T</code> is</strong>.</p>
<p><a name="query-response"></a></p>
<h2><a class="header" href="#a-trait-query-in-rustc" id="a-trait-query-in-rustc">A trait query in rustc</a></h2>
<p>The trait queries in rustc work somewhat differently. Instead of
trying to enumerate <strong>all possible</strong> answers for you, they are looking
for an <strong>unambiguous</strong> answer. In particular, when they tell you the
value for a type variable, that means that this is the <strong>only possible
instantiation</strong> that you could use, given the current set of impls and
where-clauses, that would be provable.</p>
<p>The response to a trait query in rustc is typically a
<code>Result&lt;QueryResult&lt;T&gt;, NoSolution&gt;</code> (where the <code>T</code> will vary a bit
depending on the query itself). The <code>Err(NoSolution)</code> case indicates
that the query was false and had no answers (e.g., <code>Box&lt;i32&gt;: Copy</code>).
Otherwise, the <code>QueryResult</code> gives back information about the possible answer(s)
we did find. It consists of four parts:</p>
<ul>
<li><strong>Certainty:</strong> tells you how sure we are of this answer. It can have two
values:
<ul>
<li><code>Proven</code> means that the result is known to be true.
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;i32&gt;: Clone</code>,
say, or <code>Rc&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
<li><code>Ambiguous</code> means that there were things we could not yet prove to
be either true <em>or</em> false, typically because more type information
was needed. (We'll see an example shortly.)
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Var values:</strong> Values for each of the unbound inference variables
(like <code>?T</code>) that appeared in your original query. (Remember that in Prolog,
we had to infer these.)
<ul>
<li>As we'll see in the example below, we can get back var values even
for <code>Ambiguous</code> cases.</li>
</ul>
</li>
<li><strong>Region constraints:</strong> these are relations that must hold between
the lifetimes that you supplied as inputs. We'll ignore these here.</li>
<li><strong>Value:</strong> The query result also comes with a value of type <code>T</code>. For
some specialized queries – like normalizing associated types –
this is used to carry back an extra result, but it's often just
<code>()</code>.</li>
</ul>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Let's work through an example query to see what all the parts mean.
Consider <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">the <code>Borrow</code> trait</a>. This trait has a number of
impls; among them, there are these two (for clarity, I've written the
<code>Sized</code> bounds explicitly):</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
impl&lt;T&gt; Borrow&lt;[T]&gt; for Vec&lt;T&gt; where T: Sized
</code></pre>
<p><strong>Example 1.</strong> Imagine we are type-checking this (rather artificial)
bit of code:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // Example 1: requires `Vec&lt;?T&gt;: Borrow&lt;?U&gt;`
    ...
}
</code></pre>
<p>As the comments indicate, we first create two variables <code>t</code> and <code>u</code>;
<code>t</code> is an empty vector and <code>u</code> is a <code>None</code> option. Both of these
variables have unbound inference variables in their type: <code>?T</code>
represents the elements in the vector <code>t</code> and <code>?U</code> represents the
value stored in the option <code>u</code>.  Next, we invoke <code>foo</code>; comparing the
signature of <code>foo</code> to its arguments, we wind up with <code>A = Vec&lt;?T&gt;</code> and
<code>B = ?U</code>. Therefore, the where clause on <code>foo</code> requires that <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. This is thus our first example trait query.</p>
<p>There are many possible solutions to the query <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>;
for example:</p>
<ul>
<li><code>?U = Vec&lt;?T&gt;</code>,</li>
<li><code>?U = [?T]</code>,</li>
<li><code>?T = u32, ?U = [u32]</code></li>
<li>and so forth.</li>
</ul>
<p>Therefore, the result we get back would be as follows (I'm going to
ignore region constraints and the &quot;value&quot;):</p>
<ul>
<li>Certainty: <code>Ambiguous</code> – we're not sure yet if this holds</li>
<li>Var values: <code>[?T = ?T, ?U = ?U]</code> – we learned nothing about the values of
the variables</li>
</ul>
<p>In short, the query result says that it is too soon to say much about
whether this trait is proven. During type-checking, this is not an
immediate error: instead, the type checker would hold on to this
requirement (<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>) and wait. As we'll see in the next
example, it may happen that <code>?T</code> and <code>?U</code> wind up constrained from
other sources, in which case we can try the trait query again.</p>
<p><strong>Example 2.</strong> We can now extend our previous example a bit,
and assign a value to <code>u</code>:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    // What we saw before:
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // `Vec&lt;?T&gt;: Borrow&lt;?U&gt;` =&gt; ambiguous

    // New stuff:
    u = Some(vec![]); // ?U = Vec&lt;?V&gt;
}
</code></pre>
<p>As a result of this assignment, the type of <code>u</code> is forced to be
<code>Option&lt;Vec&lt;?V&gt;&gt;</code>, where <code>?V</code> represents the element type of the
vector. This in turn implies that <code>?U</code> is <a href="traits/../type-checking.html">unified</a> to <code>Vec&lt;?V&gt;</code>.</p>
<p>Let's suppose that the type checker decides to revisit the
&quot;as-yet-unproven&quot; trait obligation we saw before, <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. <code>?U</code> is no longer an unbound inference variable; it now
has a value, <code>Vec&lt;?V&gt;</code>. So, if we &quot;refresh&quot; the query with that value, we get:</p>
<pre><code class="language-text">Vec&lt;?T&gt;: Borrow&lt;Vec&lt;?V&gt;&gt;
</code></pre>
<p>This time, there is only one impl that applies, the reflexive impl:</p>
<pre><code class="language-text">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
</code></pre>
<p>Therefore, the trait checker will answer:</p>
<ul>
<li>Certainty: <code>Proven</code></li>
<li>Var values: <code>[?T = ?T, ?V = ?T]</code></li>
</ul>
<p>Here, it is saying that we have indeed proven that the obligation
holds, and we also know that <code>?T</code> and <code>?V</code> are the same type (but we
don't know what that type is yet!).</p>
<p>(In fact, as the function ends here, the type checker would give an
error at this point, since the element types of <code>t</code> and <code>u</code> are still
not yet known, even though they are known to be the same.)</p>
<h1><a class="header" href="#the-lowering-module-in-rustc" id="the-lowering-module-in-rustc">The lowering module in rustc</a></h1>
<p>This work is ongoing. This section will be filled in once some of it has landed in <code>rustc</code>. </p>
<h1><a class="header" href="#type-checking" id="type-checking">Type checking</a></h1>
<p>The <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_typeck"><code>rustc_typeck</code></a> crate contains the source for &quot;type collection&quot;
and &quot;type checking&quot;, as well as a few other bits of related functionality. (It
draws heavily on the <a href="type-inference.html">type inference</a> and <a href="traits/resolution.html">trait solving</a>.)</p>
<h2><a class="header" href="#type-collection" id="type-collection">Type collection</a></h2>
<p>Type &quot;collection&quot; is the process of converting the types found in the HIR
(<code>hir::Ty</code>), which represent the syntactic things that the user wrote, into the
<strong>internal representation</strong> used by the compiler (<code>Ty&lt;'tcx&gt;</code>) – we also do
similar conversions for where-clauses and other bits of the function signature.</p>
<p>To try and get a sense for the difference, consider this function:</p>
<pre><code class="language-rust ignore">struct Foo { }
fn foo(x: Foo, y: self::Foo) { ... }
//        ^^^     ^^^^^^^^^
</code></pre>
<p>Those two parameters <code>x</code> and <code>y</code> each have the same type: but they will have
distinct <code>hir::Ty</code> nodes. Those nodes will have different spans, and of course
they encode the path somewhat differently. But once they are &quot;collected&quot; into
<code>Ty&lt;'tcx&gt;</code> nodes, they will be represented by the exact same internal type.</p>
<p>Collection is defined as a bundle of <a href="query.html">queries</a> for computing information about
the various functions, traits, and other items in the crate being compiled.
Note that each of these queries is concerned with <em>interprocedural</em> things –
for example, for a function definition, collection will figure out the type and
signature of the function, but it will not visit the <em>body</em> of the function in
any way, nor examine type annotations on local variables (that's the job of
type <em>checking</em>).</p>
<p>For more details, see the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/collect/"><code>collect</code></a> module.</p>
<p><strong>TODO</strong>: actually talk about type checking...</p>
<h1><a class="header" href="#method-lookup" id="method-lookup">Method lookup</a></h1>
<p>Method lookup can be rather complex due to the interaction of a number
of factors, such as self types, autoderef, trait lookup, etc. This
file provides an overview of the process. More detailed notes are in
the code itself, naturally.</p>
<p>One way to think of method lookup is that we convert an expression of
the form:</p>
<pre><code class="language-rust ignore">receiver.method(...)
</code></pre>
<p>into a more explicit <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">UFCS</a> form:</p>
<pre><code class="language-rust ignore">Trait::method(ADJ(receiver), ...) // for a trait call
ReceiverType::method(ADJ(receiver), ...) // for an inherent method call
</code></pre>
<p>Here <code>ADJ</code> is some kind of adjustment, which is typically a series of
autoderefs and then possibly an autoref (e.g., <code>&amp;**receiver</code>). However
we sometimes do other adjustments and coercions along the way, in
particular unsizing (e.g., converting from <code>[T; n]</code> to <code>[T]</code>).</p>
<p>Method lookup is divided into two major phases:</p>
<ol>
<li>Probing (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/probe/"><code>probe.rs</code></a>). The probe phase is when we decide what method
to call and how to adjust the receiver.</li>
<li>Confirmation (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/confirm/"><code>confirm.rs</code></a>). The confirmation phase &quot;applies&quot;
this selection, updating the side-tables, unifying type variables, and
otherwise doing side-effectful things.</li>
</ol>
<p>One reason for this division is to be more amenable to caching.  The
probe phase produces a &quot;pick&quot; (<code>probe::Pick</code>), which is designed to be
cacheable across method-call sites. Therefore, it does not include
inference variables or other information.</p>
<h2><a class="header" href="#the-probe-phase" id="the-probe-phase">The Probe phase</a></h2>
<h3><a class="header" href="#steps" id="steps">Steps</a></h3>
<p>The first thing that the probe phase does is to create a series of
<em>steps</em>. This is done by progressively dereferencing the receiver type
until it cannot be deref'd anymore, as well as applying an optional
&quot;unsize&quot; step. So if the receiver has type <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>, this
might yield:</p>
<pre><code class="language-rust ignore">Rc&lt;Box&lt;[T; 3]&gt;&gt;
Box&lt;[T; 3]&gt;
[T; 3]
[T]
</code></pre>
<h3><a class="header" href="#candidate-assembly-1" id="candidate-assembly-1">Candidate assembly</a></h3>
<p>We then search along those steps to create a list of <em>candidates</em>. A
<code>Candidate</code> is a method item that might plausibly be the method being
invoked. For each candidate, we'll derive a &quot;transformed self type&quot;
that takes into account explicit self.</p>
<p>Candidates are grouped into two kinds, inherent and extension.</p>
<p><strong>Inherent candidates</strong> are those that are derived from the
type of the receiver itself.  So, if you have a receiver of some
nominal type <code>Foo</code> (e.g., a struct), any methods defined within an
impl like <code>impl Foo</code> are inherent methods.  Nothing needs to be
imported to use an inherent method, they are associated with the type
itself (note that inherent impls can only be defined in the same
module as the type itself).</p>
<p>FIXME: Inherent candidates are not always derived from impls.  If you
have a trait object, such as a value of type <code>Box&lt;ToString&gt;</code>, then the
trait methods (<code>to_string()</code>, in this case) are inherently associated
with it. Another case is type parameters, in which case the methods of
their bounds are inherent. However, this part of the rules is subject
to change: when DST's &quot;impl Trait for Trait&quot; is complete, trait object
dispatch could be subsumed into trait matching, and the type parameter
behavior should be reconsidered in light of where clauses.</p>
<p>TODO: Is this FIXME still accurate?</p>
<p><strong>Extension candidates</strong> are derived from imported traits.  If I have
the trait <code>ToString</code> imported, and I call <code>to_string()</code> on a value of
type <code>T</code>, then we will go off to find out whether there is an impl of
<code>ToString</code> for <code>T</code>.  These kinds of method calls are called &quot;extension
methods&quot;.  They can be defined in any module, not only the one that
defined <code>T</code>.  Furthermore, you must import the trait to call such a
method.</p>
<p>So, let's continue our example. Imagine that we were calling a method
<code>foo</code> with the receiver <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> and there is a trait <code>Foo</code>
that defines it with <code>&amp;self</code> for the type <code>Rc&lt;U&gt;</code> as well as a method
on the type <code>Box</code> that defines <code>Foo</code> but with <code>&amp;mut self</code>. Then we
might have two candidates:</p>
<pre><code class="language-text">&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt;
&amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`
</code></pre>
<h3><a class="header" href="#candidate-search" id="candidate-search">Candidate search</a></h3>
<p>Finally, to actually pick the method, we will search down the steps,
trying to match the receiver type against the candidate types. At
each step, we also consider an auto-ref and auto-mut-ref to see whether
that makes any of the candidates match. We pick the first step where
we find a match.</p>
<p>In the case of our example, the first step is <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>,
which does not itself match any candidate. But when we autoref it, we
get the type <code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> which does match. We would then
recursively consider all where-clauses that appear on the impl: if
those match (or we cannot rule out that they do), then this is the
method we would pick. Otherwise, we would continue down the series of
steps.</p>
<h1><a class="header" href="#variance-of-type-and-lifetime-parameters" id="variance-of-type-and-lifetime-parameters">Variance of type and lifetime parameters</a></h1>
<p>For a more general background on variance, see the <a href="./appendix/background.html">background</a> appendix.</p>
<p>During type checking we must infer the variance of type and lifetime
parameters. The algorithm is taken from Section 4 of the paper <a href="https://people.cs.umass.edu/%7Eyannis/variance-extended2011.pdf">&quot;Taming the
Wildcards: Combining Definition- and Use-Site Variance&quot;</a> published in
PLDI'11 and written by Altidor et al., and hereafter referred to as The Paper.</p>
<p>This inference is explicitly designed <em>not</em> to consider the uses of
types within code. To determine the variance of type parameters
defined on type <code>X</code>, we only consider the definition of the type <code>X</code>
and the definitions of any types it references.</p>
<p>We only infer variance for type parameters found on <em>data types</em>
like structs and enums. In these cases, there is a fairly straightforward
explanation for what variance means. The variance of the type
or lifetime parameters defines whether <code>T&lt;A&gt;</code> is a subtype of <code>T&lt;B&gt;</code>
(resp. <code>T&lt;'a&gt;</code> and <code>T&lt;'b&gt;</code>) based on the relationship of <code>A</code> and <code>B</code>
(resp. <code>'a</code> and <code>'b</code>).</p>
<p>We do not infer variance for type parameters found on traits, functions,
or impls. Variance on trait parameters can indeed make sense
(and we used to compute it) but it is actually rather subtle in
meaning and not that useful in practice, so we removed it. See the
<a href="variance.html#addendum">addendum</a> for some details. Variances on function/impl parameters, on the
other hand, doesn't make sense because these parameters are instantiated and
then forgotten, they don't persist in types or compiled byproducts.</p>
<blockquote>
<p><strong>Notation</strong></p>
<p>We use the notation of The Paper throughout this chapter:</p>
<ul>
<li><code>+</code> is <em>covariance</em>.</li>
<li><code>-</code> is <em>contravariance</em>.</li>
<li><code>*</code> is <em>bivariance</em>.</li>
<li><code>o</code> is <em>invariance</em>.</li>
</ul>
</blockquote>
<h2><a class="header" href="#the-algorithm" id="the-algorithm">The algorithm</a></h2>
<p>The basic idea is quite straightforward. We iterate over the types
defined and, for each use of a type parameter <code>X</code>, accumulate a
constraint indicating that the variance of <code>X</code> must be valid for the
variance of that use site. We then iteratively refine the variance of
<code>X</code> until all constraints are met. There is <em>always</em> a solution, because at
the limit we can declare all type parameters to be invariant and all
constraints will be satisfied.</p>
<p>As a simple example, consider:</p>
<pre><code class="language-rust ignore">enum Option&lt;A&gt; { Some(A), None }
enum OptionalFn&lt;B&gt; { Some(|B|), None }
enum OptionalMap&lt;C&gt; { Some(|C| -&gt; C), None }
</code></pre>
<p>Here, we will generate the constraints:</p>
<pre><code class="language-text">1. V(A) &lt;= +
2. V(B) &lt;= -
3. V(C) &lt;= +
4. V(C) &lt;= -
</code></pre>
<p>These indicate that (1) the variance of A must be at most covariant;
(2) the variance of B must be at most contravariant; and (3, 4) the
variance of C must be at most covariant <em>and</em> contravariant. All of these
results are based on a variance lattice defined as follows:</p>
<pre><code class="language-text">   *      Top (bivariant)
-     +
   o      Bottom (invariant)
</code></pre>
<p>Based on this lattice, the solution <code>V(A)=+</code>, <code>V(B)=-</code>, <code>V(C)=o</code> is the
optimal solution. Note that there is always a naive solution which
just declares all variables to be invariant.</p>
<p>You may be wondering why fixed-point iteration is required. The reason
is that the variance of a use site may itself be a function of the
variance of other type parameters. In full generality, our constraints
take the form:</p>
<pre><code class="language-text">V(X) &lt;= Term
Term := + | - | * | o | V(X) | Term x Term
</code></pre>
<p>Here the notation <code>V(X)</code> indicates the variance of a type/region
parameter <code>X</code> with respect to its defining class. <code>Term x Term</code>
represents the &quot;variance transform&quot; as defined in the paper:</p>
<blockquote>
<p>If the variance of a type variable <code>X</code> in type expression <code>E</code> is <code>V2</code>
and the definition-site variance of the corresponding type parameter
of a class <code>C</code> is <code>V1</code>, then the variance of <code>X</code> in the type expression
<code>C&lt;E&gt;</code> is <code>V3 = V1.xform(V2)</code>.</p>
</blockquote>
<h2><a class="header" href="#constraints" id="constraints">Constraints</a></h2>
<p>If I have a struct or enum with where clauses:</p>
<pre><code class="language-rust ignore">struct Foo&lt;T: Bar&gt; { ... }
</code></pre>
<p>you might wonder whether the variance of <code>T</code> with respect to <code>Bar</code> affects the
variance <code>T</code> with respect to <code>Foo</code>. I claim no.  The reason: assume that <code>T</code> is
invariant with respect to <code>Bar</code> but covariant with respect to <code>Foo</code>. And then
we have a <code>Foo&lt;X&gt;</code> that is upcast to <code>Foo&lt;Y&gt;</code>, where <code>X &lt;: Y</code>. However, while
<code>X : Bar</code>, <code>Y : Bar</code> does not hold.  In that case, the upcast will be illegal,
but not because of a variance failure, but rather because the target type
<code>Foo&lt;Y&gt;</code> is itself just not well-formed. Basically we get to assume
well-formedness of all types involved before considering variance.</p>
<h3><a class="header" href="#dependency-graph-management" id="dependency-graph-management">Dependency graph management</a></h3>
<p>Because variance is a whole-crate inference, its dependency graph
can become quite muddled if we are not careful. To resolve this, we refactor
into two queries:</p>
<ul>
<li><code>crate_variances</code> computes the variance for all items in the current crate.</li>
<li><code>variances_of</code> accesses the variance for an individual reading; it
works by requesting <code>crate_variances</code> and extracting the relevant data.</li>
</ul>
<p>If you limit yourself to reading <code>variances_of</code>, your code will only
depend then on the inference of that particular item.</p>
<p>Ultimately, this setup relies on the <a href="./queries/incremental-compilation.html">red-green algorithm</a>. In particular,
every variance query effectively depends on all type definitions in the entire
crate (through <code>crate_variances</code>), but since most changes will not result in a
change to the actual results from variance inference, the <code>variances_of</code> query
will wind up being considered green after it is re-evaluated.</p>
<p><a name="addendum"></a></p>
<h2><a class="header" href="#addendum-variance-on-traits" id="addendum-variance-on-traits">Addendum: Variance on traits</a></h2>
<p>As mentioned above, we used to permit variance on traits. This was
computed based on the appearance of trait type parameters in
method signatures and was used to represent the compatibility of
vtables in trait objects (and also &quot;virtual&quot; vtables or dictionary
in trait bounds). One complication was that variance for
associated types is less obvious, since they can be projected out
and put to myriad uses, so it's not clear when it is safe to allow
<code>X&lt;A&gt;::Bar</code> to vary (or indeed just what that means). Moreover (as
covered below) all inputs on any trait with an associated type had
to be invariant, limiting the applicability. Finally, the
annotations (<code>MarkerTrait</code>, <code>PhantomFn</code>) needed to ensure that all
trait type parameters had a variance were confusing and annoying
for little benefit.</p>
<p>Just for historical reference, I am going to preserve some text indicating how
one could interpret variance and trait matching.</p>
<h3><a class="header" href="#variance-and-object-types" id="variance-and-object-types">Variance and object types</a></h3>
<p>Just as with structs and enums, we can decide the subtyping
relationship between two object types <code>&amp;Trait&lt;A&gt;</code> and <code>&amp;Trait&lt;B&gt;</code>
based on the relationship of <code>A</code> and <code>B</code>. Note that for object
types we ignore the <code>Self</code> type parameter – it is unknown, and
the nature of dynamic dispatch ensures that we will always call a
function that is expected the appropriate <code>Self</code> type. However, we
must be careful with the other type parameters, or else we could
end up calling a function that is expecting one type but provided
another.</p>
<p>To see what I mean, consider a trait like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait ConvertTo&lt;A&gt; {
    fn convertTo(&amp;self) -&gt; A;
}
<span class="boring">}
</span></code></pre></pre>
<p>Intuitively, If we had one object <code>O=&amp;ConvertTo&lt;Object&gt;</code> and another
<code>S=&amp;ConvertTo&lt;String&gt;</code>, then <code>S &lt;: O</code> because <code>String &lt;: Object</code>
(presuming Java-like &quot;string&quot; and &quot;object&quot; types, my go to examples
for subtyping). The actual algorithm would be to compare the
(explicit) type parameters pairwise respecting their variance: here,
the type parameter A is covariant (it appears only in a return
position), and hence we require that <code>String &lt;: Object</code>.</p>
<p>You'll note though that we did not consider the binding for the
(implicit) <code>Self</code> type parameter: in fact, it is unknown, so that's
good. The reason we can ignore that parameter is precisely because we
don't need to know its value until a call occurs, and at that time (as
you said) the dynamic nature of virtual dispatch means the code we run
will be correct for whatever value <code>Self</code> happens to be bound to for
the particular object whose method we called. <code>Self</code> is thus different
from <code>A</code>, because the caller requires that <code>A</code> be known in order to
know the return type of the method <code>convertTo()</code>. (As an aside, we
have rules preventing methods where <code>Self</code> appears outside of the
receiver position from being called via an object.)</p>
<h3><a class="header" href="#trait-variance-and-vtable-resolution" id="trait-variance-and-vtable-resolution">Trait variance and vtable resolution</a></h3>
<p>But traits aren't only used with objects. They're also used when
deciding whether a given impl satisfies a given trait bound. To set the
scene here, imagine I had a function:</p>
<pre><code class="language-rust ignore">fn convertAll&lt;A,T:ConvertTo&lt;A&gt;&gt;(v: &amp;[T]) { ... }
</code></pre>
<p>Now imagine that I have an implementation of <code>ConvertTo</code> for <code>Object</code>:</p>
<pre><code class="language-rust ignore">impl ConvertTo&lt;i32&gt; for Object { ... }
</code></pre>
<p>And I want to call <code>convertAll</code> on an array of strings. Suppose
further that for whatever reason I specifically supply the value of
<code>String</code> for the type parameter <code>T</code>:</p>
<pre><code class="language-rust ignore">let mut vector = vec![&quot;string&quot;, ...];
convertAll::&lt;i32, String&gt;(vector);
</code></pre>
<p>Is this legal? To put another way, can we apply the <code>impl</code> for
<code>Object</code> to the type <code>String</code>? The answer is yes, but to see why
we have to expand out what will happen:</p>
<ul>
<li>
<p><code>convertAll</code> will create a pointer to one of the entries in the
vector, which will have type <code>&amp;String</code></p>
</li>
<li>
<p>It will then call the impl of <code>convertTo()</code> that is intended
for use with objects. This has the type <code>fn(self: &amp;Object) -&gt; i32</code>.</p>
<p>It is OK to provide a value for <code>self</code> of type <code>&amp;String</code> because
<code>&amp;String &lt;: &amp;Object</code>.</p>
</li>
</ul>
<p>OK, so intuitively we want this to be legal, so let's bring this back
to variance and see whether we are computing the correct result. We
must first figure out how to phrase the question &quot;is an impl for
<code>Object,i32</code> usable where an impl for <code>String,i32</code> is expected?&quot;</p>
<p>Maybe it's helpful to think of a dictionary-passing implementation of
type classes. In that case, <code>convertAll()</code> takes an implicit parameter
representing the impl. In short, we <em>have</em> an impl of type:</p>
<pre><code class="language-text">V_O = ConvertTo&lt;i32&gt; for Object
</code></pre>
<p>and the function prototype expects an impl of type:</p>
<pre><code class="language-text">V_S = ConvertTo&lt;i32&gt; for String
</code></pre>
<p>As with any argument, this is legal if the type of the value given
(<code>V_O</code>) is a subtype of the type expected (<code>V_S</code>). So is <code>V_O &lt;: V_S</code>?
The answer will depend on the variance of the various parameters. In
this case, because the <code>Self</code> parameter is contravariant and <code>A</code> is
covariant, it means that:</p>
<pre><code class="language-text">V_O &lt;: V_S iff
    i32 &lt;: i32
    String &lt;: Object
</code></pre>
<p>These conditions are satisfied and so we are happy.</p>
<h3><a class="header" href="#variance-and-associated-types" id="variance-and-associated-types">Variance and associated types</a></h3>
<p>Traits with associated types – or at minimum projection
expressions – must be invariant with respect to all of their
inputs. To see why this makes sense, consider what subtyping for a
trait reference means:</p>
<pre><code class="language-text">&lt;T as Trait&gt; &lt;: &lt;U as Trait&gt;
</code></pre>
<p>means that if I know that <code>T as Trait</code>, I also know that <code>U as Trait</code>. Moreover, if you think of it as dictionary passing style,
it means that a dictionary for <code>&lt;T as Trait&gt;</code> is safe to use where
a dictionary for <code>&lt;U as Trait&gt;</code> is expected.</p>
<p>The problem is that when you can project types out from <code>&lt;T as Trait&gt;</code>, the relationship to types projected out of <code>&lt;U as Trait&gt;</code>
is completely unknown unless <code>T==U</code> (see #21726 for more
details). Making <code>Trait</code> invariant ensures that this is true.</p>
<p>Another related reason is that if we didn't make traits with
associated types invariant, then projection is no longer a
function with a single result. Consider:</p>
<pre><code class="language-rust ignore">trait Identity { type Out; fn foo(&amp;self); }
impl&lt;T&gt; Identity for T { type Out = T; ... }
</code></pre>
<p>Now if I have <code>&lt;&amp;'static () as Identity&gt;::Out</code>, this can be
validly derived as <code>&amp;'a ()</code> for any <code>'a</code>:</p>
<pre><code class="language-text">&lt;&amp;'a () as Identity&gt; &lt;: &lt;&amp;'static () as Identity&gt;
if &amp;'static () &lt; : &amp;'a ()   -- Identity is contravariant in Self
if 'static : 'a             -- Subtyping rules for relations
</code></pre>
<p>This change otoh means that <code>&lt;'static () as Identity&gt;::Out</code> is
always <code>&amp;'static ()</code> (which might then be upcast to <code>'a ()</code>,
separately). This was helpful in solving #21750.</p>
<h1><a class="header" href="#opaque-types-type-alias-impl-trait" id="opaque-types-type-alias-impl-trait">Opaque types (type alias <code>impl Trait</code>)</a></h1>
<p>Opaque types are syntax to declare an opaque type alias that only
exposes a specific set of traits as their interface; the concrete type in the
background is inferred from a certain set of use sites of the opaque type.</p>
<p>This is expressed by using <code>impl Trait</code> within type aliases, for example:</p>
<pre><code class="language-rust ignore">type Foo = impl Bar;
</code></pre>
<p>This declares an opaque type named <code>Foo</code>, of which the only information is that
it implements <code>Bar</code>. Therefore, any of <code>Bar</code>'s interface can be used on a <code>Foo</code>,
but nothing else (regardless of whether it implements any other traits).</p>
<p>Since there needs to be a concrete background type, you can currently
express that type by using the opaque type in a &quot;defining use site&quot;.</p>
<pre><code class="language-rust ignore">struct Struct;
impl Bar for Struct { /* stuff */ }
fn foo() -&gt; Foo {
    Struct
}
</code></pre>
<p>Any other &quot;defining use site&quot; needs to produce the exact same type.</p>
<h2><a class="header" href="#defining-use-sites" id="defining-use-sites">Defining use site(s)</a></h2>
<p>Currently only the return value of a function can be a defining use site
of an opaque type (and only if the return type of that function contains
the opaque type).</p>
<p>The defining use of an opaque type can be any code <em>within</em> the parent
of the opaque type definition. This includes any siblings of the
opaque type and all children of the siblings.</p>
<p>The initiative for <em>&quot;not causing fatal brain damage to developers due to
accidentally running infinite loops in their brain while trying to
comprehend what the type system is doing&quot;</em> has decided to disallow children
of opaque types to be defining use sites.</p>
<h3><a class="header" href="#associated-opaque-types" id="associated-opaque-types">Associated opaque types</a></h3>
<p>Associated opaque types can be defined by any other associated item
on the same trait <code>impl</code> or a child of these associated items. For instance:</p>
<pre><code class="language-rust ignore">trait Baz {
    type Foo;
    fn foo() -&gt; Self::Foo;
}

struct Quux;

impl Baz for Quux {
    type Foo = impl Bar;
    fn foo() -&gt; Self::Foo { ... }
}
</code></pre>
<h1><a class="header" href="#pattern-and-exhaustiveness-checking" id="pattern-and-exhaustiveness-checking">Pattern and Exhaustiveness Checking</a></h1>
<p>In Rust, pattern matching and bindings have a few very helpful properties. The
compiler will check that bindings are irrefutable when made and that match arms
are exhaustive.</p>
<p><strong>TODO</strong>: write this chapter.</p>
<h1><a class="header" href="#mir-borrow-check" id="mir-borrow-check">MIR borrow check</a></h1>
<p>The borrow check is Rust's &quot;secret sauce&quot; – it is tasked with
enforcing a number of properties:</p>
<ul>
<li>That all variables are initialized before they are used.</li>
<li>That you can't move the same value twice.</li>
<li>That you can't move a value while it is borrowed.</li>
<li>That you can't access a place while it is mutably borrowed (except through
the reference).</li>
<li>That you can't mutate a place while it is immutably borrowed.</li>
<li>etc</li>
</ul>
<p>The borrow checker operates on the MIR. An older implementation operated on the
HIR. Doing borrow checking on MIR has several advantages:</p>
<ul>
<li>The MIR is <em>far</em> less complex than the HIR; the radical desugaring
helps prevent bugs in the borrow checker. (If you're curious, you
can see
<a href="https://github.com/rust-lang/rust/issues/47366">a list of bugs that the MIR-based borrow checker fixes here</a>.)</li>
<li>Even more importantly, using the MIR enables <a href="https://rust-lang.github.io/rfcs/2094-nll.html">&quot;non-lexical lifetimes&quot;</a>,
which are regions derived from the control-flow graph.</li>
</ul>
<h3><a class="header" href="#major-phases-of-the-borrow-checker" id="major-phases-of-the-borrow-checker">Major phases of the borrow checker</a></h3>
<p>The borrow checker source is found in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/index.html">the <code>rustc_mir::borrow_check</code> module</a>. The main entry point is
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/fn.mir_borrowck.html"><code>mir_borrowck</code></a> query.</p>
<ul>
<li>We first create a <strong>local copy</strong> of the MIR. In the coming steps,
we will modify this copy in place to modify the types and things to
include references to the new regions that we are computing.</li>
<li>We then invoke <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a> to modify our local MIR.
Among other things, this function will replace all of the <a href="./appendix/glossary.html#region">regions</a>
in the MIR with fresh <a href="./appendix/glossary.html#inf-var">inference variables</a>.</li>
<li>Next, we perform a number of
<a href="./appendix/background.html#dataflow">dataflow analyses</a> that
compute what data is moved and when.</li>
<li>We then do a <a href="borrow_check/type_check.html">second type check</a> across the MIR:
the purpose of this type check is to determine all of the constraints between
different regions.</li>
<li>Next, we do <a href="borrow_check/region_inference.html">region inference</a>, which computes
the values of each region — basically, the points in the control-flow graph where
each lifetime must be valid according to the constraints we collected.</li>
<li>At this point, we can compute the &quot;borrows in scope&quot; at each point.</li>
<li>Finally, we do a second walk over the MIR, looking at the actions it
does and reporting errors. For example, if we see a statement like
<code>*a + 1</code>, then we would check that the variable <code>a</code> is initialized
and that it is not mutably borrowed, as either of those would
require an error to be reported. Doing this check requires the results of all
the previous analyses.</li>
</ul>
<h1><a class="header" href="#tracking-moves-and-initialization" id="tracking-moves-and-initialization">Tracking moves and initialization</a></h1>
<p>Part of the borrow checker's job is to track which variables are
&quot;initialized&quot; at any given point in time -- this also requires
figuring out where moves occur and tracking those.</p>
<h2><a class="header" href="#initialization-and-moves" id="initialization-and-moves">Initialization and moves</a></h2>
<p>From a user's perspective, initialization -- giving a variable some
value -- and moves -- transferring ownership to another place -- might
seem like distinct topics. Indeed, our borrow checker error messages
often talk about them differently. But <strong>within the borrow checker</strong>,
they are not nearly as separate. Roughly speaking, the borrow checker
tracks the set of &quot;initialized places&quot; at any point in the source
code. Assigning to a previously uninitialized local variable adds it
to that set; moving from a local variable removes it from that set.</p>
<p>Consider this example:</p>
<pre><code class="language-rust ignore">fn foo() {
    let a: Vec&lt;u32&gt;;
    
    // a is not initialized yet
    
    a = vec![22];
    
    // a is initialized here
    
    std::mem::drop(a); // a is moved here
    
    // a is no longer initialized here

    let l = a.len(); //~ ERROR
}
</code></pre>
<p>Here you can see that <code>a</code> starts off as uninitialized; once it is
assigned, it becomes initialized. But when <code>drop(a)</code> is called, that
moves <code>a</code> into the call, and hence it becomes uninitialized again.</p>
<h2><a class="header" href="#subsections" id="subsections">Subsections</a></h2>
<p>To make it easier to peruse, this section is broken into a number of
subsections:</p>
<ul>
<li><a href="borrow_check/./moves_and_initialization/move_paths.html">Move paths</a> the
<em>move path</em> concept that we use to track which local variables (or parts of
local variables, in some cases) are initialized.</li>
<li>TODO <em>Rest not yet written</em> =)</li>
</ul>
<h1><a class="header" href="#move-paths" id="move-paths">Move paths</a></h1>
<p>In reality, it's not enough to track initialization at the granularity
of local variables. Rust also allows us to do moves and initialization
at the field granularity:</p>
<pre><code class="language-rust ignore">fn foo() {
    let a: (Vec&lt;u32&gt;, Vec&lt;u32&gt;) = (vec![22], vec![44]);
    
    // a.0 and a.1 are both initialized
    
    let b = a.0; // moves a.0
    
    // a.0 is not initialized, but a.1 still is

    let c = a.0; // ERROR
    let d = a.1; // OK
}
</code></pre>
<p>To handle this, we track initialization at the granularity of a <strong>move
path</strong>. A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePath.html"><code>MovePath</code></a> represents some location that the user can
initialize, move, etc. So e.g. there is a move-path representing the
local variable <code>a</code>, and there is a move-path representing <code>a.0</code>.  Move
paths roughly correspond to the concept of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a> from MIR, but
they are indexed in ways that enable us to do move analysis more
efficiently.</p>
<h2><a class="header" href="#move-path-indices" id="move-path-indices">Move path indices</a></h2>
<p>Although there is a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePath.html"><code>MovePath</code></a> data structure, they are never referenced
directly.  Instead, all the code passes around <em>indices</em> of type
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. If you need to get information about a move path, you use
this index with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html#structfield.move_paths"><code>move_paths</code> field of the <code>MoveData</code></a>. For
example, to convert a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> <code>mpi</code> into a MIR <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a>, you might
access the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePath.html#structfield.place"><code>MovePath::place</code></a> field like so:</p>
<pre><code class="language-rust ignore">move_data.move_paths[mpi].place
</code></pre>
<h2><a class="header" href="#building-move-paths" id="building-move-paths">Building move paths</a></h2>
<p>One of the first things we do in the MIR borrow check is to construct
the set of move paths. This is done as part of the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html#method.gather_moves"><code>MoveData::gather_moves</code></a> function. This function uses a MIR visitor
called <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/builder/struct.Gatherer.html"><code>Gatherer</code></a> to walk the MIR and look at how each <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a>
within is accessed. For each such <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a>, it constructs a
corresponding <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. It also records when/where that
particular move path is moved/initialized, but we'll get to that in a
later section.</p>
<h3><a class="header" href="#illegal-move-paths" id="illegal-move-paths">Illegal move paths</a></h3>
<p>We don't actually create a move-path for <strong>every</strong> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a> that gets
used.  In particular, if it is illegal to move from a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a>, then
there is no need for a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. Some examples:</p>
<ul>
<li>You cannot move from a static variable, so we do not create a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>
for static variables.</li>
<li>You cannot move an individual element of an array, so if we have e.g. <code>foo: [String; 3]</code>,
there would be no move-path for <code>foo[1]</code>.</li>
<li>You cannot move from inside of a borrowed reference, so if we have e.g. <code>foo: &amp;String</code>,
there would be no move-path for <code>*foo</code>.</li>
</ul>
<p>These rules are enforced by the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/builder/struct.Gatherer.html#method.move_path_for"><code>move_path_for</code></a> function, which
converts a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a> into a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> -- in error cases like
those just discussed, the function returns an <code>Err</code>. This in turn
means we don't have to bother tracking whether those places are
initialized (which lowers overhead).</p>
<h2><a class="header" href="#looking-up-a-move-path" id="looking-up-a-move-path">Looking up a move-path</a></h2>
<p>If you have a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a> and you would like to convert it to a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>, you
can do that using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html"><code>MovePathLookup</code></a> structure found in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html#structfield.rev_lookup"><code>rev_lookup</code></a> field
of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html"><code>MoveData</code></a>. There are two different methods:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html#method.find_local"><code>find_local</code></a>, which takes a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Local.html"><code>mir::Local</code></a> representing a local
variable. This is the easier method, because we <strong>always</strong> create a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> for every local variable.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html#method.find"><code>find</code></a>, which takes an arbitrary <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a>. This method is a bit
more annoying to use, precisely because we don't have a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> for <strong>every</strong> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html"><code>Place</code></a> (as we just discussed in
the &quot;illegal move paths&quot; section). Therefore, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html#method.find"><code>find</code></a> returns a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/enum.LookupResult.html"><code>LookupResult</code></a> indicating the closest path it was able to find
that exists (e.g., for <code>foo[1]</code>, it might return just the path for
<code>foo</code>).</li>
</ul>
<h2><a class="header" href="#cross-references" id="cross-references">Cross-references</a></h2>
<p>As we noted above, move-paths are stored in a big vector and
referenced via their <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. However, within this vector,
they are also structured into a tree. So for example if you have the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> for <code>a.b.c</code>, you can go to its parent move-path
<code>a.b</code>. You can also iterate over all children paths: so, from <code>a.b</code>,
you might iterate to find the path <code>a.b.c</code> (here you are iterating
just over the paths that are <strong>actually referenced</strong> in the source,
not all <strong>possible</strong> paths that could have been referenced). These
references are used for example in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html#method.find_in_move_path_or_its_descendants"><code>find_in_move_path_or_its_descendants</code></a> function, which determines
whether a move-path (e.g., <code>a.b</code>) or any child of that move-path 
(e.g.,<code>a.b.c</code>) matches a given predicate.</p>
<h1><a class="header" href="#the-mir-type-check" id="the-mir-type-check">The MIR type-check</a></h1>
<p>A key component of the borrow check is the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/type_check/index.html">MIR type-check</a>.
This check walks the MIR and does a complete &quot;type check&quot; -- the same
kind you might find in any other language. In the process of doing
this type-check, we also uncover the region constraints that apply to
the program.</p>
<p>TODO -- elaborate further? Maybe? :)</p>
<h1><a class="header" href="#region-inference-nll" id="region-inference-nll">Region inference (NLL)</a></h1>
<p>The MIR-based region checking code is located in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/index.html">the <code>rustc_mir::borrow_check</code>
module</a>.</p>
<p>The MIR-based region analysis consists of two major functions:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a>, invoked first, has two jobs:
<ul>
<li>First, it finds the set of regions that appear within the
signature of the function (e.g., <code>'a</code> in <code>fn foo&lt;'a&gt;(&amp;'a u32) { ... }</code>). These are called the &quot;universal&quot; or &quot;free&quot; regions – in
particular, they are the regions that <a href="borrow_check/../appendix/background.html#free-vs-bound">appear free</a> in the
function body.</li>
<li>Second, it replaces all the regions from the function body with
fresh inference variables. This is because (presently) those
regions are the results of lexical region inference and hence are
not of much interest. The intention is that – eventually – they
will be &quot;erased regions&quot; (i.e., no information at all), since we
won't be doing lexical region inference at all.</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.compute_regions.html"><code>compute_regions</code></a>, invoked second: this is given as argument the
results of move analysis. It has the job of computing values for all
the inference variables that <code>replace_regions_in_mir</code> introduced.
<ul>
<li>To do that, it first runs the <a href="borrow_check/./type_check.html">MIR type checker</a>. This is
basically a normal type-checker but specialized to MIR, which is
much simpler than full Rust, of course. Running the MIR type
checker will however create various <a href="borrow_check/./region_inference/constraint_propagation.html">constraints</a> between region
variables, indicating their potential values and relationships to
one another.</li>
<li>After this, we perform <a href="borrow_check/./region_inference/constraint_propagation.html">constraint propagation</a> by creating a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html"><code>RegionInferenceContext</code></a> and invoking its <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.solve"><code>solve</code></a>
method.</li>
<li>The <a href="https://rust-lang.github.io/rfcs/2094-nll.html">NLL RFC</a> also includes fairly thorough (and hopefully readable)
coverage.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#universal-regions" id="universal-regions">Universal regions</a></h2>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/universal_regions/struct.UniversalRegions.html"><code>UniversalRegions</code></a> type represents a collection of <em>universal</em> regions
corresponding to some MIR <code>DefId</code>. It is constructed in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a> when we replace all regions with fresh inference
variables. <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/universal_regions/struct.UniversalRegions.html"><code>UniversalRegions</code></a> contains indices for all the free regions in
the given MIR along with any relationships that are <em>known</em> to hold between
them (e.g. implied bounds, where clauses, etc.).</p>
<p>For example, given the MIR for the following function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a u32) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>we would create a universal region for <code>'a</code> and one for <code>'static</code>. There may
also be some complications for handling closures, but we will ignore those for
the moment.</p>
<p>TODO: write about <em>how</em> these regions are computed.</p>
<p><a name="region-variables"></a></p>
<h2><a class="header" href="#region-variables" id="region-variables">Region variables</a></h2>
<p>The value of a region can be thought of as a <strong>set</strong>. This set contains all
points in the MIR where the region is valid along with any regions that are
outlived by this region (e.g. if <code>'a: 'b</code>, then <code>end('b)</code> is in the set for
<code>'a</code>); we call the domain of this set a <code>RegionElement</code>. In the code, the value
for all regions is maintained in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check/region_infer/">the
<code>rustc_mir::borrow_check::nll::region_infer</code> module</a>. For each region we
maintain a set storing what elements are present in its value (to make this
efficient, we give each kind of element an index, the <code>RegionElementIndex</code>, and
use sparse bitsets).</p>
<p>The kinds of region elements are as follows:</p>
<ul>
<li>Each <strong><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Location.html"><code>location</code></a></strong> in the MIR control-flow graph: a location is just
the pair of a basic block and an index. This identifies the point
<strong>on entry</strong> to the statement with that index (or the terminator, if
the index is equal to <code>statements.len()</code>).</li>
<li>There is an element <code>end('a)</code> for each universal region <code>'a</code>,
corresponding to some portion of the caller's (or caller's caller,
etc) control-flow graph.</li>
<li>Similarly, there is an element denoted <code>end('static)</code> corresponding
to the remainder of program execution after this function returns.</li>
<li>There is an element <code>!1</code> for each placeholder region <code>!1</code>. This
corresponds (intuitively) to some unknown set of other elements –
for details on placeholders, see the section
<a href="borrow_check/region_inference/placeholders_and_universes.html">placeholders and universes</a>.</li>
</ul>
<h2><a class="header" href="#constraints-1" id="constraints-1">Constraints</a></h2>
<p>Before we can infer the value of regions, we need to collect
constraints on the regions. The full set of constraints is described
in <a href="borrow_check/./region_inference/constraint_propagation.html">the section on constraint propagation</a>, but the two most
common sorts of constraints are:</p>
<ol>
<li>Outlives constraints. These are constraints that one region outlives another
(e.g. <code>'a: 'b</code>). Outlives constraints are generated by the <a href="borrow_check/./type_check.html">MIR type
checker</a>.</li>
<li>Liveness constraints. Each region needs to be live at points where it can be
used. These constraints are collected by <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/constraint_generation/fn.generate_constraints.html"><code>generate_constraints</code></a>.</li>
</ol>
<h2><a class="header" href="#inference-overview" id="inference-overview">Inference Overview</a></h2>
<p>So how do we compute the contents of a region? This process is called <em>region
inference</em>. The high-level idea is pretty simple, but there are some details we
need to take care of.</p>
<p>Here is the high-level idea: we start off each region with the MIR locations we
know must be in it from the liveness constraints. From there, we use all of the
outlives constraints computed from the type checker to <em>propagate</em> the
constraints: for each region <code>'a</code>, if <code>'a: 'b</code>, then we add all elements of
<code>'b</code> to <code>'a</code>, including <code>end('b)</code>. This all happens in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a>.</p>
<p>Then, we will check for errors. We first check that type tests are satisfied by
calling <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.check_type_tests"><code>check_type_tests</code></a>. This checks constraints like <code>T: 'a</code>. Second, we
check that universal regions are not &quot;too big&quot;. This is done by calling
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.check_universal_regions"><code>check_universal_regions</code></a>. This checks that for each region <code>'a</code> if <code>'a</code>
contains the element <code>end('b)</code>, then we must already know that <code>'a: 'b</code> holds
(e.g. from a where clause). If we don't already know this, that is an error...
well, almost. There is some special handling for closures that we will discuss
later.</p>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<p>Consider the following example:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a usize) -&gt; &amp;'b usize {
    x
}
</code></pre>
<p>Clearly, this should not compile because we don't know if <code>'a</code> outlives <code>'b</code>
(if it doesn't then the return value could be a dangling reference).</p>
<p>Let's back up a bit. We need to introduce some free inference variables (as is
done in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a>). This example doesn't use the exact regions
produced, but it (hopefully) is enough to get the idea across.</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a /* '#1 */ usize) -&gt; &amp;'b /* '#3 */ usize {
    x // '#2, location L1
}
</code></pre>
<p>Some notation: <code>'#1</code>, <code>'#3</code>, and <code>'#2</code> represent the universal regions for the
argument, return value, and the expression <code>x</code>, respectively. Additionally, I
will call the location of the expression <code>x</code> <code>L1</code>.</p>
<p>So now we can use the liveness constraints to get the following starting points:</p>
<table><thead><tr><th>Region</th><th>Contents</th></tr></thead><tbody>
<tr><td>'#1</td><td></td></tr>
<tr><td>'#2</td><td><code>L1</code></td></tr>
<tr><td>'#3</td><td><code>L1</code></td></tr>
</tbody></table>
<p>Now we use the outlives constraints to expand each region. Specifically, we
know that <code>'#2: '#3</code> ...</p>
<table><thead><tr><th>Region</th><th>Contents</th></tr></thead><tbody>
<tr><td>'#1</td><td><code>L1</code></td></tr>
<tr><td>'#2</td><td><code>L1, end('#3) // add contents of '#3 and end('#3)</code></td></tr>
<tr><td>'#3</td><td><code>L1</code></td></tr>
</tbody></table>
<p>... and <code>'#1: '#2</code>, so ...</p>
<table><thead><tr><th>Region</th><th>Contents</th></tr></thead><tbody>
<tr><td>'#1</td><td><code>L1, end('#2), end('#3) // add contents of '#2 and end('#2)</code></td></tr>
<tr><td>'#2</td><td><code>L1, end('#3)</code></td></tr>
<tr><td>'#3</td><td><code>L1</code></td></tr>
</tbody></table>
<p>Now, we need to check that no regions were too big (we don't have any type
tests to check in this case). Notice that <code>'#1</code> now contains <code>end('#3)</code>, but
we have no <code>where</code> clause or implied bound to say that <code>'a: 'b</code>... that's an
error!</p>
<h3><a class="header" href="#some-details" id="some-details">Some details</a></h3>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html"><code>RegionInferenceContext</code></a> type contains all of the information needed to
do inference, including the universal regions from <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a> and
the constraints computed for each region. It is constructed just after we
compute the liveness constraints.</p>
<p>Here are some of the fields of the struct:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.constraints"><code>constraints</code></a>: contains all the outlives constraints.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.liveness_constraints"><code>liveness_constraints</code></a>: contains all the liveness constraints.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.universal_regions"><code>universal_regions</code></a>: contains the <code>UniversalRegions</code> returned by
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.universal_region_relations"><code>universal_region_relations</code></a>: contains relations known to be true about
universal regions. For example, if we have a where clause that <code>'a: 'b</code>, that
relation is assumed to be true while borrow checking the implementation (it
is checked at the caller), so <code>universal_region_relations</code> would contain <code>'a: 'b</code>.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.type_tests"><code>type_tests</code></a>: contains some constraints on types that we must check after
inference (e.g. <code>T: 'a</code>).</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.closure_bounds_mapping"><code>closure_bounds_mapping</code></a>: used for propagating region constraints from
closures back out to the creator of the closure.</li>
</ul>
<p>TODO: should we discuss any of the others fields? What about the SCCs?</p>
<p>Ok, now that we have constructed a <code>RegionInferenceContext</code>, we can do
inference. This is done by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.solve"><code>solve</code></a> method on the context. This
is where we call <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a> and then check the resulting type
tests and universal regions, as discussed above.</p>
<h1><a class="header" href="#constraint-propagation" id="constraint-propagation">Constraint propagation</a></h1>
<p>The main work of the region inference is <strong>constraint propagation</strong>,
which is done in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a> function.  There are
three sorts of constraints that are used in NLL, and we'll explain how
<code>propagate_constraints</code> works by &quot;layering&quot; those sorts of constraints
on one at a time (each of them is fairly independent from the others):</p>
<ul>
<li>liveness constraints (<code>R live at E</code>), which arise from liveness;</li>
<li>outlives constraints (<code>R1: R2</code>), which arise from subtyping;</li>
<li><a href="borrow_check/region_inference/./member_constraints.html">member constraints</a> (<code>member R_m of [R_c...]</code>), which arise from impl Trait.</li>
</ul>
<p>In this chapter, we'll explain the &quot;heart&quot; of constraint propagation,
covering both liveness and outlives constraints.</p>
<h2><a class="header" href="#notation-and-high-level-concepts" id="notation-and-high-level-concepts">Notation and high-level concepts</a></h2>
<p>Conceptually, region inference is a &quot;fixed-point&quot; computation. It is
given some set of constraints <code>{C}</code> and it computes a set of values
<code>Values: R -&gt; {E}</code> that maps each region <code>R</code> to a set of elements
<code>{E}</code> (see <a href="borrow_check/region_inference/../region_inference.html#region-variables">here</a> for more notes on region elements):</p>
<ul>
<li>Initially, each region is mapped to an empty set, so <code>Values(R) = {}</code> for all regions <code>R</code>.</li>
<li>Next, we process the constraints repeatedly until a fixed-point is reached:
<ul>
<li>For each constraint C:
<ul>
<li>Update <code>Values</code> as needed to satisfy the constraint</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>As a simple example, if we have a liveness constraint <code>R live at E</code>,
then we can apply <code>Values(R) = Values(R) union {E}</code> to make the
constraint be satisfied. Similarly, if we have an outlives constraints
<code>R1: R2</code>, we can apply <code>Values(R1) = Values(R1) union Values(R2)</code>.
(Member constraints are more complex and we discuss them <a href="borrow_check/region_inference/./member_constraints.html">in this section</a>.)</p>
<p>In practice, however, we are a bit more clever. Instead of applying
the constraints in a loop, we can analyze the constraints and figure
out the correct order to apply them, so that we only have to apply
each constraint once in order to find the final result.</p>
<p>Similarly, in the implementation, the <code>Values</code> set is stored in the
<code>scc_values</code> field, but they are indexed not by a <em>region</em> but by a
<em>strongly connected component</em> (SCC). SCCs are an optimization that
avoids a lot of redundant storage and computation.  They are explained
in the section on outlives constraints.</p>
<h2><a class="header" href="#liveness-constraints" id="liveness-constraints">Liveness constraints</a></h2>
<p>A <strong>liveness constraint</strong> arises when some variable whose type
includes a region R is live at some <a href="borrow_check/region_inference/../../appendix/glossary.html#point">point</a> P. This simply means that
the value of R must include the point P. Liveness constraints are
computed by the MIR type checker.</p>
<p>A liveness constraint <code>R live at E</code> is satisfied if <code>E</code> is a member of
<code>Values(R)</code>. So to &quot;apply&quot; such a constraint to <code>Values</code>, we just have
to compute <code>Values(R) = Values(R) union {E}</code>.</p>
<p>The liveness values are computed in the type-check and passed to the
region inference upon creation in the <code>liveness_constraints</code> argument.
These are not represented as individual constraints like <code>R live at E</code>
though; instead, we store a (sparse) bitset per region variable (of
type <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/values/struct.LivenessValues.html"><code>LivenessValues</code></a>). This way we only need a single bit for each
liveness constraint.</p>
<p>One thing that is worth mentioning: All lifetime parameters are always
considered to be live over the entire function body. This is because
they correspond to some portion of the <em>caller's</em> execution, and that
execution clearly includes the time spent in this function, since the
caller is waiting for us to return.</p>
<h2><a class="header" href="#outlives-constraints" id="outlives-constraints">Outlives constraints</a></h2>
<p>An outlives constraint <code>'a: 'b</code> indicates that the value of <code>'a</code> must
be a <strong>superset</strong> of the value of <code>'b</code>. That is, an outlives
constraint <code>R1: R2</code> is satisfied if <code>Values(R1)</code> is a superset of
<code>Values(R2)</code>. So to &quot;apply&quot; such a constraint to <code>Values</code>, we just
have to compute <code>Values(R1) = Values(R1) union Values(R2)</code>.</p>
<p>One observation that follows from this is that if you have <code>R1: R2</code>
and <code>R2: R1</code>, then <code>R1 = R2</code> must be true. Similarly, if you have:</p>
<pre><code class="language-txt">R1: R2
R2: R3
R3: R4
R4: R1
</code></pre>
<p>then <code>R1 = R2 = R3 = R4</code> follows. We take advantage of this to make things
much faster, as described shortly.</p>
<p>In the code, the set of outlives constraints is given to the region
inference context on creation in a parameter of type
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/constraints/struct.OutlivesConstraintSet.html"><code>OutlivesConstraintSet</code></a>. The constraint set is basically just a list of <code>'a: 'b</code> constraints.</p>
<h3><a class="header" href="#the-outlives-constraint-graph-and-sccs" id="the-outlives-constraint-graph-and-sccs">The outlives constraint graph and SCCs</a></h3>
<p>In order to work more efficiently with outlives constraints, they are
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/constraints/struct.OutlivesConstraintSet.html#method.graph">converted into the form of a graph</a>, where the nodes of the
graph are region variables (<code>'a</code>, <code>'b</code>) and each constraint <code>'a: 'b</code>
induces an edge <code>'a -&gt; 'b</code>. This conversion happens in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.new"><code>RegionInferenceContext::new</code></a> function that creates the inference
context.</p>
<p>When using a graph representation, we can detect regions that must be equal
by looking for cycles. That is, if you have a constraint like</p>
<pre><code class="language-txt">'a: 'b
'b: 'c
'c: 'd
'd: 'a
</code></pre>
<p>then this will correspond to a cycle in the graph containing the
elements <code>'a...'d</code>.</p>
<p>Therefore, one of the first things that we do in propagating region
values is to compute the <strong>strongly connected components</strong> (SCCs) in
the constraint graph. The result is stored in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.constraint_sccs"><code>constraint_sccs</code></a>
field. You can then easily find the SCC that a region <code>r</code> is a part of
by invoking <code>constraint_sccs.scc(r)</code>.</p>
<p>Working in terms of SCCs allows us to be more efficient: if we have a
set of regions <code>'a...'d</code> that are part of a single SCC, we don't have
to compute/store their values separately. We can just store one value
<strong>for the SCC</strong>, since they must all be equal.</p>
<p>If you look over the region inference code, you will see that a number
of fields are defined in terms of SCCs. For example, the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#structfield.scc_values"><code>scc_values</code></a> field stores the values of each SCC. To get the value
of a specific region <code>'a</code> then, we first figure out the SCC that the
region is a part of, and then find the value of that SCC.</p>
<p>When we compute SCCs, we not only figure out which regions are a
member of each SCC, we also figure out the edges between them. So for example
consider this set of outlives constraints:</p>
<pre><code class="language-txt">'a: 'b
'b: 'a

'a: 'c

'c: 'd
'd: 'c
</code></pre>
<p>Here we have two SCCs: S0 contains <code>'a</code> and <code>'b</code>, and S1 contains <code>'c</code>
and <code>'d</code>.  But these SCCs are not independent: because <code>'a: 'c</code>, that
means that <code>S0: S1</code> as well. That is -- the value of <code>S0</code> must be a
superset of the value of <code>S1</code>. One crucial thing is that this graph of
SCCs is always a DAG -- that is, it never has cycles. This is because
all the cycles have been removed to form the SCCs themselves.</p>
<h3><a class="header" href="#applying-liveness-constraints-to-sccs" id="applying-liveness-constraints-to-sccs">Applying liveness constraints to SCCs</a></h3>
<p>The liveness constraints that come in from the type-checker are
expressed in terms of regions -- that is, we have a map like
<code>Liveness: R -&gt; {E}</code>.  But we want our final result to be expressed
in terms of SCCs -- we can integrate these liveness constraints very
easily just by taking the union:</p>
<pre><code class="language-txt">for each region R:
  let S be the SCC that contains R
  Values(S) = Values(S) union Liveness(R)
</code></pre>
<p>In the region inferencer, this step is done in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.new"><code>RegionInferenceContext::new</code></a>.</p>
<h3><a class="header" href="#applying-outlives-constraints" id="applying-outlives-constraints">Applying outlives constraints</a></h3>
<p>Once we have computed the DAG of SCCs, we use that to structure out
entire computation. If we have an edge <code>S1 -&gt; S2</code> between two SCCs,
that means that <code>Values(S1) &gt;= Values(S2)</code> must hold. So, to compute
the value of <code>S1</code>, we first compute the values of each successor <code>S2</code>.
Then we simply union all of those values together. To use a
quasi-iterator-like notation:</p>
<pre><code class="language-txt">Values(S1) =
  s1.successors()
    .map(|s2| Values(s2))
    .union()
</code></pre>
<p>In the code, this work starts in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a>
function, which iterates over all the SCCs. For each SCC <code>S1</code>, we
compute its value by first computing the value of its
successors. Since SCCs form a DAG, we don't have to be concerned about
cycles, though we do need to keep a set around to track whether we
have already processed a given SCC or not. For each successor <code>S2</code>, once
we have computed <code>S2</code>'s value, we can union those elements into the
value for <code>S1</code>. (Although we have to be careful in this process to
properly handle <a href="borrow_check/region_inference/./placeholders_and_universes.html">higher-ranked
placeholders</a>. Note that the value
for <code>S1</code> already contains the liveness constraints, since they were
added in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.new"><code>RegionInferenceContext::new</code></a>.</p>
<p>Once that process is done, we now have the &quot;minimal value&quot; for <code>S1</code>,
taking into account all of the liveness and outlives
constraints. However, in order to complete the process, we must also
consider <a href="borrow_check/region_inference/./member_constraints.html">member constraints</a>, which are described in <a href="borrow_check/region_inference/./member_constraints.html">a later
section</a>.</p>
<h1><a class="header" href="#universal-regions-1" id="universal-regions-1">Universal regions</a></h1>
<p>&quot;Universal regions&quot; is the name that the code uses to refer to &quot;named
lifetimes&quot; -- e.g., lifetime parameters and <code>'static</code>. The name
derives from the fact that such lifetimes are &quot;universally quantified&quot;
(i.e., we must make sure the code is true for all values of those
lifetimes). It is worth spending a bit of discussing how lifetime
parameters are handled during region inference. Consider this example:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a u32, y: &amp;'b u32) -&gt; &amp;'b u32 {
  x
}
</code></pre>
<p>This example is intended not to compile, because we are returning <code>x</code>,
which has type <code>&amp;'a u32</code>, but our signature promises that we will
return a <code>&amp;'b u32</code> value. But how are lifetimes like <code>'a</code> and <code>'b</code>
integrated into region inference, and how this error wind up being
detected?</p>
<h2><a class="header" href="#universal-regions-and-their-relationships-to-one-another" id="universal-regions-and-their-relationships-to-one-another">Universal regions and their relationships to one another</a></h2>
<p>Early on in region inference, one of the first things we do is to
construct a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/universal_regions/struct.UniversalRegions.html"><code>UniversalRegions</code></a> struct. This struct tracks the
various universal regions in scope on a particular function.  We also
create a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/type_check/free_region_relations/struct.UniversalRegionRelations.html"><code>UniversalRegionRelations</code></a> struct, which tracks their
relationships to one another. So if you have e.g. <code>where 'a: 'b</code>, then
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/type_check/free_region_relations/struct.UniversalRegionRelations.html"><code>UniversalRegionRelations</code></a> struct would track that <code>'a: 'b</code> is
known to hold (which could be tested with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/type_check/free_region_relations/struct.UniversalRegionRelations.html#method.outlives"><code>outlives</code></a> function.</p>
<h2><a class="header" href="#everything-is-a-region-variable" id="everything-is-a-region-variable">Everything is a region variable</a></h2>
<p>One important aspect of how NLL region inference works is that <strong>all
lifetimes</strong> are represented as numbered variables. This means that the
only variant of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.RegionKind.html"><code>ty::RegionKind</code></a> that we use is the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.RegionKind.html#variant.ReVar"><code>ReVar</code></a>
variant. These region variables are broken into two major categories,
based on their index:</p>
<ul>
<li>0..N: universal regions -- the ones we are discussing here. In this
case, the code must be correct with respect to any value of those
variables that meets the declared relationships.</li>
<li>N..M: existential regions -- inference variables where the region
inferencer is tasked with finding <em>some</em> suitable value.</li>
</ul>
<p>In fact, the universal regions can be further subdivided based on
where they were brought into scope (see the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/universal_regions/enum.RegionClassification.html#variant.Local"><code>RegionClassification</code></a>
type). These subdivisions are not important for the topics discussed
here, but become important when we consider <a href="borrow_check/region_inference/./closure_constraints.html">closure constraint
propagation</a>, so we discuss them there.</p>
<h2><a class="header" href="#universal-lifetimes-as-the-elements-of-a-regions-value" id="universal-lifetimes-as-the-elements-of-a-regions-value">Universal lifetimes as the elements of a region's value</a></h2>
<p>As noted previously, the value that we infer for each region is a set
<code>{E}</code>. The elements of this set can be points in the control-flow
graph, but they can also be an element <code>end('a)</code> corresponding to each
universal lifetime <code>'a</code>. If the value for some region <code>R0</code> includes
<code>end('a</code>), then this implies that <code>R0</code> must extend until the end of <code>'a</code>
in the caller.</p>
<h2><a class="header" href="#the-value-of-a-universal-region" id="the-value-of-a-universal-region">The &quot;value&quot; of a universal region</a></h2>
<p>During region inference, we compute a value for each universal region
in the same way as we compute values for other regions. This value
represents, effectively, the <strong>lower bound</strong> on that universal region
-- the things that it must outlive. We now describe how we use this
value to check for errors.</p>
<h2><a class="header" href="#liveness-and-universal-regions" id="liveness-and-universal-regions">Liveness and universal regions</a></h2>
<p>All universal regions have an initial liveness constraint that
includes the entire function body. This is because lifetime parameters
are defined in the caller and must include the entirety of the
function call that invokes this particular function. In addition, each
universal region <code>'a</code> includes itself (that is, <code>end('a)</code>) in its
liveness constraint (i.e., <code>'a</code> must extend until the end of
itself). In the code, these liveness constraints are setup in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.init_free_and_bound_regions"><code>init_free_and_bound_regions</code></a>.</p>
<h2><a class="header" href="#propagating-outlives-constraints-for-universal-regions" id="propagating-outlives-constraints-for-universal-regions">Propagating outlives constraints for universal regions</a></h2>
<p>So, consider the first example of this section:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a u32, y: &amp;'b u32) -&gt; &amp;'b u32 {
  x
}
</code></pre>
<p>Here, returning <code>x</code> requires that <code>&amp;'a u32 &lt;: &amp;'b u32</code>, which gives
rise to an outlives constraint <code>'a: 'b</code>. Combined with our default liveness
constraints we get:</p>
<pre><code class="language-txt">'a live at {B, end('a)} // B represents the &quot;function body&quot;
'b live at {B, end('b)}
'a: 'b
</code></pre>
<p>When we process the <code>'a: 'b</code> constraint, therefore, we will add
<code>end('b)</code> into the value for <code>'a</code>, resulting in a final value of <code>{B, end('a), end('b)}</code>.</p>
<h2><a class="header" href="#detecting-errors" id="detecting-errors">Detecting errors</a></h2>
<p>Once we have finished constraint propagation, we then enforce a
constraint that if some universal region <code>'a</code> includes an element
<code>end('b)</code>, then <code>'a: 'b</code> must be declared in the function's bounds. If
not, as in our example, that is an error. This check is done in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/region_infer/struct.RegionInferenceContext.html#method.check_universal_regions"><code>check_universal_regions</code></a> function, which simply iterates over all
universal regions, inspects their final value, and tests against the
declared <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/type_check/free_region_relations/struct.UniversalRegionRelations.html"><code>UniversalRegionRelations</code></a>.</p>
<h1><a class="header" href="#member-constraints" id="member-constraints">Member constraints</a></h1>
<p>A member constraint <code>'m member of ['c_1..'c_N]</code> expresses that the
region <code>'m</code> must be <em>equal</em> to some <strong>choice regions</strong> <code>'c_i</code> (for
some <code>i</code>). These constraints cannot be expressed by users, but they
arise from <code>impl Trait</code> due to its lifetime capture rules. Consider a
function such as the following:</p>
<pre><code class="language-rust ignore">fn make(a: &amp;'a u32, b: &amp;'b u32) -&gt; impl Trait&lt;'a, 'b&gt; { .. }
</code></pre>
<p>Here, the true return type (often called the &quot;hidden type&quot;) is only
permitted to capture the lifetimes <code>'a</code> or <code>'b</code>. You can kind of see
this more clearly by desugaring that <code>impl Trait</code> return type into its
more explicit form:</p>
<pre><code class="language-rust ignore">type MakeReturn&lt;'x, 'y&gt; = impl Trait&lt;'x, 'y&gt;;
fn make(a: &amp;'a u32, b: &amp;'b u32) -&gt; MakeReturn&lt;'a, 'b&gt; { .. }
</code></pre>
<p>Here, the idea is that the hidden type must be some type that could
have been written in place of the <code>impl Trait&lt;'x, 'y&gt;</code> -- but clearly
such a type can only reference the regions <code>'x</code> or <code>'y</code> (or
<code>'static</code>!), as those are the only names in scope. This limitation is
then translated into a restriction to only access <code>'a</code> or <code>'b</code> because
we are returning <code>MakeReturn&lt;'a, 'b&gt;</code>, where <code>'x</code> and <code>'y</code> have been
replaced with <code>'a</code> and <code>'b</code> respectively.</p>
<h2><a class="header" href="#detailed-example" id="detailed-example">Detailed example</a></h2>
<p>To help us explain member constraints in more detail, let's spell out
the <code>make</code> example in a bit more detail. First off, let's assume that
you have some dummy trait:</p>
<pre><code class="language-rust ignore">trait Trait&lt;'a, 'b&gt; { }
impl&lt;T&gt; Trait&lt;'_, '_&gt; for T { }
</code></pre>
<p>and this is the <code>make</code> function (in desugared form):</p>
<pre><code class="language-rust ignore">type MakeReturn&lt;'x, 'y&gt; = impl Trait&lt;'x, 'y&gt;;
fn make(a: &amp;'a u32, b: &amp;'b u32) -&gt; MakeReturn&lt;'a, 'b&gt; {
  (a, b)
}
</code></pre>
<p>What happens in this case is that the return type will be <code>(&amp;'0 u32, &amp;'1 u32)</code>,
where <code>'0</code> and <code>'1</code> are fresh region variables. We will have the following
region constraints:</p>
<pre><code class="language-txt">'0 live at {L}
'1 live at {L}
'a: '0
'b: '1
'0 member of ['a, 'b, 'static]
'1 member of ['a, 'b, 'static]
</code></pre>
<p>Here the &quot;liveness set&quot; <code>{L}</code> corresponds to that subset of the body
where <code>'0</code> and <code>'1</code> are live -- basically the point from where the
return tuple is constructed to where it is returned (in fact, <code>'0</code> and
<code>'1</code> might have slightly different liveness sets, but that's not very
interesting to the point we are illustrating here).</p>
<p>The <code>'a: '0</code> and <code>'b: '1</code> constraints arise from subtyping. When we
construct the <code>(a, b)</code> value, it will be assigned type <code>(&amp;'0 u32, &amp;'1 u32)</code> -- the region variables reflect that the lifetimes of these
references could be made smaller. For this value to be created from
<code>a</code> and <code>b</code>, however, we do require that:</p>
<pre><code class="language-txt">(&amp;'a u32, &amp;'b u32) &lt;: (&amp;'0 u32, &amp;'1 u32)
</code></pre>
<p>which means in turn that <code>&amp;'a u32 &lt;: &amp;'0 u32</code> and hence that <code>'a: '0</code>
(and similarly that <code>&amp;'b u32 &lt;: &amp;'1 u32</code>, <code>'b: '1</code>).</p>
<p>Note that if we ignore member constraints, the value of <code>'0</code> would be
inferred to some subset of the function body (from the liveness
constraints, which we did not write explicitly). It would never become
<code>'a</code>, because there is no need for it too -- we have a constraint that
<code>'a: '0</code>, but that just puts a &quot;cap&quot; on how <em>large</em> <code>'0</code> can grow to
become. Since we compute the <em>minimal</em> value that we can, we are happy
to leave <code>'0</code> as being just equal to the liveness set. This is where
member constraints come in.</p>
<h2><a class="header" href="#choices-are-always-lifetime-parameters" id="choices-are-always-lifetime-parameters">Choices are always lifetime parameters</a></h2>
<p>At present, the &quot;choice&quot; regions from a member constraint are always
lifetime parameters from the current function. This falls out from the
placement of impl Trait, though in the future it may not be the case.
We take some advantage of this fact, as it simplifies the current
code. In particular, we don't have to consider a case like <code>'0 member of ['1, 'static]</code>, in which the value of both <code>'0</code> and <code>'1</code> are being
inferred and hence changing. See <a href="https://github.com/rust-lang/rust/issues/61773">rust-lang/rust#61773</a> for more
information.</p>
<h2><a class="header" href="#applying-member-constraints" id="applying-member-constraints">Applying member constraints</a></h2>
<p>Member constraints are a bit more complex than other forms of
constraints. This is because they have a &quot;or&quot; quality to them -- that
is, they describe multiple choices that we must select from. E.g., in
our example constraint <code>'0 member of ['a, 'b, 'static]</code>, it might be
that <code>'0</code> is equal to <code>'a</code>, <code>'b</code>, <em>or</em> <code>'static</code>. How can we pick the
correct one?  What we currently do is to look for a <em>minimal choice</em>
-- if we find one, then we will grow <code>'0</code> to be equal to that minimal
choice. To find that minimal choice, we take two factors into
consideration: lower and upper bounds.</p>
<h3><a class="header" href="#lower-bounds" id="lower-bounds">Lower bounds</a></h3>
<p>The <em>lower bounds</em> are those lifetimes that <code>'0</code> <em>must outlive</em> --
i.e., that <code>'0</code> must be larger than. In fact, when it comes time to
apply member constraints, we've already <em>computed</em> the lower bounds of
<code>'0</code> because we computed its minimal value (or at least, the lower
bounds considering everything but member constraints).</p>
<p>Let <code>LB</code> be the current value of <code>'0</code>. We know then that <code>'0: LB</code> must
hold, whatever the final value of <code>'0</code> is. Therefore, we can rule out
any choice <code>'choice</code> where <code>'choice: LB</code> does not hold.</p>
<p>Unfortunately, in our example, this is not very helpful. The lower
bound for <code>'0</code> will just be the liveness set <code>{L}</code>, and we know that
all the lifetime parameters outlive that set. So we are left with the
same set of choices here. (But in other examples, particularly those
with different variance, lower bound constraints may be relevant.)</p>
<h3><a class="header" href="#upper-bounds" id="upper-bounds">Upper bounds</a></h3>
<p>The <em>upper bounds</em> are those lifetimes that <em>must outlive</em> <code>'0</code> --
i.e., that <code>'0</code> must be <em>smaller</em> than. In our example, this would be
<code>'a</code>, because we have the constraint that <code>'a: '0</code>. In more complex
examples, the chain may be more indirect.</p>
<p>We can use upper bounds to rule out members in a very similar way to
lower lower bounds. If UB is some upper bound, then we know that <code>UB: '0</code> must hold, so we can rule out any choice <code>'choice</code> where <code>UB: 'choice</code> does not hold.</p>
<p>In our example, we would be able to reduce our choice set from <code>['a, 'b, 'static]</code> to just <code>['a]</code>. This is because <code>'0</code> has an upper bound
of <code>'a</code>, and neither <code>'a: 'b</code> nor <code>'a: 'static</code> is known to hold.</p>
<p>(For notes on how we collect upper bounds in the implementation, see
<a href="borrow_check/region_inference/member_constraints.html#collecting">the section below</a>.)</p>
<h3><a class="header" href="#minimal-choice" id="minimal-choice">Minimal choice</a></h3>
<p>After applying lower and upper bounds, we can still sometimes have
multiple possibilities. For example, imagine a variant of our example
using types with the opposite variance. In that case, we would have
the constraint <code>'0: 'a</code> instead of <code>'a: '0</code>. Hence the current value
of <code>'0</code> would be <code>{L, 'a}</code>. Using this as a lower bound, we would be
able to narrow down the member choices to <code>['a, 'static]</code> because <code>'b: 'a</code> is not known to hold (but <code>'a: 'a</code> and <code>'static: 'a</code> do hold). We
would not have any upper bounds, so that would be our final set of choices.</p>
<p>In that case, we apply the <strong>minimal choice</strong> rule -- basically, if
one of our choices if smaller than the others, we can use that. In
this case, we would opt for <code>'a</code> (and not <code>'static</code>).</p>
<p>This choice is consistent with the general 'flow' of region
propagation, which always aims to compute a minimal value for the
region being inferred. However, it is somewhat arbitrary.</p>
<p><a name="collecting"></a></p>
<h3><a class="header" href="#collecting-upper-bounds-in-the-implementation" id="collecting-upper-bounds-in-the-implementation">Collecting upper bounds in the implementation</a></h3>
<p>In practice, computing upper bounds is a bit inconvenient, because our
data structures are setup for the opposite. What we do is to compute
the <strong>reverse SCC graph</strong> (we do this lazily and cache the result) --
that is, a graph where <code>'a: 'b</code> induces an edge <code>SCC('b) -&gt; SCC('a)</code>. Like the normal SCC graph, this is a DAG. We can then do a
depth-first search starting from <code>SCC('0)</code> in this graph. This will
take us to all the SCCs that must outlive <code>'0</code>.</p>
<p>One wrinkle is that, as we walk the &quot;upper bound&quot; SCCs, their values
will not yet have been fully computed. However, we <strong>have</strong> already
applied their liveness constraints, so we have some information about
their value. In particular, for any regions representing lifetime
parameters, their value will contain themselves (i.e., the initial
value for <code>'a</code> includes <code>'a</code> and the value for <code>'b</code> contains <code>'b</code>). So
we can collect all of the lifetime parameters that are reachable,
which is precisely what we are interested in.</p>
<h1><a class="header" href="#placeholders-and-universes" id="placeholders-and-universes">Placeholders and universes</a></h1>
<p>From time to time we have to reason about regions that we can't
concretely know. For example, consider this program:</p>
<pre><code class="language-rust ignore">// A function that needs a static reference
fn foo(x: &amp;'static u32) { }

fn bar(f: for&lt;'a&gt; fn(&amp;'a u32)) {
       // ^^^^^^^^^^^^^^^^^^^ a function that can accept **any** reference
    let x = 22;
    f(&amp;x);
}

fn main() {
    bar(foo);
}
</code></pre>
<p>This program ought not to type-check: <code>foo</code> needs a static reference
for its argument, and <code>bar</code> wants to be given a function that that
accepts <strong>any</strong> reference (so it can call it with something on its
stack, for example). But <em>how</em> do we reject it and <em>why</em>?</p>
<h2><a class="header" href="#subtyping-and-placeholders" id="subtyping-and-placeholders">Subtyping and Placeholders</a></h2>
<p>When we type-check <code>main</code>, and in particular the call <code>bar(foo)</code>, we
are going to wind up with a subtyping relationship like this one:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: for&lt;'a&gt; fn(&amp;'a u32)
----------------    -------------------
the type of `foo`   the type `bar` expects
</code></pre>
<p>We handle this sort of subtyping by taking the variables that are
bound in the supertype and replacing them with
<a href="borrow_check/region_inference/../../appendix/background.html#quantified">universally quantified</a>
representatives, denoted like <code>!1</code> here. We call these regions &quot;placeholder
regions&quot; – they represent, basically, &quot;some unknown region&quot;.</p>
<p>Once we've done that replacement, we have the following relation:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32)
</code></pre>
<p>The key idea here is that this unknown region <code>'!1</code> is not related to
any other regions. So if we can prove that the subtyping relationship
is true for <code>'!1</code>, then it ought to be true for any region, which is
what we wanted.</p>
<p>So let's work through what happens next. To check if two functions are
subtypes, we check if their arguments have the desired relationship
(fn arguments are <a href="borrow_check/region_inference/../../appendix/background.html#variance">contravariant</a>, so
we swap the left and right here):</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'static u32
</code></pre>
<p>According to the basic subtyping rules for a reference, this will be
true if <code>'!1: 'static</code>. That is – if &quot;some unknown region <code>!1</code>&quot; lives
outlives <code>'static</code>. Now, this <em>might</em> be true – after all, <code>'!1</code>
could be <code>'static</code> – but we don't <em>know</em> that it's true. So this
should yield up an error (eventually).</p>
<h2><a class="header" href="#what-is-a-universe" id="what-is-a-universe">What is a universe?</a></h2>
<p>In the previous section, we introduced the idea of a placeholder
region, and we denoted it <code>!1</code>. We call this number <code>1</code> the <strong>universe
index</strong>. The idea of a &quot;universe&quot; is that it is a set of names that
are in scope within some type or at some point. Universes are formed
into a tree, where each child extends its parents with some new names.
So the <strong>root universe</strong> conceptually contains global names, such as
the the lifetime <code>'static</code> or the type <code>i32</code>. In the compiler, we also
put generic type parameters into this root universe (in this sense,
there is not just one root universe, but one per item). So consider
this function <code>bar</code>:</p>
<pre><code class="language-rust ignore">struct Foo { }

fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    ...
}
</code></pre>
<p>Here, the root universe would consist of the lifetimes <code>'static</code> and
<code>'a</code>.  In fact, although we're focused on lifetimes here, we can apply
the same concept to types, in which case the types <code>Foo</code> and <code>T</code> would
be in the root universe (along with other global types, like <code>i32</code>).
Basically, the root universe contains all the names that
<a href="borrow_check/region_inference/../../appendix/background.html#free-vs-bound">appear free</a> in the body of <code>bar</code>.</p>
<p>Now let's extend <code>bar</code> a bit by adding a variable <code>x</code>:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;
}
</code></pre>
<p>Here, the name <code>'b</code> is not part of the root universe. Instead, when we
&quot;enter&quot; into this <code>for&lt;'b&gt;</code> (e.g., by replacing it with a placeholder), we will create
a child universe of the root, let's call it U1:</p>
<pre><code class="language-text">U0 (root universe)
│
└─ U1 (child universe)
</code></pre>
<p>The idea is that this child universe U1 extends the root universe U0
with a new name, which we are identifying by its universe number:
<code>!1</code>.</p>
<p>Now let's extend <code>bar</code> a bit by adding one more variable, <code>y</code>:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;
    let y: for&lt;'c&gt; fn(&amp;'b u32) = ...;
}
</code></pre>
<p>When we enter <em>this</em> type, we will again create a new universe, which
we'll call <code>U2</code>. Its parent will be the root universe, and U1 will be
its sibling:</p>
<pre><code class="language-text">U0 (root universe)
│
├─ U1 (child universe)
│
└─ U2 (child universe)
</code></pre>
<p>This implies that, while in U2, we can name things from U0 or U2, but
not U1.</p>
<p><strong>Giving existential variables a universe.</strong> Now that we have this
notion of universes, we can use it to extend our type-checker and
things to prevent illegal names from leaking out. The idea is that we
give each inference (existential) variable – whether it be a type or
a lifetime – a universe. That variable's value can then only
reference names visible from that universe. So for example if a
lifetime variable is created in U0, then it cannot be assigned a value
of <code>!1</code> or <code>!2</code>, because those names are not visible from the universe
U0.</p>
<p><strong>Representing universes with just a counter.</strong> You might be surprised
to see that the compiler doesn't keep track of a full tree of
universes. Instead, it just keeps a counter – and, to determine if
one universe can see another one, it just checks if the index is
greater. For example, U2 can see U0 because 2 &gt;= 0. But U0 cannot see
U2, because 0 &gt;= 2 is false.</p>
<p>How can we get away with this? Doesn't this mean that we would allow
U2 to also see U1? The answer is that, yes, we would, <strong>if that
question ever arose</strong>.  But because of the structure of our type
checker etc, there is no way for that to happen. In order for
something happening in the universe U1 to &quot;communicate&quot; with something
happening in U2, they would have to have a shared inference variable X
in common. And because everything in U1 is scoped to just U1 and its
children, that inference variable X would have to be in U0. And since
X is in U0, it cannot name anything from U1 (or U2). This is perhaps easiest
to see by using a kind of generic &quot;logic&quot; example:</p>
<pre><code class="language-text">exists&lt;X&gt; {
   forall&lt;Y&gt; { ... /* Y is in U1 ... */ }
   forall&lt;Z&gt; { ... /* Z is in U2 ... */ }
}
</code></pre>
<p>Here, the only way for the two foralls to interact would be through X,
but neither Y nor Z are in scope when X is declared, so its value
cannot reference either of them.</p>
<h2><a class="header" href="#universes-and-placeholder-region-elements" id="universes-and-placeholder-region-elements">Universes and placeholder region elements</a></h2>
<p>But where does that error come from?  The way it happens is like this.
When we are constructing the region inference context, we can tell
from the type inference context how many placeholder variables exist
(the <code>InferCtxt</code> has an internal counter). For each of those, we
create a corresponding universal region variable <code>!n</code> and a &quot;region
element&quot; <code>placeholder(n)</code>. This corresponds to &quot;some unknown set of other
elements&quot;. The value of <code>!n</code> is <code>{placeholder(n)}</code>.</p>
<p>At the same time, we also give each existential variable a
<strong>universe</strong> (also taken from the <code>InferCtxt</code>). This universe
determines which placeholder elements may appear in its value: For
example, a variable in universe U3 may name <code>placeholder(1)</code>, <code>placeholder(2)</code>, and
<code>placeholder(3)</code>, but not <code>placeholder(4)</code>. Note that the universe of an inference
variable controls what region elements <strong>can</strong> appear in its value; it
does not say region elements <strong>will</strong> appear.</p>
<h2><a class="header" href="#placeholders-and-outlives-constraints" id="placeholders-and-outlives-constraints">Placeholders and outlives constraints</a></h2>
<p>In the region inference engine, outlives constraints have the form:</p>
<pre><code class="language-text">V1: V2 @ P
</code></pre>
<p>where <code>V1</code> and <code>V2</code> are region indices, and hence map to some region
variable (which may be universally or existentially quantified). The
<code>P</code> here is a &quot;point&quot; in the control-flow graph; it's not important
for this section. This variable will have a universe, so let's call
those universes <code>U(V1)</code> and <code>U(V2)</code> respectively. (Actually, the only
one we are going to care about is <code>U(V1)</code>.)</p>
<p>When we encounter this constraint, the ordinary procedure is to start
a DFS from <code>P</code>. We keep walking so long as the nodes we are walking
are present in <code>value(V2)</code> and we add those nodes to <code>value(V1)</code>. If
we reach a return point, we add in any <code>end(X)</code> elements. That part
remains unchanged.</p>
<p>But then <em>after that</em> we want to iterate over the placeholder <code>placeholder(x)</code>
elements in V2 (each of those must be visible to <code>U(V2)</code>, but we
should be able to just assume that is true, we don't have to check
it). We have to ensure that <code>value(V1)</code> outlives each of those
placeholder elements.</p>
<p>Now there are two ways that could happen. First, if <code>U(V1)</code> can see
the universe <code>x</code> (i.e., <code>x &lt;= U(V1)</code>), then we can just add <code>placeholder(x)</code>
to <code>value(V1)</code> and be done. But if not, then we have to approximate:
we may not know what set of elements <code>placeholder(x)</code> represents, but we
should be able to compute some sort of <strong>upper bound</strong> B for it –
some region B that outlives <code>placeholder(x)</code>. For now, we'll just use
<code>'static</code> for that (since it outlives everything) – in the future, we
can sometimes be smarter here (and in fact we have code for doing this
already in other contexts). Moreover, since <code>'static</code> is in the root
universe U0, we know that all variables can see it – so basically if
we find that <code>value(V2)</code> contains <code>placeholder(x)</code> for some universe <code>x</code>
that <code>V1</code> can't see, then we force <code>V1</code> to <code>'static</code>.</p>
<h2><a class="header" href="#extending-the-universal-regions-check" id="extending-the-universal-regions-check">Extending the &quot;universal regions&quot; check</a></h2>
<p>After all constraints have been propagated, the NLL region inference
has one final check, where it goes over the values that wound up being
computed for each universal region and checks that they did not get
'too large'. In our case, we will go through each placeholder region
and check that it contains <em>only</em> the <code>placeholder(u)</code> element it is known to
outlive. (Later, we might be able to know that there are relationships
between two placeholder regions and take those into account, as we do
for universal regions from the fn signature.)</p>
<p>Put another way, the &quot;universal regions&quot; check can be considered to be
checking constraints like:</p>
<pre><code class="language-text">{placeholder(1)}: V1
</code></pre>
<p>where <code>{placeholder(1)}</code> is like a constant set, and V1 is the variable we
made to represent the <code>!1</code> region.</p>
<h2><a class="header" href="#back-to-our-example" id="back-to-our-example">Back to our example</a></h2>
<p>OK, so far so good. Now let's walk through what would happen with our
first example:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32) @ P  // this point P is not imp't here
</code></pre>
<p>The region inference engine will create a region element domain like this:</p>
<pre><code class="language-text">{ CFG; end('static); placeholder(1) }
  ---  ------------  ------- from the universe `!1`
  |    'static is always in scope
  all points in the CFG; not especially relevant here
</code></pre>
<p>It will always create two universal variables, one representing
<code>'static</code> and one representing <code>'!1</code>. Let's call them Vs and V1. They
will have initial values like so:</p>
<pre><code class="language-text">Vs = { CFG; end('static) } // it is in U0, so can't name anything else
V1 = { placeholder(1) }
</code></pre>
<p>From the subtyping constraint above, we would have an outlives constraint like</p>
<pre><code class="language-text">'!1: 'static @ P
</code></pre>
<p>To process this, we would grow the value of V1 to include all of Vs:</p>
<pre><code class="language-text">Vs = { CFG; end('static) }
V1 = { CFG; end('static), placeholder(1) }
</code></pre>
<p>At that point, constraint propagation is complete, because all the
outlives relationships are satisfied. Then we would go to the &quot;check
universal regions&quot; portion of the code, which would test that no
universal region grew too large.</p>
<p>In this case, <code>V1</code> <em>did</em> grow too large – it is not known to outlive
<code>end('static)</code>, nor any of the CFG – so we would report an error.</p>
<h2><a class="header" href="#another-example" id="another-example">Another example</a></h2>
<p>What about this subtyping relationship?</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)
    &lt;:
for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32)
</code></pre>
<p>Here we would replace the bound region in the supertype with a placeholder, as before, yielding:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32)
</code></pre>
<p>then we instantiate the variable on the left-hand side with an
existential in universe U2, yielding the following (<code>?n</code> is a notation
for an existential variable):</p>
<pre><code class="language-text">fn(&amp;'?3 u32, &amp;'?3 u32)
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32)
</code></pre>
<p>Then we break this down further:</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'?3 u32
&amp;'!2 u32 &lt;: &amp;'?3 u32
</code></pre>
<p>and even further, yield up our region constraints:</p>
<pre><code class="language-text">'!1: '?3
'!2: '?3
</code></pre>
<p>Note that, in this case, both <code>'!1</code> and <code>'!2</code> have to outlive the
variable <code>'?3</code>, but the variable <code>'?3</code> is not forced to outlive
anything else. Therefore, it simply starts and ends as the empty set
of elements, and hence the type-check succeeds here.</p>
<p>(This should surprise you a little. It surprised me when I first realized it.
We are saying that if we are a fn that <strong>needs both of its arguments to have
the same region</strong>, we can accept being called with <strong>arguments with two
distinct regions</strong>. That seems intuitively unsound. But in fact, it's fine, as
I tried to explain in <a href="https://github.com/rust-lang/rust/issues/32330#issuecomment-202536977">this issue</a> on the Rust issue
tracker long ago.  The reason is that even if we get called with arguments of
two distinct lifetimes, those two lifetimes have some intersection (the call
itself), and that intersection can be our value of <code>'a</code> that we use as the
common lifetime of our arguments. -nmatsakis)</p>
<h2><a class="header" href="#final-example" id="final-example">Final example</a></h2>
<p>Let's look at one last example. We'll extend the previous one to have
a return type:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32
    &lt;:
for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32) -&gt; &amp;'b u32
</code></pre>
<p>Despite seeming very similar to the previous example, this case is going to get
an error. That's good: the problem is that we've gone from a fn that promises
to return one of its two arguments, to a fn that is promising to return the
first one. That is unsound. Let's see how it plays out.</p>
<p>First, we replace the bound region in the supertype with a placeholder:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32
</code></pre>
<p>Then we instantiate the subtype with existentials (in U2):</p>
<pre><code class="language-text">fn(&amp;'?3 u32, &amp;'?3 u32) -&gt; &amp;'?3 u32
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32
</code></pre>
<p>And now we create the subtyping relationships:</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'?3 u32 // arg 1
&amp;'!2 u32 &lt;: &amp;'?3 u32 // arg 2
&amp;'?3 u32 &lt;: &amp;'!1 u32 // return type
</code></pre>
<p>And finally the outlives relationships. Here, let V1, V2, and V3 be the
variables we assign to <code>!1</code>, <code>!2</code>, and <code>?3</code> respectively:</p>
<pre><code class="language-text">V1: V3
V2: V3
V3: V1
</code></pre>
<p>Those variables will have these initial values:</p>
<pre><code class="language-text">V1 in U1 = {placeholder(1)}
V2 in U2 = {placeholder(2)}
V3 in U2 = {}
</code></pre>
<p>Now because of the <code>V3: V1</code> constraint, we have to add <code>placeholder(1)</code> into <code>V3</code> (and
indeed it is visible from <code>V3</code>), so we get:</p>
<pre><code class="language-text">V3 in U2 = {placeholder(1)}
</code></pre>
<p>then we have this constraint <code>V2: V3</code>, so we wind up having to enlarge
<code>V2</code> to include <code>placeholder(1)</code> (which it can also see):</p>
<pre><code class="language-text">V2 in U2 = {placeholder(1), placeholder(2)}
</code></pre>
<p>Now constraint propagation is done, but when we check the outlives
relationships, we find that <code>V2</code> includes this new element <code>placeholder(1)</code>,
so we report an error.</p>
<h1><a class="header" href="#propagating-closure-constraints" id="propagating-closure-constraints">Propagating closure constraints</a></h1>
<p>When we are checking the type tests and universal regions, we may come
across a constraint that we can't prove yet if we are in a closure
body! However, the necessary constraints may actually hold (we just
don't know it yet). Thus, if we are inside a closure, we just collect
all the constraints we can't prove yet and return them. Later, when we
are borrow check the MIR node that created the closure, we can also
check that these constraints hold. At that time, if we can't prove
they hold, we report an error.</p>
<h1><a class="header" href="#reporting-region-errors" id="reporting-region-errors">Reporting region errors</a></h1>
<p>TODO: we should discuss how to generate errors from the results of these analyses.</p>
<h1><a class="header" href="#two-phase-borrows" id="two-phase-borrows">Two-phase borrows</a></h1>
<p>Two-phase borrows are a more permissive version of mutable borrows that allow
nested method calls such as <code>vec.push(vec.len())</code>. Such borrows first act as
shared borrows in a &quot;reservation&quot; phase and can later be &quot;activated&quot; into a
full mutable borrow.</p>
<p>Only certain implicit mutable borrows can be two-phase, any <code>&amp;mut</code> or <code>ref mut</code>
in the source code is never a two-phase borrow. The cases where we generate a
two-phase borrow are:</p>
<ol>
<li>The autoref borrow when calling a method with a mutable reference receiver.</li>
<li>A mutable reborrow in function arguments.</li>
<li>The implicit mutable borrow in an overloaded compound assignment operator.</li>
</ol>
<p>To give some examples:</p>
<pre><pre class="playpen"><code class="language-rust2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// In the source code

// Case 1:
let mut v = Vec::new();
v.push(v.len());
let r = &amp;mut Vec::new();
r.push(r.len());

// Case 2:
std::mem::replace(r, vec![1, r.len()]);

// Case 3:
let mut x = std::num::Wrapping(2);
x += x;
<span class="boring">}
</span></code></pre></pre>
<p>Expanding these enough to show the two-phase borrows:</p>
<pre><code class="language-rust ignore">// Case 1:
let mut v = Vec::new();
let temp1 = &amp;two_phase v;
let temp2 = v.len();
Vec::push(temp1, temp2);
let r = &amp;mut Vec::new();
let temp3 = &amp;two_phase *r;
let temp4 = r.len();
Vec::push(temp3, temp4);

// Case 2:
let temp5 = &amp;two_phase *r;
let temp6 = vec![1, r.len()];
std::mem::replace(temp5, temp6);

// Case 3:
let mut x = std::num::Wrapping(2);
let temp7 = &amp;two_phase x;
let temp8 = x;
std::ops::AddAssign::add_assign(temp7, temp8);
</code></pre>
<p>Whether a borrow can be two-phase is tracked by a flag on the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html"><code>AutoBorrow</code></a>
after type checking, which is then <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/cx/expr/trait.ToBorrowKind.html#method.to_borrow_kind">converted</a> to a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html"><code>BorrowKind</code></a> during MIR
construction.</p>
<p>Each two-phase borrow is assigned to a temporary that is only used once. As
such we can define:</p>
<ul>
<li>The point where the temporary is assigned to is called the <em>reservation</em>
point of the two-phase borrow.</li>
<li>The point where the temporary is used, which is effectively always a
function call, is called the <em>activation</em> point.</li>
</ul>
<p>The activation points are found using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html#method.visit_local"><code>GatherBorrows</code></a> visitor. The
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/borrow_set/struct.BorrowData.html"><code>BorrowData</code></a> then holds both the reservation and activation points for the
borrow.</p>
<h2><a class="header" href="#checking-two-phase-borrows" id="checking-two-phase-borrows">Checking two-phase borrows</a></h2>
<p>Two-phase borrows are treated as if they were mutable borrows with the
following exceptions:</p>
<ol>
<li>At every location in the MIR we <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/struct.MirBorrowckCtxt.html#method.check_activations">check</a> if any two-phase borrows are
activated at this location. If a live two phase borrow is activated at a
location, then we check that there are no borrows that conflict with the
two-phase borrow.</li>
<li>At the reservation point we error if there are conflicting live <em>mutable</em>
borrows. And lint if there are any conflicting shared borrows.</li>
<li>Between the reservation and the activation point, the two-phase borrow acts
as a shared borrow. We determine (in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/path_utils/fn.is_active.html"><code>is_active</code></a>) if we're at such a point
by using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html"><code>Dominators</code></a> for the MIR graph.</li>
<li>After the activation point, the two-phase borrow acts as a mutable borrow.</li>
</ol>
<h1><a class="header" href="#parameter-environment" id="parameter-environment">Parameter Environment</a></h1>
<p>When working with associated and/or or generic items (types, constants,
functions/methods) it is often relevant to have more information about the
<code>Self</code> or generic parameters. Trait bounds and similar information is encoded in
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.ParamEnv.html"><code>ParamEnv</code></a>. Often this is not enough information to obtain things like the
type's <code>Layout</code>, but you can do all kinds of other checks on it (e.g. whether a
type implements <code>Copy</code>) or you can evaluate an associated constant whose value
does not depend on anything from the parameter environment.</p>
<p>For example if you have a function</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Copy&gt;(t: T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>the parameter environment for that function is <code>[T: Copy]</code>. This means any
evaluation within this function will, when accessing the type <code>T</code>, know about
its <code>Copy</code> bound via the parameter environment.</p>
<p>You can get the parameter environment for a <code>def_id</code> using the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ty/ty/fn.param_env.html"><code>param_env</code></a> query. However, this <code>ParamEnv</code> can be too generic for
your use case. Using the <code>ParamEnv</code> from the surrounding context can allow you
to evaluate more things. For example, suppose we had something the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Assoc;
}

trait Bar { }

trait Baz {
    fn stuff() -&gt; bool;
}

fn foo&lt;T&gt;(t: T)
where
    T: Foo,
    &lt;T as Foo&gt;::Assoc: Bar
{
   bar::&lt;T::Assoc&gt;()
}

fn bar&lt;T: Baz&gt;() {
    if T::stuff() { mep() } else { mop() }
}
<span class="boring">}
</span></code></pre></pre>
<p>We may know some things inside <code>bar</code> that we wouldn't know if we just fetched
<code>bar</code>'s param env because of the <code>&lt;T as Foo&gt;::Assoc: Bar</code> bound in <code>foo</code>. This
is a contrived example that makes no sense in our existing analyses, but we may
run into similar cases when doing analyses with associated constants on generic
traits or traits with assoc types.</p>
<h2><a class="header" href="#bundling" id="bundling">Bundling</a></h2>
<p>Another great thing about <code>ParamEnv</code> is that you can use it to bundle the thing
depending on generic parameters (e.g. a <code>Ty</code>) by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.ParamEnv.html#method.and"><code>and</code></a>
method. This will produce a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.ParamEnvAnd.html"><code>ParamEnvAnd&lt;Ty&gt;</code></a>, making clear that you
should probably not be using the inner value without taking care to also use
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.ParamEnv.html"><code>ParamEnv</code></a>.</p>
<h1><a class="header" href="#from-mir-to-binaries" id="from-mir-to-binaries">From MIR to Binaries</a></h1>
<p>All of the preceding chapters of this guide have one thing in common: we never
generated any executable machine code at all! With this chapter, all of that
changes.</p>
<p>So far, we've shown how the compiler can take raw source code in text format
and transform it into MIR. We have also shown how the compiler does various
analyses on the code to detect things like type or lifetime errors. Now, we
will finally take the MIR and produce some executable machine code.</p>
<blockquote>
<p>NOTE: This part of a compiler is often called the <em>backend</em> the term is a bit
overloaded because in the compiler source, it usually refers to the &quot;codegen
backend&quot; (i.e. LLVM or Cranelift). Usually, when you see the word &quot;backend&quot;
in this part, we are refering to the &quot;codegen backend&quot;.</p>
</blockquote>
<p>So what do we need to do?</p>
<ol start="0">
<li>First, we need to collect the set of things to generate code for. In
particular, we need to find out which concrete types to substitute for
generic ones, since we need to generate code for the concrete types.
Generating code for the concrete types (i.e. emitting a copy of the code for
each concrete type) is called <em>monomorphization</em>, so the process of
collecting all the concrete types is called <em>monomorphization collection</em>.</li>
<li>Next, we need to actually lower the MIR to a codegen IR
(usually LLVM IR) for each concrete type we collected.</li>
<li>Finally, we need to invoke LLVM or Cranelift, which runs a bunch of
optimization passes, generates executable code, and links together an
executable binary.</li>
</ol>
<p>The code for codegen is actually a bit complex due to a few factors:</p>
<ul>
<li>Support for multiple codegen backends (LLVM and Cranelift). We try to share as much
backend code between them as possible, so a lot of it is generic over the
codegen implementation. This means that there are often a lot of layers of
abstraction.</li>
<li>Codegen happens asynchronously in another thread for performance.</li>
<li>The actual codegen is done by a third-party library (either LLVM or Cranelift).</li>
</ul>
<p>Generally, the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/index.html"><code>rustc_codegen_ssa</code></a> crate contains backend-agnostic code
(i.e. independent of LLVM or Cranelift), while the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/index.html"><code>rustc_codegen_llvm</code></a>
crate contains code specific to LLVM codegen.</p>
<p>At a very high level, the entry point is
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_crate.html"><code>rustc_codegen_ssa::base::codegen_crate</code></a>. This function starts the
process discussed in the rest of this chapter.</p>
<h1><a class="header" href="#the-mir-mid-level-ir-1" id="the-mir-mid-level-ir-1">The MIR (Mid-level IR)</a></h1>
<p>MIR is Rust's <em>Mid-level Intermediate Representation</em>. It is
constructed from <a href="mir/../hir.html">HIR</a>. MIR was introduced in
<a href="https://rust-lang.github.io/rfcs/1211-mir.html">RFC 1211</a>. It is a radically simplified form of Rust that is used for
certain flow-sensitive safety checks – notably the borrow checker! –
and also for optimization and code generation.</p>
<p>If you'd like a very high-level introduction to MIR, as well as some
of the compiler concepts that it relies on (such as control-flow
graphs and desugaring), you may enjoy the
<a href="https://blog.rust-lang.org/2016/04/19/MIR.html">rust-lang blog post that introduced MIR</a>.</p>
<h2><a class="header" href="#introduction-to-mir-1" id="introduction-to-mir-1">Introduction to MIR</a></h2>
<p>MIR is defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_middle/mir"><code>src/librustc_middle/mir/</code></a> module, but much of the code
that manipulates it is found in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir"><code>src/librustc_mir</code></a>.</p>
<p>Some of the key characteristics of MIR are:</p>
<ul>
<li>It is based on a <a href="mir/../appendix/background.html#cfg">control-flow graph</a>.</li>
<li>It does not have nested expressions.</li>
<li>All types in MIR are fully explicit.</li>
</ul>
<h2><a class="header" href="#key-mir-vocabulary-1" id="key-mir-vocabulary-1">Key MIR vocabulary</a></h2>
<p>This section introduces the key concepts of MIR, summarized here:</p>
<ul>
<li><strong>Basic blocks</strong>: units of the control-flow graph, consisting of:
<ul>
<li><strong>statements:</strong> actions with one successor</li>
<li><strong>terminators:</strong> actions with potentially multiple successors; always at
the end of a block</li>
<li>(if you're not familiar with the term <em>basic block</em>, see the <a href="mir/../appendix/background.html#cfg">background
chapter</a>)</li>
</ul>
</li>
<li><strong>Locals:</strong> Memory locations allocated on the stack (conceptually, at
least), such as function arguments, local variables, and
temporaries. These are identified by an index, written with a
leading underscore, like <code>_1</code>. There is also a special &quot;local&quot;
(<code>_0</code>) allocated to store the return value.</li>
<li><strong>Places:</strong> expressions that identify a location in memory, like <code>_1</code> or
<code>_1.f</code>.</li>
<li><strong>Rvalues:</strong> expressions that produce a value. The &quot;R&quot; stands for
the fact that these are the &quot;right-hand side&quot; of an assignment.
<ul>
<li><strong>Operands:</strong> the arguments to an rvalue, which can either be a
constant (like <code>22</code>) or a place (like <code>_1</code>).</li>
</ul>
</li>
</ul>
<p>You can get a feeling for how MIR is structed by translating simple
programs into MIR and reading the pretty printed output. In fact, the
playground makes this easy, since it supplies a MIR button that will
show you the MIR for your program. Try putting this program into play
(or <a href="https://play.rust-lang.org/?gist=30074856e62e74e91f06abd19bd72ece&amp;version=stable">clicking on this link</a>), and then clicking the &quot;MIR&quot;
button on the top:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);
}
</code></pre></pre>
<p>You should see something like:</p>
<pre><code class="language-mir">// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -&gt; () {
    ...
}
</code></pre>
<p>This is the MIR format for the <code>main</code> function.</p>
<p><strong>Variable declarations.</strong> If we drill in a bit, we'll see it begins
with a bunch of variable declarations. They look like this:</p>
<pre><code class="language-mir">let mut _0: ();                      // return place
let mut _1: std::vec::Vec&lt;i32&gt;;      // in scope 0 at src/main.rs:2:9: 2:16
let mut _2: ();
let mut _3: &amp;mut std::vec::Vec&lt;i32&gt;;
let mut _4: ();
let mut _5: &amp;mut std::vec::Vec&lt;i32&gt;;
</code></pre>
<p>You can see that variables in MIR don't have names, they have indices,
like <code>_0</code> or <code>_1</code>.  We also intermingle the user's variables (e.g.,
<code>_1</code>) with temporary values (e.g., <code>_2</code> or <code>_3</code>). You can tell apart
user-defined variables because they have debuginfo associated to them (see below).</p>
<p><strong>User variable debuginfo.</strong> Below the variable declarations, we find the only
hint that <code>_1</code> represents a user variable:</p>
<pre><code class="language-mir">scope 1 {
    debug vec =&gt; _1;                 // in scope 1 at src/main.rs:2:9: 2:16
}
</code></pre>
<p>Each <code>debug &lt;Name&gt; =&gt; &lt;Place&gt;;</code> annotation describes a named user variable,
and where (i.e. the place) a debugger can find the data of that variable.
Here the mapping is trivial, but optimizations may complicate the place,
or lead to multiple user variables sharing the same place.
Additionally, closure captures are described using the same system, and so
they're complicated even without optimizations, e.g.: <code>debug x =&gt; (*((*_1).0: &amp;T));</code>.</p>
<p>The &quot;scope&quot; blocks (e.g., <code>scope 1 { .. }</code>) describe the lexical structure of
the source program (which names were in scope when), so any part of the program
annotated with <code>// in scope 0</code> would be missing <code>vec</code>, if you were stepping
through the code in a debugger, for example.</p>
<p><strong>Basic blocks.</strong> Reading further, we see our first <strong>basic block</strong> (naturally
it may look slightly different when you view it, and I am ignoring some of the
comments):</p>
<pre><code class="language-mir">bb0: {
    StorageLive(_1);
    _1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
}
</code></pre>
<p>A basic block is defined by a series of <strong>statements</strong> and a final
<strong>terminator</strong>.  In this case, there is one statement:</p>
<pre><code class="language-mir">StorageLive(_1);
</code></pre>
<p>This statement indicates that the variable <code>_1</code> is &quot;live&quot;, meaning
that it may be used later – this will persist until we encounter a
<code>StorageDead(_1)</code> statement, which indicates that the variable <code>_1</code> is
done being used. These &quot;storage statements&quot; are used by LLVM to
allocate stack space.</p>
<p>The <strong>terminator</strong> of the block <code>bb0</code> is the call to <code>Vec::new</code>:</p>
<pre><code class="language-mir">_1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
</code></pre>
<p>Terminators are different from statements because they can have more
than one successor – that is, control may flow to different
places. Function calls like the call to <code>Vec::new</code> are always
terminators because of the possibility of unwinding, although in the
case of <code>Vec::new</code> we are able to see that indeed unwinding is not
possible, and hence we list only one successor block, <code>bb2</code>.</p>
<p>If we look ahead to <code>bb2</code>, we will see it looks like this:</p>
<pre><code class="language-mir">bb2: {
    StorageLive(_3);
    _3 = &amp;mut _1;
    _2 = const &lt;std::vec::Vec&lt;T&gt;&gt;::push(move _3, const 1i32) -&gt; [return: bb3, unwind: bb4];
}
</code></pre>
<p>Here there are two statements: another <code>StorageLive</code>, introducing the <code>_3</code>
temporary, and then an assignment:</p>
<pre><code class="language-mir">_3 = &amp;mut _1;
</code></pre>
<p>Assignments in general have the form:</p>
<pre><code class="language-text">&lt;Place&gt; = &lt;Rvalue&gt;
</code></pre>
<p>A place is an expression like <code>_3</code>, <code>_3.f</code> or <code>*_3</code> – it denotes a
location in memory.  An <strong>Rvalue</strong> is an expression that creates a
value: in this case, the rvalue is a mutable borrow expression, which
looks like <code>&amp;mut &lt;Place&gt;</code>. So we can kind of define a grammar for
rvalues like so:</p>
<pre><code class="language-text">&lt;Rvalue&gt;  = &amp; (mut)? &lt;Place&gt;
          | &lt;Operand&gt; + &lt;Operand&gt;
          | &lt;Operand&gt; - &lt;Operand&gt;
          | ...

&lt;Operand&gt; = Constant
          | copy Place
          | move Place
</code></pre>
<p>As you can see from this grammar, rvalues cannot be nested – they can
only reference places and constants. Moreover, when you use a place,
we indicate whether we are <strong>copying it</strong> (which requires that the
place have a type <code>T</code> where <code>T: Copy</code>) or <strong>moving it</strong> (which works
for a place of any type). So, for example, if we had the expression <code>x = a + b + c</code> in Rust, that would get compiled to two statements and a
temporary:</p>
<pre><code class="language-mir">TMP1 = a + b
x = TMP1 + c
</code></pre>
<p>(<a href="https://play.rust-lang.org/?gist=1751196d63b2a71f8208119e59d8a5b6&amp;version=stable">Try it and see</a>, though you may want to do release mode to skip
over the overflow checks.)</p>
<h2><a class="header" href="#mir-data-types-1" id="mir-data-types-1">MIR data types</a></h2>
<p>The MIR data types are defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_middle/mir"><code>src/librustc_middle/mir/</code></a>
module.  Each of the key concepts mentioned in the previous section
maps in a fairly straightforward way to a Rust type.</p>
<p>The main MIR data type is <code>Mir</code>. It contains the data for a single
function (along with sub-instances of Mir for &quot;promoted constants&quot;,
but <a href="mir/index.html#promoted">you can read about those below</a>).</p>
<ul>
<li><strong>Basic blocks</strong>: The basic blocks are stored in the field
<code>basic_blocks</code>; this is a vector of <code>BasicBlockData</code>
structures. Nobody ever references a basic block directly: instead,
we pass around <code>BasicBlock</code> values, which are
<a href="mir/../appendix/glossary.html#newtype">newtype'd</a> indices into this vector.</li>
<li><strong>Statements</strong> are represented by the type <code>Statement</code>.</li>
<li><strong>Terminators</strong> are represented by the <code>Terminator</code>.</li>
<li><strong>Locals</strong> are represented by a <a href="mir/../appendix/glossary.html#newtype">newtype'd</a> index type <code>Local</code>. The
data for a local variable is found in the <code>Mir</code> (the <code>local_decls</code>
vector). There is also a special constant <code>RETURN_PLACE</code> identifying
the special &quot;local&quot; representing the return value.</li>
<li><strong>Places</strong> are identified by the enum <code>Place</code>. There are a few variants:
<ul>
<li>Local variables like <code>_1</code></li>
<li>Static variables <code>FOO</code></li>
<li><strong>Projections</strong>, which are fields or other things that &quot;project
out&quot; from a base place. So e.g. the place <code>_1.f</code> is a projection,
with <code>f</code> being the &quot;projection element and <code>_1</code> being the base
path. <code>*_1</code> is also a projection, with the <code>*</code> being represented
by the <code>ProjectionElem::Deref</code> element.</li>
</ul>
</li>
<li><strong>Rvalues</strong> are represented by the enum <code>Rvalue</code>.</li>
<li><strong>Operands</strong> are represented by the enum <code>Operand</code>.</li>
</ul>
<h2><a class="header" href="#representing-constants-1" id="representing-constants-1">Representing constants</a></h2>
<p><em>to be written</em></p>
<p><a name="promoted"></a></p>
<h3><a class="header" href="#promoted-constants-1" id="promoted-constants-1">Promoted constants</a></h3>
<p><em>to be written</em></p>
<h1><a class="header" href="#mir-optimizations" id="mir-optimizations">MIR optimizations</a></h1>
<p>MIR optimizations are optimizations run on the <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">MIR</a> to produce better MIR
before codegen. This is important for two reasons: first, it makes the final
generated executable code better, and second, it means that LLVM has less work
to do, so compilation is faster. Note that since MIR is generic (not
<a href="https://rustc-dev-guide.rust-lang.org/appendix/glossary.html#mono">monomorphized</a> yet), these optimizations are particularly
effective; we can optimize the generic version, so all of the monomorphizations
are cheaper!</p>
<p>MIR optimizations run after borrow checking. We run a series of optimization
passes over the MIR to improve it. Some passes are required to run on all code,
some passes don't actually do optimizations but only check stuff, and some
passes are only turned on in <code>release</code> mode.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/fn.optimized_mir.html"><code>optimized_mir</code></a> <a href="https://rustc-dev-guide.rust-lang.org/query.html">query</a> is called to produce the optimized MIR
for a given <a href="https://rustc-dev-guide.rust-lang.org/appendix/glossary.html#def-id"><code>DefId</code></a>. This query makes sure that the borrow checker has
run and that some validation has occurred. Then, it <a href="https://rustc-dev-guide.rust-lang.org/mir/passes.html?highlight=steal#stealing">steals</a> the MIR,
optimizes it, and returns the improved MIR.</p>
<h2><a class="header" href="#defining-optimization-passes" id="defining-optimization-passes">Defining optimization passes</a></h2>
<p>The list of passes run and the order in which they are run is defined by the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/fn.run_optimization_passes.html"><code>run_optimization_passes</code></a> function. It contains an array of passes to
run.  Each pass in the array is a struct that implements the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/trait.MirPass.html"><code>MirPass</code></a> trait.
The array is an array of <code>&amp;dyn MirPass</code> trait objects. Typically, a pass is
implemented in its own submodule of the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/index.html"><code>rustc_mir::transform</code></a> module.</p>
<p>Some examples of passes are:</p>
<ul>
<li><code>CleanupNonCodegenStatements</code>: remove some of the info that is only needed for
analyses, rather than codegen.</li>
<li><code>ConstProp</code>: Does <a href="https://en.wikipedia.org/wiki/Constant_folding#Constant_propagation">constant propagation</a></li>
</ul>
<p>You can see the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/trait.MirPass.html#implementors">&quot;Implementors&quot; section of the <code>MirPass</code> rustdocs</a> for more examples.</p>
<h1><a class="header" href="#mir-debugging" id="mir-debugging">MIR Debugging</a></h1>
<p>The <code>-Zdump-mir</code> flag can be used to dump a text representation of the MIR. The
<code>-Zdump-mir-graphviz</code> flag can be used to dump a <code>.dot</code> file that represents
MIR as a control-flow graph.</p>
<p><code>-Zdump-mir=F</code> is a handy compiler options that will let you view the MIR for
each function at each stage of compilation. <code>-Zdump-mir</code> takes a <strong>filter</strong> <code>F</code>
which allows you to control which functions and which passes you are
interesting in. For example:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir=foo ...
</code></pre>
<p>This will dump the MIR for any function whose name contains <code>foo</code>; it
will dump the MIR both before and after every pass. Those files will
be created in the <code>mir_dump</code> directory. There will likely be quite a
lot of them!</p>
<pre><code class="language-bash">&gt; cat &gt; foo.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
^D
&gt; rustc -Zdump-mir=main foo.rs
&gt; ls mir_dump/* | wc -l
     161
</code></pre>
<p>The files have names like <code>rustc.main.000-000.CleanEndRegions.after.mir</code>. These
names have a number of parts:</p>
<pre><code class="language-text">rustc.main.000-000.CleanEndRegions.after.mir
      ---- --- --- --------------- ----- either before or after
      |    |   |   name of the pass
      |    |   index of dump within the pass (usually 0, but some passes dump intermediate states)
      |    index of the pass
      def-path to the function etc being dumped
</code></pre>
<p>You can also make more selective filters. For example, <code>main &amp; CleanEndRegions</code>
will select for things that reference <em>both</em> <code>main</code> and the pass
<code>CleanEndRegions</code>:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir='main &amp; CleanEndRegions' foo.rs
&gt; ls mir_dump
rustc.main.000-000.CleanEndRegions.after.mir	rustc.main.000-000.CleanEndRegions.before.mir
</code></pre>
<p>Filters can also have <code>|</code> parts to combine multiple sets of
<code>&amp;</code>-filters. For example <code>main &amp; CleanEndRegions | main &amp; NoLandingPads</code> will select <em>either</em> <code>main</code> and <code>CleanEndRegions</code> <em>or</em>
<code>main</code> and <code>NoLandingPads</code>:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir='main &amp; CleanEndRegions | main &amp; NoLandingPads' foo.rs
&gt; ls mir_dump
rustc.main-promoted[0].002-000.NoLandingPads.after.mir
rustc.main-promoted[0].002-000.NoLandingPads.before.mir
rustc.main-promoted[0].002-006.NoLandingPads.after.mir
rustc.main-promoted[0].002-006.NoLandingPads.before.mir
rustc.main-promoted[1].002-000.NoLandingPads.after.mir
rustc.main-promoted[1].002-000.NoLandingPads.before.mir
rustc.main-promoted[1].002-006.NoLandingPads.after.mir
rustc.main-promoted[1].002-006.NoLandingPads.before.mir
rustc.main.000-000.CleanEndRegions.after.mir
rustc.main.000-000.CleanEndRegions.before.mir
rustc.main.002-000.NoLandingPads.after.mir
rustc.main.002-000.NoLandingPads.before.mir
rustc.main.002-006.NoLandingPads.after.mir
rustc.main.002-006.NoLandingPads.before.mir
</code></pre>
<p>(Here, the <code>main-promoted[0]</code> files refer to the MIR for &quot;promoted constants&quot;
that appeared within the <code>main</code> function.)</p>
<p>TODO: anything else?</p>
<h1><a class="header" href="#constant-evaluation" id="constant-evaluation">Constant Evaluation</a></h1>
<p>Constant evaluation is the process of computing values at compile time. For a
specific item (constant/static/array length) this happens after the MIR for the
item is borrow-checked and optimized. In many cases trying to const evaluate an
item will trigger the computation of its MIR for the first time.</p>
<p>Prominent examples are</p>
<ul>
<li>The initializer of a <code>static</code></li>
<li>Array length
<ul>
<li>needs to be known to reserve stack or heap space</li>
</ul>
</li>
<li>Enum variant discriminants
<ul>
<li>needs to be known to prevent two variants from having the same
discriminant</li>
</ul>
</li>
<li>Patterns
<ul>
<li>need to be known to check for overlapping patterns</li>
</ul>
</li>
</ul>
<p>Additionally constant evaluation can be used to reduce the workload or binary
size at runtime by precomputing complex operations at compiletime and only
storing the result.</p>
<p>Constant evaluation can be done by calling the <code>const_eval</code> query of <code>TyCtxt</code>.</p>
<p>The <code>const_eval</code> query takes a <a href="./param_env.html"><code>ParamEnv</code></a> of environment in
which the constant is evaluated (e.g. the function within which the constant is
used) and a <code>GlobalId</code>. The <code>GlobalId</code> is made up of an
<code>Instance</code> referring to a constant or static or of an
<code>Instance</code> of a function and an index into the function's <code>Promoted</code> table.</p>
<p>Constant evaluation returns a <code>Result</code> with either the error, or the simplest
representation of the constant. &quot;simplest&quot; meaning if it is representable as an
integer or fat pointer, it will directly yield the value (via <code>ConstValue::Scalar</code> or
<code>ConstValue::ScalarPair</code>), instead of referring to the <a href="./miri.html"><code>miri</code></a> virtual
memory allocation (via <code>ConstValue::ByRef</code>). This means that the <code>const_eval</code>
function cannot be used to create miri-pointers to the evaluated constant or
static. If you need that, you need to directly work with the functions in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/const_eval/index.html">src/librustc_mir/const_eval.rs</a>.</p>
<h1><a class="header" href="#miri" id="miri">Miri</a></h1>
<p>Miri (<strong>MIR</strong> <strong>I</strong>nterpreter) is a virtual machine for executing MIR without
compiling to machine code. It is usually invoked via <code>tcx.const_eval</code>.</p>
<p>If you start out with a constant</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const FOO: usize = 1 &lt;&lt; 12;
<span class="boring">}
</span></code></pre></pre>
<p>rustc doesn't actually invoke anything until the constant is either used or
placed into metadata.</p>
<p>Once you have a use-site like</p>
<pre><code class="language-rust ignore">type Foo = [u8; FOO - 42];
</code></pre>
<p>The compiler needs to figure out the length of the array before being able to
create items that use the type (locals, constants, function arguments, ...).</p>
<p>To obtain the (in this case empty) parameter environment, one can call
<code>let param_env = tcx.param_env(length_def_id);</code>. The <code>GlobalId</code> needed is</p>
<pre><code class="language-rust ignore">let gid = GlobalId {
    promoted: None,
    instance: Instance::mono(length_def_id),
};
</code></pre>
<p>Invoking <code>tcx.const_eval(param_env.and(gid))</code> will now trigger the creation of
the MIR of the array length expression. The MIR will look something like this:</p>
<pre><code class="language-mir">const Foo::{{initializer}}: usize = {
    let mut _0: usize;                   // return pointer
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const Unevaluated(FOO, Slice([])), const 42usize);
        assert(!(_1.1: bool), &quot;attempt to subtract with overflow&quot;) -&gt; bb1;
    }

    bb1: {
        _0 = (_1.0: usize);
        return;
    }
}
</code></pre>
<p>Before the evaluation, a virtual memory location (in this case essentially a
<code>vec![u8; 4]</code> or <code>vec![u8; 8]</code>) is created for storing the evaluation result.</p>
<p>At the start of the evaluation, <code>_0</code> and <code>_1</code> are
<code>Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Undef))</code>.  This is quite
a mouthful: <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/enum.Operand.html"><code>Operand</code></a> can represent either data stored somewhere in the
<a href="miri.html#memory">interpreter memory</a> (<code>Operand::Indirect</code>), or (as an optimization)
immediate data stored in-line.  And <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/enum.Immediate.html"><code>Immediate</code></a> can either be a single
(potentially uninitialized) <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/enum.Scalar.html">scalar value</a> (integer or thin pointer),
or a pair of two of them.  In our case, the single scalar value is <em>not</em> (yet)
initialized.</p>
<p>When the initialization of <code>_1</code> is invoked, the value of the <code>FOO</code> constant is
required, and triggers another call to <code>tcx.const_eval</code>, which will not be shown
here. If the evaluation of FOO is successful, <code>42</code> will be subtracted from its
value <code>4096</code> and the result stored in <code>_1</code> as
<code>Operand::Immediate(Immediate::ScalarPair(Scalar::Raw { data: 4054, .. }, Scalar::Raw { data: 0, .. })</code>. The first part of the pair is the computed value,
the second part is a bool that's true if an overflow happened. A <code>Scalar::Raw</code>
also stores the size (in bytes) of this scalar value; we are eliding that here.</p>
<p>The next statement asserts that said boolean is <code>0</code>. In case the assertion
fails, its error message is used for reporting a compile-time error.</p>
<p>Since it does not fail, <code>Operand::Immediate(Immediate::Scalar(Scalar::Raw { data: 4054, .. }))</code> is stored in the virtual memory was allocated before the
evaluation. <code>_0</code> always refers to that location directly.</p>
<p>After the evaluation is done, the return value is converted from <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/enum.Operand.html"><code>Operand</code></a> to
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/enum.ConstValue.html"><code>ConstValue</code></a> by <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/const_eval/eval_queries/fn.op_to_const.html"><code>op_to_const</code></a>: the former representation is geared towards
what is needed <em>during</em> cost evaluation, while <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/enum.ConstValue.html"><code>ConstValue</code></a> is shaped by the
needs of the remaining parts of the compiler that consume the results of const
evaluation.  As part of this conversion, for types with scalar values, even if
the resulting <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/enum.Operand.html"><code>Operand</code></a> is <code>Indirect</code>, it will return an immediate
<code>ConstValue::Scalar(computed_value)</code> (instead of the usual <code>ConstValue::ByRef</code>).
This makes using the result much more efficient and also more convenient, as no
further queries need to be executed in order to get at something as simple as a
<code>usize</code>.</p>
<p>Future evaluations of the same constants will not actually invoke
Miri, but just use the cached result.</p>
<h2><a class="header" href="#datastructures" id="datastructures">Datastructures</a></h2>
<p>Miri's outside-facing datastructures can be found in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_middle/mir/interpret">librustc_middle/mir/interpret</a>.
This is mainly the error enum and the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/enum.ConstValue.html"><code>ConstValue</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/enum.Scalar.html"><code>Scalar</code></a> types. A
<code>ConstValue</code> can be either <code>Scalar</code> (a single <code>Scalar</code>, i.e., integer or thin
pointer), <code>Slice</code> (to represent byte slices and strings, as needed for pattern
matching) or <code>ByRef</code>, which is used for anything else and refers to a virtual
allocation. These allocations can be accessed via the methods on
<code>tcx.interpret_interner</code>.  A <code>Scalar</code> is either some <code>Raw</code> integer or a pointer;
see <a href="miri.html#memory">the next section</a> for more on that.</p>
<p>If you are expecting a numeric result, you can use <code>eval_usize</code> (panics on
anything that can't be representad as a <code>u64</code>) or <code>try_eval_usize</code> which results
in an <code>Option&lt;u64&gt;</code> yielding the <code>Scalar</code> if possible.</p>
<h2><a class="header" href="#memory" id="memory">Memory</a></h2>
<p>To support any kind of pointers, Miri needs to have a &quot;virtual memory&quot; that the
pointers can point to.  This is implemented in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/struct.Memory.html"><code>Memory</code></a> type.  In the
simplest model, every global variable, stack variable and every dynamic
allocation corresponds to an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/struct.Allocation.html"><code>Allocation</code></a> in that memory.  (Actually using an
allocation for every MIR stack variable would be very inefficient; that's why we
have <code>Operand::Immediate</code> for stack variables that are both small and never have
their address taken.  But that is purely an optimization.)</p>
<p>Such an <code>Allocation</code> is basically just a sequence of <code>u8</code> storing the value of
each byte in this allocation.  (Plus some extra data, see below.)  Every
<code>Allocation</code> has a globally unique <code>AllocId</code> assigned in <code>Memory</code>.  With that, a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/struct.Pointer.html"><code>Pointer</code></a> consists of a pair of an <code>AllocId</code> (indicating the allocation) and
an offset into the allocation (indicating which byte of the allocation the
pointer points to).  It may seem odd that a <code>Pointer</code> is not just an integer
address, but remember that during const evaluation, we cannot know at which
actual integer address the allocation will end up -- so we use <code>AllocId</code> as
symbolic base addresses, which means we need a separate offset.  (As an aside,
it turns out that pointers at run-time are
<a href="https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#pointer-provenance">more than just integers, too</a>.)</p>
<p>These allocations exist so that references and raw pointers have something to
point to. There is no global linear heap in which things are allocated, but each
allocation (be it for a local variable, a static or a (future) heap allocation)
gets its own little memory with exactly the required size. So if you have a
pointer to an allocation for a local variable <code>a</code>, there is no possible (no
matter how unsafe) operation that you can do that would ever change said pointer
to a pointer to a different local variable <code>b</code>.
Pointer arithmetic on <code>a</code> will only ever change its offset; the <code>AllocId</code> stays the same.</p>
<p>This, however, causes a problem when we want to store a <code>Pointer</code> into an
<code>Allocation</code>: we cannot turn it into a sequence of <code>u8</code> of the right length!
<code>AllocId</code> and offset together are twice as big as a pointer &quot;seems&quot; to be.  This
is what the <code>relocation</code> field of <code>Allocation</code> is for: the byte offset of the
<code>Pointer</code> gets stored as a bunch of <code>u8</code>, while its <code>AllocId</code> gets stored
out-of-band.  The two are reassembled when the <code>Pointer</code> is read from memory.
The other bit of extra data an <code>Allocation</code> needs is <code>undef_mask</code> for keeping
track of which of its bytes are initialized.</p>
<h3><a class="header" href="#global-memory-and-exotic-allocations" id="global-memory-and-exotic-allocations">Global memory and exotic allocations</a></h3>
<p><code>Memory</code> exists only during the Miri evaluation; it gets destroyed when the
final value of the constant is computed.  In case that constant contains any
pointers, those get &quot;interned&quot; and moved to a global &quot;const eval memory&quot; that is
part of <code>TyCtxt</code>.  These allocations stay around for the remaining computation
and get serialized into the final output (so that dependent crates can use
them).</p>
<p>Moreover, to also support function pointers, the global memory in <code>TyCtxt</code> can
also contain &quot;virtual allocations&quot;: instead of an <code>Allocation</code>, these contain an
<code>Instance</code>.  That allows a <code>Pointer</code> to point to either normal data or a
function, which is needed to be able to evaluate casts from function pointers to
raw pointers.</p>
<p>Finally, the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/enum.GlobalAlloc.html"><code>GlobalAlloc</code></a> type used in the global memory also contains a
variant <code>Static</code> that points to a particular <code>const</code> or <code>static</code> item.  This is
needed to support circular statics, where we need to have a <code>Pointer</code> to a
<code>static</code> for which we cannot yet have an <code>Allocation</code> as we do not know the
bytes of its value.</p>
<h3><a class="header" href="#pointer-values-vs-pointer-types" id="pointer-values-vs-pointer-types">Pointer values vs Pointer types</a></h3>
<p>One common cause of confusion in Miri is that being a pointer <em>value</em> and having
a pointer <em>type</em> are entirely independent properties.  By &quot;pointer value&quot;, we
refer to a <code>Scalar::Ptr</code> containing a <code>Pointer</code> and thus pointing somewhere into
Miri's virtual memory.  This is in contrast to <code>Scalar::Raw</code>, which is just some
concrete integer.</p>
<p>However, a variable of pointer or reference <em>type</em>, such as <code>*const T</code> or <code>&amp;T</code>,
does not have to have a pointer <em>value</em>: it could be obtaining by casting or
transmuting an integer to a pointer (currently that is hard to do in const eval,
but eventually <code>transmute</code> will be stable as a <code>const fn</code>).  And similarly, when
casting or transmuting a reference to some actual allocation to an integer, we
end up with a pointer <em>value</em> (<code>Scalar::Ptr</code>) at integer <em>type</em> (<code>usize</code>).  This
is a problem because we cannot meaningfully perform integer operations such as
division on pointer values.</p>
<h2><a class="header" href="#interpretation" id="interpretation">Interpretation</a></h2>
<p>Although the main entry point to constant evaluation is the <code>tcx.const_eval</code>
query, there are additional functions in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/const_eval/index.html">librustc_mir/const_eval.rs</a>
that allow accessing the fields of a <code>ConstValue</code> (<code>ByRef</code> or otherwise). You should
never have to access an <code>Allocation</code> directly except for translating it to the
compilation target (at the moment just LLVM).</p>
<p>Miri starts by creating a virtual stack frame for the current constant that is
being evaluated. There's essentially no difference between a constant and a
function with no arguments, except that constants do not allow local (named)
variables at the time of writing this guide.</p>
<p>A stack frame is defined by the <code>Frame</code> type in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/eval_context.rs">librustc_mir/interpret/eval_context.rs</a>
and contains all the local
variables memory (<code>None</code> at the start of evaluation). Each frame refers to the
evaluation of either the root constant or subsequent calls to <code>const fn</code>. The
evaluation of another constant simply calls <code>tcx.const_eval</code>, which produces an
entirely new and independent stack frame.</p>
<p>The frames are just a <code>Vec&lt;Frame&gt;</code>, there's no way to actually refer to a
<code>Frame</code>'s memory even if horrible shenanigans are done via unsafe code. The only
memory that can be referred to are <code>Allocation</code>s.</p>
<p>Miri now calls the <code>step</code> method (in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/step.rs">librustc_mir/interpret/step.rs</a>
) until it either returns an error or has no further statements to execute. Each
statement will now initialize or modify the locals or the virtual memory
referred to by a local. This might require evaluating other constants or
statics, which just recursively invokes <code>tcx.const_eval</code>.</p>
<h1><a class="header" href="#monomorphization" id="monomorphization">Monomorphization</a></h1>
<p>As you probably know, rust has a very expressive type system that has extensive
support for generic types. But of course, assembly is not generic, so we need
to figure out the concrete types of all the generics before the code can
execute.</p>
<p>Different languages handle this problem differently. For example, in some
languages, such as Java, we may not know the most precise type of value until
runtime. In the case of Java, this is ok because (almost) all variables are
reference values anyway (i.e. pointers to a stack allocated object). This
flexibility comes at the cost of performance, since all accesses to an object
must dereference a pointer.</p>
<p>Rust takes a different approach: it <em>monomorphizes</em> all generic types. This
means that compiler stamps out a different copy of the code of a generic
function for each concrete type needed. For example, if I use a <code>Vec&lt;u64&gt;</code> and
a <code>Vec&lt;String&gt;</code> in my code, then the generated binary will have two copies of
the generated code for <code>Vec</code>: one for <code>Vec&lt;u64&gt;</code> and another for <code>Vec&lt;String&gt;</code>.
The result is fast programs, but it comes at the cost of compile time (creating
all those copies can take a while) and binary size (all those copies might take
a lot of space).</p>
<p>Monomorphization is the first step in the backend of the rust compiler.</p>
<h2><a class="header" href="#collection" id="collection">Collection</a></h2>
<p>First, we need to figure out what concrete types we need for all the generic
things in our program. This is called <em>collection</em>, and the code that does this
is called the <em>monomorphization collector</em>.</p>
<p>Take this example:</p>
<pre><pre class="playpen"><code class="language-rust">fn banana() {
   peach::&lt;u64&gt;();
}

fn main() {
    banana();
}
</code></pre></pre>
<p>The monomorphization collector will give you a list of <code>[main, banana, peach::&lt;u64&gt;]</code>. These are the functions that will have machine code generated
for them. Collector will also add things like statics to that list.</p>
<p>See <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/monomorphize/collector/index.html">the collector rustdocs</a> for more info.</p>
<p>The monomorphization collector is run just before MIR lowering and codegen.
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_crate.html"><code>rustc_codegen_ssa::base::codegen_crate</code></a> calls the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/monomorphize/partitioning/fn.collect_and_partition_mono_items.html"><code>collect_and_partition_mono_items</code></a> query, which does monomorphization
collection and then partitions them into <a href="backend/../appendix/glossary.html#codegen-unit">codegen
units</a>.</p>
<h2><a class="header" href="#polymorphization" id="polymorphization">Polymorphization</a></h2>
<p>As mentioned above, monomorphization produces fast code, but it comes at the
cost of compile time and binary size. <a href="backend/../mir/optimizations.html">MIR
optimizations</a> can help a bit with this. Another
optimization currently under development is called <em>polymorphization</em>.</p>
<p>The general idea is that often we can share some code between monomorphized
copies of code. More precisely, if a MIR block is not dependent on a type
parameter, it may not need to be monomorphized into many copies. Consider the
following example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn f() {
    g::&lt;bool&gt;();
    g::&lt;usize&gt;();
}

fn g&lt;T&gt;() -&gt; usize {
    let n = 1;
    let closure = || n;
    closure()
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, we would currently collect <code>[f, g::&lt;bool&gt;, g::&lt;usize&gt;, g::&lt;bool&gt;::{{closure}}, g::&lt;usize&gt;::{{closure}}]</code>, but notice that the two
closures would be identical -- they don't depend on the type parameter <code>T</code> of
function <code>g</code>. So we only need to emit one copy of the closure.</p>
<p>For more information, see <a href="https://github.com/rust-lang/rust/issues/46477">this thread on github</a>.</p>
<h1><a class="header" href="#lowering-mir-to-a-codegen-ir" id="lowering-mir-to-a-codegen-ir">Lowering MIR to a Codegen IR</a></h1>
<p>Now that we have a list of symbols to generate from the collector, we need to
generate some sort of codegen IR. In this chapter, we will assume LLVM IR,
since that's what rustc usually uses. The actual monomorphization is performed
as we go, while we do the translation.</p>
<p>Recall that the backend is started by
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_crate.html"><code>rustc_codegen_ssa::base::codegen_crate</code></a>. Eventually, this reaches
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/fn.codegen_mir.html"><code>rustc_codegen_ssa::mir::codegen_mir</code></a>, which does the lowering from
MIR to LLVM IR.</p>
<p>The code is split into modules which handle particular MIR primitives:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/block/index.html"><code>librustc_codegen_ssa::mir::block</code></a> will deal with translating
blocks and their terminators.  The most complicated and also the most
interesting thing this module does is generating code for function calls,
including the necessary unwinding handling IR.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/statement/index.html"><code>librustc_codegen_ssa::mir::statement</code></a> translates MIR statements.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/operand/index.html"><code>librustc_codegen_ssa::mir::operand</code></a> translates MIR operands.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/place/index.html"><code>librustc_codegen_ssa::mir::place</code></a> translates MIR place references.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/rvalue/index.html"><code>librustc_codegen_ssa::mir::rvalue</code></a> translates MIR r-values.</li>
</ul>
<p>Before a function is translated a number of simple and primitive analysis
passes will run to help us generate simpler and more efficient LLVM IR. An
example of such an analysis pass would be figuring out which variables are
SSA-like, so that we can translate them to SSA directly rather than relying on
LLVM's <code>mem2reg</code> for those variables. The analysis can be found in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/analyze/index.html"><code>rustc_codegen_ssa::mir::analyze</code></a>.</p>
<p>Usually a single MIR basic block will map to a LLVM basic block, with very few
exceptions: intrinsic or function calls and less basic MIR statements like
<code>assert</code> can result in multiple basic blocks. This is a perfect lede into the
non-portable LLVM-specific part of the code generation. Intrinsic generation is
fairly easy to understand as it involves very few abstraction levels in between
and can be found in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/intrinsic/index.html"><code>rustc_codegen_llvm::intrinsic</code></a>.</p>
<p>Everything else will use the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/builder/index.html">builder interface</a>. This is the code that gets
called in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/index.html"><code>librustc_codegen_ssa::mir::*</code></a> modules discussed above.</p>
<blockquote>
<p>TODO: discuss how constants are generated</p>
</blockquote>
<h1><a class="header" href="#code-generation" id="code-generation">Code generation</a></h1>
<p>Code generation or &quot;codegen&quot; is the part of the compiler that actually
generates an executable binary. Usually, rustc uses LLVM for code generation;
there is also support for <a href="https://github.com/bytecodealliance/wasmtime/tree/master/cranelift">Cranelift</a>. The key is that rustc doesn't implement
codegen itself. It's worth noting, though, that in the rust source code, many
parts of the backend have <code>codegen</code> in their names (there are no hard
boundaries).</p>
<blockquote>
<p>NOTE: If you are looking for hints on how to debug code generation bugs,
please see <a href="backend/./debugging.html">this section of the debugging chapter</a>.</p>
</blockquote>
<h2><a class="header" href="#what-is-llvm" id="what-is-llvm">What is LLVM?</a></h2>
<p><a href="https://llvm.org">LLVM</a> is &quot;a collection of modular and reusable compiler and
toolchain technologies&quot;. In particular, the LLVM project contains a pluggable
compiler backend (also called &quot;LLVM&quot;), which is used by many compiler projects,
including the <code>clang</code> C compiler and our beloved <code>rustc</code>.</p>
<p>LLVM takes input in the form of LLVM IR. It is basically assembly code with
additional low-level types and annotations added. These annotations are helpful
for doing optimizations on the LLVM IR and outputted machine code. The end
result of all this is (at long last) something executable (e.g. an ELF object,
an EXE, or wasm).</p>
<p>There are a few benefits to using LLVM:</p>
<ul>
<li>We don't have to write a whole compiler backend. This reduces implementation
and maintenance burden.</li>
<li>We benefit from the large suite of advanced optimizations that the LLVM
project has been collecting.</li>
<li>We can automatically compile Rust to any of the platforms for which LLVM has
support. For example, as soon as LLVM added support for wasm, voila! rustc,
clang, and a bunch of other languages were able to compile to wasm! (Well,
there was some extra stuff to be done, but we were 90% there anyway).</li>
<li>We and other compiler projects benefit from each other. For example, when the
<a href="https://meltdownattack.com/">Spectre and Meltdown security vulnerabilities</a> were discovered,
only LLVM needed to be patched.</li>
</ul>
<h2><a class="header" href="#running-llvm-linking-and-metadata-generation" id="running-llvm-linking-and-metadata-generation">Running LLVM, linking, and metadata generation</a></h2>
<p>Once LLVM IR for all of the functions and statics, etc is built, it is time to
start running LLVM and its optimization passes. LLVM IR is grouped into
&quot;modules&quot;. Multiple &quot;modules&quot; can be codegened at the same time to aid in
multi-core utilization. These &quot;modules&quot; are what we refer to as <em>codegen
units</em>. These units were established way back during monomorphization
collection phase.</p>
<p>Once LLVM produces objects from these modules, these objects are passed to the
linker along with, optionally, the metadata object and an archive or an
executable is produced.</p>
<p>It is not necessarily the codegen phase described above that runs the
optimizations. With certain kinds of LTO, the optimization might happen at the
linking time instead. It is also possible for some optimizations to happen
before objects are passed on to the linker and some to happen during the
linking.</p>
<p>This all happens towards the very end of compilation. The code for this can be
found in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/back/index.html"><code>librustc_codegen_ssa::back</code></a> and
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/back/index.html"><code>librustc_codegen_llvm::back</code></a>. Sadly, this piece of code is not
really well-separated into LLVM-dependent code; the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/index.html"><code>rustc_codegen_ssa</code></a>
contains a fair amount of code specific to the LLVM backend.</p>
<p>Once these components are done with their work you end up with a number of
files in your filesystem corresponding to the outputs you have requested.</p>
<h1><a class="header" href="#updating-llvm" id="updating-llvm">Updating LLVM</a></h1>
<p>The Rust compiler uses LLVM as its primary codegen backend today, and naturally
we want to at least occasionally update this dependency! Currently we do not
have a strict policy about when to update LLVM or what it can be updated to, but
a few guidelines are applied:</p>
<ul>
<li>We try to always support the latest released version of LLVM</li>
<li>We try to support the &quot;last few&quot; versions of LLVM (how many is changing over
time)</li>
<li>We allow moving to arbitrary commits during development.</li>
<li>Strongly prefer to upstream all patches to LLVM before including them in
rustc.</li>
</ul>
<p>This policy may change over time (or may actually start to exist as a formal
policy!), but for now these are rough guidelines!</p>
<h2><a class="header" href="#why-update-llvm" id="why-update-llvm">Why update LLVM?</a></h2>
<p>There are a few reasons nowadays that we want to update LLVM in one way or
another:</p>
<ul>
<li>
<p>A bug could have been fixed! Often we find bugs in the compiler and fix
them upstream in LLVM. We'll want to pull fixes back to the compiler itself as
they're merged upstream.</p>
</li>
<li>
<p>A new feature may be available in LLVM that we want to use in rustc,
but we don't want to wait for a full LLVM release to test it out.</p>
</li>
<li>
<p>LLVM itself may have a new release and we'd like to update to this LLVM
release.</p>
</li>
</ul>
<p>Each of these reasons has a different strategy for updating LLVM, and we'll go
over them in detail here.</p>
<h2><a class="header" href="#bugfix-updates" id="bugfix-updates">Bugfix Updates</a></h2>
<p>For updates of LLVM that are to fix a small bug, we cherry-pick the bugfix to
the branch we're already using. The steps for this are:</p>
<ol>
<li>Make sure the bugfix is in upstream LLVM.</li>
<li>Identify the branch that rustc is currently using. The <code>src/llvm-project</code>
submodule is always pinned to a branch of the
<a href="https://github.com/rust-lang/llvm-project">rust-lang/llvm-project</a> repository.</li>
<li>Fork the rust-lang/llvm-project repository</li>
<li>Check out the appropriate branch (typically named <code>rustc/a.b-yyyy-mm-dd</code>)</li>
<li>Cherry-pick the upstream commit onto the branch</li>
<li>Push this branch to your fork</li>
<li>Send a Pull Request to rust-lang/llvm-project to the same branch as before.
Be sure to reference the Rust and/or LLVM issue that you're fixing in the PR
description.</li>
<li>Wait for the PR to be merged</li>
<li>Send a PR to rust-lang/rust updating the <code>src/llvm-project</code> submodule with
your bugfix. This can be done locally with <code>git submodule update --remote src/llvm-project</code> typically.</li>
<li>Wait for PR to be merged</li>
</ol>
<p>The tl;dr; is that we can cherry-pick bugfixes at any time and pull them back
into the rust-lang/llvm-project branch that we're using, and getting it into the
compiler is just updating the submodule via a PR!</p>
<p>Example PRs look like:
<a href="https://github.com/rust-lang/rust/pull/59089">#59089</a></p>
<h2><a class="header" href="#feature-updates" id="feature-updates">Feature updates</a></h2>
<blockquote>
<p>Note that this is all information as applies to the current day in age. This
process for updating LLVM changes with practically all LLVM updates, so this
may be out of date!</p>
</blockquote>
<p>Unlike bugfixes, updating to pick up a new feature of LLVM typically requires a
lot more work. This is where we can't reasonably cherry-pick commits backwards
so we need to do a full update. There's a lot of stuff to do here, so let's go
through each in detail.</p>
<ol>
<li>
<p>Create a new branch in the rust-lang/llvm-project repository. This branch
should be named <code>rustc/a.b-yyyy-mm-dd</code> where <code>a.b</code> is the current version
number of LLVM in-tree at the time of the branch and the remaining part is
today's date. Move this branch to the commit in LLVM that you'd like, which
for this is probably the current LLVM HEAD.</p>
</li>
<li>
<p>Apply Rust-specific patches to the llvm-project repository. All features and
bugfixes are upstream, but there's often some weird build-related patches
that don't make sense to upstream which we have on our repositories. These
patches are around the latest patches in the rust-lang/llvm-project branch
that rustc is currently using.</p>
</li>
<li>
<p>Build the new LLVM in the <code>rust</code> repository. To do this you'll want to update
the <code>src/llvm-project</code> repository to your branch and the revision you've
created. It's also typically a good idea to update <code>.gitmodules</code> with the new
branch name of the LLVM submodule. Make sure you've committed changes to
<code>src/llvm-project</code> to ensure submodule updates aren't reverted. Some commands
you should execute are:</p>
<ul>
<li><code>./x.py build src/llvm</code> - test that LLVM still builds</li>
<li><code>./x.py build src/tools/lld</code> - same for LLD</li>
<li><code>./x.py build</code> - build the rest of rustc</li>
</ul>
<p>You'll likely need to update <code>src/rustllvm/*.cpp</code> to compile with updated
LLVM bindings. Note that you should use <code>#ifdef</code> and such to ensure that the
bindings still compile on older LLVM versions.</p>
</li>
<li>
<p>Test for regressions across other platforms. LLVM often has at least one bug
for non-tier-1 architectures, so it's good to do some more testing before
sending this to bors! If you're low on resources you can send the PR as-is
now to bors, though, and it'll get tested anyway.</p>
<p>Ideally, build LLVM and test it on a few platforms:</p>
<ul>
<li>Linux</li>
<li>OSX</li>
<li>Windows</li>
</ul>
<p>and afterwards run some docker containers that CI also does:</p>
<ul>
<li><code>./src/ci/docker/run.sh wasm32-unknown</code></li>
<li><code>./src/ci/docker/run.sh arm-android</code></li>
<li><code>./src/ci/docker/run.sh dist-various-1</code></li>
<li><code>./src/ci/docker/run.sh dist-various-2</code></li>
<li><code>./src/ci/docker/run.sh armhf-gnu</code></li>
</ul>
</li>
<li>
<p>Prepare a PR to <code>rust-lang/rust</code>. Work with maintainers of
<code>rust-lang/llvm-project</code> to get your commit in a branch of that repository,
and then you can send a PR to <code>rust-lang/rust</code>. You'll change at least
<code>src/llvm-project</code> and will likely also change <code>src/rustllvm/*</code> as well.</p>
</li>
</ol>
<p>For prior art, previous LLVM updates look like
<a href="https://github.com/rust-lang/rust/pull/55835">#55835</a>
<a href="https://github.com/rust-lang/rust/pull/47828">#47828</a>
<a href="https://github.com/rust-lang/rust/pull/62474">#62474</a>
<a href="https://github.com/rust-lang/rust/pull/62592">#62592</a>. Note that sometimes it's
easiest to land <code>src/rustllvm/*</code> compatibility as a PR before actually updating
<code>src/llvm-project</code>. This way while you're working through LLVM issues others
interested in trying out the new LLVM can benefit from work you've done to
update the C++ bindings.</p>
<h3><a class="header" href="#caveats-and-gotchas" id="caveats-and-gotchas">Caveats and gotchas</a></h3>
<p>Ideally the above instructions are pretty smooth, but here's some caveats to
keep in mind while going through them:</p>
<ul>
<li>LLVM bugs are hard to find, don't hesitate to ask for help! Bisection is
definitely your friend here (yes LLVM takes forever to build, yet bisection is
still your friend)</li>
<li>If you've got general questions, @alexcrichton can help you out.</li>
<li>Creating branches is a privileged operation on GitHub, so you'll need someone
with write access to create the branches for you most likely.</li>
</ul>
<h2><a class="header" href="#new-llvm-release-updates" id="new-llvm-release-updates">New LLVM Release Updates</a></h2>
<p>Updating to a new release of LLVM is very similar to the &quot;feature updates&quot;
section above. The release process for LLVM is often months-long though and we
like to ensure compatibility ASAP. The main tweaks to the &quot;feature updates&quot;
section above is generally around branch naming. The sequence of events
typically looks like:</p>
<ol>
<li>
<p>LLVM announces that its latest release version has branched. This will show
up as a branch in https://github.com/llvm/llvm-project typically named
<code>release/$N.x</code> where <code>$N</code> is the version of LLVM that's being released.</p>
</li>
<li>
<p>We then follow the &quot;feature updates&quot; section above to create a new branch of
LLVM in our rust-lang/llvm-project repository. This follows the same naming
convention of branches as usual, except that <code>a.b</code> is the new version. This
update is eventually landed in the rust-lang/rust repository.</p>
</li>
<li>
<p>Over the next few months, LLVM will continually push commits to its
<code>release/a.b</code> branch. Often those are bug fixes we'd like to have as well.
The merge process for that is to use <code>git merge</code> itself to merge LLVM's
<code>release/a.b</code> branch with the branch created in step 2. This is typically
done multiple times when necessary while LLVM's release branch is baking.</p>
</li>
<li>
<p>LLVM then announces the release of version <code>a.b</code>.</p>
</li>
<li>
<p>After LLVM's official release, we follow the &quot;feature update&quot; section again
to create a new branch in the rust-lang/llvm-project repository, this time
with a new date. The commit history should look much cleaner as just a few
Rust-specific commits stacked on top of stock LLVM's release branch.</p>
</li>
</ol>
<h2><a class="header" href="#debugging-llvm" id="debugging-llvm">Debugging LLVM</a></h2>
<blockquote>
<p>NOTE: If you are looking for info about code generation, please see <a href="backend/./codegen.html">this
chapter</a> instead.</p>
</blockquote>
<p>This section is about debugging compiler bugs in code generation (e.g. why the
compiler generated some piece of code or crashed in LLVM).  LLVM is a big
project on its own that probably needs to have its own debugging document (not
that I could find one). But here are some tips that are important in a rustc
context:</p>
<p>As a general rule, compilers generate lots of information from analyzing code.
Thus, a useful first step is usually to find a minimal example. One way to do
this is to</p>
<ol>
<li>
<p>create a new crate that reproduces the issue (e.g. adding whatever crate is
at fault as a dependency, and using it from there)</p>
</li>
<li>
<p>minimize the crate by removing external dependencies; that is, moving
everything relevant to the new crate</p>
</li>
<li>
<p>further minimize the issue by making the code shorter (there are tools that
help with this like <code>creduce</code>)</p>
</li>
</ol>
<p>The official compilers (including nightlies) have LLVM assertions disabled,
which means that LLVM assertion failures can show up as compiler crashes (not
ICEs but &quot;real&quot; crashes) and other sorts of weird behavior. If you are
encountering these, it is a good idea to try using a compiler with LLVM
assertions enabled - either an &quot;alt&quot; nightly or a compiler you build yourself
by setting <code>[llvm] assertions=true</code> in your config.toml - and see whether
anything turns up.</p>
<p>The rustc build process builds the LLVM tools into
<code>./build/&lt;host-triple&gt;/llvm/bin</code>. They can be called directly.</p>
<p>The default rustc compilation pipeline has multiple codegen units, which is
hard to replicate manually and means that LLVM is called multiple times in
parallel.  If you can get away with it (i.e. if it doesn't make your bug
disappear), passing <code>-C codegen-units=1</code> to rustc will make debugging easier.</p>
<p>For rustc to generate LLVM IR, you need to pass the <code>--emit=llvm-ir</code> flag. If
you are building via cargo, use the <code>RUSTFLAGS</code> environment variable (e.g.
<code>RUSTFLAGS='--emit=llvm-ir'</code>). This causes rustc to spit out LLVM IR into the
target directory.</p>
<p><code>cargo llvm-ir [options] path</code> spits out the LLVM IR for a particular function
at <code>path</code>. (<code>cargo install cargo-asm</code> installs <code>cargo asm</code> and <code>cargo llvm-ir</code>). <code>--build-type=debug</code> emits code for debug builds. There are also
other useful options. Also, debug info in LLVM IR can clutter the output a lot:
<code>RUSTFLAGS=&quot;-C debuginfo=0&quot;</code> is really useful.</p>
<p><code>RUSTFLAGS=&quot;-C save-temps&quot;</code> outputs LLVM bitcode (not the same as IR) at
different stages during compilation, which is sometimes useful. One just needs
to convert the bitcode files to <code>.ll</code> files using <code>llvm-dis</code> which should be in
the target local compilation of rustc.</p>
<p>If you want to play with the optimization pipeline, you can use the <code>opt</code> tool
from <code>./build/&lt;host-triple&gt;/llvm/bin/</code> with the LLVM IR emitted by rustc.  Note
that rustc emits different IR depending on whether <code>-O</code> is enabled, even
without LLVM's optimizations, so if you want to play with the IR rustc emits,
you should:</p>
<pre><code class="language-bash">$ rustc +local my-file.rs --emit=llvm-ir -O -C no-prepopulate-passes \
    -C codegen-units=1
$ OPT=./build/$TRIPLE/llvm/bin/opt
$ $OPT -S -O2 &lt; my-file.ll &gt; my
</code></pre>
<p>If you just want to get the LLVM IR during the LLVM pipeline, to e.g. see which
IR causes an optimization-time assertion to fail, or to see when LLVM performs
a particular optimization, you can pass the rustc flag <code>-C llvm-args=-print-after-all</code>, and possibly add <code>-C llvm-args='-filter-print-funcs=EXACT_FUNCTION_NAME</code> (e.g.  <code>-C llvm-args='-filter-print-funcs=_ZN11collections3str21_$LT$impl$u20$str$GT$\ 7replace17hbe10ea2e7c809b0bE'</code>).</p>
<p>That produces a lot of output into standard error, so you'll want to pipe that
to some file. Also, if you are using neither <code>-filter-print-funcs</code> nor <code>-C codegen-units=1</code>, then, because the multiple codegen units run in parallel, the
printouts will mix together and you won't be able to read anything.</p>
<p>If you want just the IR for a specific function (say, you want to see why it
causes an assertion or doesn't optimize correctly), you can use <code>llvm-extract</code>,
e.g.</p>
<pre><code class="language-bash">$ ./build/$TRIPLE/llvm/bin/llvm-extract \
    -func='_ZN11collections3str21_$LT$impl$u20$str$GT$7replace17hbe10ea2e7c809b0bE' \
    -S \
    &lt; unextracted.ll \
    &gt; extracted.ll
</code></pre>
<h3><a class="header" href="#getting-help-and-asking-questions" id="getting-help-and-asking-questions">Getting help and asking questions</a></h3>
<p>If you have some questions, head over to the <a href="https://rust-lang.zulipchat.com/">rust-lang Zulip</a> and
specifically the <code>#t-compiler/wg-llvm</code> stream.</p>
<h3><a class="header" href="#compiler-options-to-know-and-love" id="compiler-options-to-know-and-love">Compiler options to know and love</a></h3>
<p>The <code>-Chelp</code> and <code>-Zhelp</code> compiler switches will list out a variety
of interesting options you may find useful. Here are a few of the most
common that pertain to LLVM development (some of them are employed in the
tutorial above):</p>
<ul>
<li>The <code>--emit llvm-ir</code> option emits a <code>&lt;filename&gt;.ll</code> file with LLVM IR in textual format
<ul>
<li>The <code>--emit llvm-bc</code> option emits in bytecode format (<code>&lt;filename&gt;.bc</code>)</li>
</ul>
</li>
<li>Passing <code>-Cllvm-args=&lt;foo&gt;</code> allows passing pretty much all the
options that tools like llc and opt would accept;
e.g. <code>-Cllvm-args=-print-before-all</code> to print IR before every LLVM
pass.</li>
<li>The <code>-Cno-prepopulate-passes</code> will avoid pre-populate the LLVM pass
manager with a list of passes.  This will allow you to view the LLVM
IR that rustc generates, not the LLVM IR after optimizations.</li>
<li>The <code>-Cpasses=val</code> option allows you to supply a (space seprated) list of extra LLVM passes to run</li>
<li>The <code>-Csave-temps</code> option saves all temporary output files during compilation</li>
<li>The <code>-Zprint-llvm-passes</code> option will print out LLVM optimization passes being run</li>
<li>The <code>-Ztime-llvm-passes</code> option measures the time of each LLVM pass</li>
<li>The <code>-Zverify-llvm-ir</code> option will verify the LLVM IR for correctness</li>
<li>The <code>-Zno-parallel-llvm</code> will disable parallel compilation of distinct compilation units</li>
<li>The <code>-Zllvm-time-trace</code> option will output a Chrome profiler compatible JSON file
which contains details and timings for LLVM passes.</li>
</ul>
<h3><a class="header" href="#filing-llvm-bug-reports" id="filing-llvm-bug-reports">Filing LLVM bug reports</a></h3>
<p>When filing an LLVM bug report, you will probably want some sort of minimal
working example that demonstrates the problem. The Godbolt compiler explorer is
really helpful for this.</p>
<ol>
<li>
<p>Once you have some LLVM IR for the problematic code (see above), you can
create a minimal working example with Godbolt. Go to
<a href="https://gcc.godbolt.org">gcc.godbolt.org</a>.</p>
</li>
<li>
<p>Choose <code>LLVM-IR</code> as programming language.</p>
</li>
<li>
<p>Use <code>llc</code> to compile the IR to a particular target as is:</p>
<ul>
<li>There are some useful flags: <code>-mattr</code> enables target features, <code>-march=</code>
selects the target, <code>-mcpu=</code> selects the CPU, etc.</li>
<li>Commands like <code>llc -march=help</code> output all architectures available, which
is useful because sometimes the Rust arch names and the LLVM names do not
match.</li>
<li>If you have compiled rustc yourself somewhere, in the target directory
you have binaries for <code>llc</code>, <code>opt</code>, etc.</li>
</ul>
</li>
<li>
<p>If you want to optimize the LLVM-IR, you can use <code>opt</code> to see how the LLVM
optimizations transform it.</p>
</li>
<li>
<p>Once you have a godbolt link demonstrating the issue, it is pretty easy to
fill in an LLVM bug. Just visit <a href="https://bugs.llvm.org/">bugs.llvm.org</a>.</p>
</li>
</ol>
<h3><a class="header" href="#porting-bug-fixes-from-llvm" id="porting-bug-fixes-from-llvm">Porting bug fixes from LLVM</a></h3>
<p>Once you've identified the bug as an LLVM bug, you will sometimes
find that it has already been reported and fixed in LLVM, but we haven't
gotten the fix yet (or perhaps you are familiar enough with LLVM to fix it yourself).</p>
<p>In that case, we can sometimes opt to port the fix for the bug
directly to our own LLVM fork, so that rustc can use it more easily.
Our fork of LLVM is maintained in <a href="https://github.com/rust-lang/llvm-project/">rust-lang/llvm-project</a>. Once
you've landed the fix there, you'll also need to land a PR modifying
our submodule commits -- ask around on Zulip for help.</p>
<h1><a class="header" href="#backend-agnostic-codegen" id="backend-agnostic-codegen">Backend Agnostic Codegen</a></h1>
<p>In the future, it would be nice to allow other codegen backends (e.g.
<a href="https://github.com/bytecodealliance/wasmtime/tree/master/cranelift">Cranelift</a>). To this end, <code>librustc_codegen_ssa</code> provides an
abstract interface for all backends to implenent.</p>
<blockquote>
<p>The following is a copy/paste of a README from the rust-lang/rust repo.
Please submit a PR if it needs updating.</p>
</blockquote>
<h1><a class="header" href="#refactoring-of-rustc_codegen_llvm" id="refactoring-of-rustc_codegen_llvm">Refactoring of <code>rustc_codegen_llvm</code></a></h1>
<p>by Denis Merigoux, October 23rd 2018</p>
<h2><a class="header" href="#state-of-the-code-before-the-refactoring" id="state-of-the-code-before-the-refactoring">State of the code before the refactoring</a></h2>
<p>All the code related to the compilation of MIR into LLVM IR was contained
inside the <code>rustc_codegen_llvm</code> crate. Here is the breakdown of the most
important elements:</p>
<ul>
<li>the <code>back</code> folder (7,800 LOC) implements the mechanisms for creating the
different object files and archive through LLVM, but also the communication
mechanisms for parallel code generation;</li>
<li>the <code>debuginfo</code> (3,200 LOC) folder contains all code that passes debug
information down to LLVM;</li>
<li>the <code>llvm</code> (2,200 LOC) folder defines the FFI necessary to communicate with
LLVM using the C++ API;</li>
<li>the <code>mir</code> (4,300 LOC) folder implements the actual lowering from MIR to LLVM
IR;</li>
<li>the <code>base.rs</code> (1,300 LOC) file contains some helper functions but also the
high-level code that launches the code generation and distributes the work.</li>
<li>the <code>builder.rs</code> (1,200 LOC) file contains all the functions generating
individual LLVM IR instructions inside a basic block;</li>
<li>the <code>common.rs</code> (450 LOC) contains various helper functions and all the
functions generating LLVM static values;</li>
<li>the <code>type_.rs</code> (300 LOC) defines most of the type translations to LLVM IR.</li>
</ul>
<p>The goal of this refactoring is to separate inside this crate code that is
specific to the LLVM from code that can be reused for other rustc backends. For
instance, the <code>mir</code> folder is almost entirely backend-specific but it relies
heavily on other parts of the crate. The separation of the code must not affect
the logic of the code nor its performance.</p>
<p>For these reasons, the separation process involves two transformations that
have to be done at the same time for the resulting code to compile :</p>
<ol>
<li>replace all the LLVM-specific types by generics inside function signatures
and structure definitions;</li>
<li>encapsulate all functions calling the LLVM FFI inside a set of traits that
will define the interface between backend-agnostic code and the backend.</li>
</ol>
<p>While the LLVM-specific code will be left in <code>rustc_codegen_llvm</code>, all the new
traits and backend-agnostic code will be moved in <code>rustc_codegen_ssa</code> (name
suggestion by @eddyb).</p>
<h2><a class="header" href="#generic-types-and-structures" id="generic-types-and-structures">Generic types and structures</a></h2>
<p>@irinagpopa started to parametrize the types of <code>rustc_codegen_llvm</code> by a
generic <code>Value</code> type, implemented in LLVM by a reference <code>&amp;'ll Value</code>. This
work has been extended to all structures inside the <code>mir</code> folder and elsewhere,
as well as for LLVM's <code>BasicBlock</code> and <code>Type</code> types.</p>
<p>The two most important structures for the LLVM codegen are <code>CodegenCx</code> and
<code>Builder</code>. They are parametrized by multiple lifetime parameters and the type
for <code>Value</code>.</p>
<pre><code class="language-rust ignore">struct CodegenCx&lt;'ll, 'tcx&gt; {
  /* ... */
}

struct Builder&lt;'a, 'll, 'tcx&gt; {
  cx: &amp;'a CodegenCx&lt;'ll, 'tcx&gt;,
  /* ... */
}
</code></pre>
<p><code>CodegenCx</code> is used to compile one codegen-unit that can contain multiple
functions, whereas <code>Builder</code> is created to compile one basic block.</p>
<p>The code in <code>rustc_codegen_llvm</code> has to deal with multiple explicit lifetime
parameters, that correspond to the following:</p>
<ul>
<li><code>'tcx</code> is the longest lifetime, that corresponds to the original <code>TyCtxt</code>
containing the program's information;</li>
<li><code>'a</code> is a short-lived reference of a <code>CodegenCx</code> or another object inside a
struct;</li>
<li><code>'ll</code> is the lifetime of references to LLVM objects such as <code>Value</code> or
<code>Type</code>.</li>
</ul>
<p>Although there are already many lifetime parameters in the code, making it
generic uncovered situations where the borrow-checker was passing only due to
the special nature of the LLVM objects manipulated (they are extern pointers).
For instance, an additional lifetime parameter had to be added to
<code>LocalAnalyser</code> in <code>analyse.rs</code>, leading to the definition:</p>
<pre><code class="language-rust ignore">struct LocalAnalyzer&lt;'mir, 'a, 'tcx&gt; {
  /* ... */
}
</code></pre>
<p>However, the two most important structures <code>CodegenCx</code> and <code>Builder</code> are not
defined in the backend-agnostic code. Indeed, their content is highly specific
of the backend and it makes more sense to leave their definition to the backend
implementor than to allow just a narrow spot via a generic field for the
backend's context.</p>
<h2><a class="header" href="#traits-and-interface" id="traits-and-interface">Traits and interface</a></h2>
<p>Because they have to be defined by the backend, <code>CodegenCx</code> and <code>Builder</code> will
be the structures implementing all the traits defining the backend's interface.
These traits are defined in the folder <code>rustc_codegen_ssa/traits</code> and all the
backend-agnostic code is parametrized by them. For instance, let us explain how
a function in <code>base.rs</code> is parametrized:</p>
<pre><code class="language-rust ignore">pub fn codegen_instance&lt;'a, 'tcx, Bx: BuilderMethods&lt;'a, 'tcx&gt;&gt;(
    cx: &amp;'a Bx::CodegenCx,
    instance: Instance&lt;'tcx&gt;
) {
    /* ... */
}
</code></pre>
<p>In this signature, we have the two lifetime parameters explained earlier and
the master type <code>Bx</code> which satisfies the trait <code>BuilderMethods</code> corresponding
to the interface satisfied by the <code>Builder</code> struct. The <code>BuilderMethods</code>
defines an associated type <code>Bx::CodegenCx</code> that itself satisfies the
<code>CodegenMethods</code> traits implemented by the struct <code>CodegenCx</code>.</p>
<p>On the trait side, here is an example with part of the definition of
<code>BuilderMethods</code> in <code>traits/builder.rs</code>:</p>
<pre><code class="language-rust ignore">pub trait BuilderMethods&lt;'a, 'tcx&gt;:
    HasCodegen&lt;'tcx&gt;
    + DebugInfoBuilderMethods&lt;'tcx&gt;
    + ArgTypeMethods&lt;'tcx&gt;
    + AbiBuilderMethods&lt;'tcx&gt;
    + IntrinsicCallMethods&lt;'tcx&gt;
    + AsmBuilderMethods&lt;'tcx&gt;
{
    fn new_block&lt;'b&gt;(
        cx: &amp;'a Self::CodegenCx,
        llfn: Self::Function,
        name: &amp;'b str
    ) -&gt; Self;
    /* ... */
    fn cond_br(
        &amp;mut self,
        cond: Self::Value,
        then_llbb: Self::BasicBlock,
        else_llbb: Self::BasicBlock,
    );
    /* ... */
}
</code></pre>
<p>Finally, a master structure implementing the <code>ExtraBackendMethods</code> trait is
used for high-level codegen-driving functions like <code>codegen_crate</code> in
<code>base.rs</code>. For LLVM, it is the empty <code>LlvmCodegenBackend</code>.
<code>ExtraBackendMethods</code> should be implemented by the same structure that
implements the <code>CodegenBackend</code> defined in
<code>rustc_codegen_utils/codegen_backend.rs</code>.</p>
<p>During the traitification process, certain functions have been converted from
methods of a local structure to methods of <code>CodegenCx</code> or <code>Builder</code> and a
corresponding <code>self</code> parameter has been added. Indeed, LLVM stores information
internally that it can access when called through its API. This information
does not show up in a Rust data structure carried around when these methods are
called. However, when implementing a Rust backend for <code>rustc</code>, these methods
will need information from <code>CodegenCx</code>, hence the additional parameter (unused
in the LLVM implementation of the trait).</p>
<h2><a class="header" href="#state-of-the-code-after-the-refactoring" id="state-of-the-code-after-the-refactoring">State of the code after the refactoring</a></h2>
<p>The traits offer an API which is very similar to the API of LLVM. This is not
the best solution since LLVM has a very special way of doing things: when
addding another backend, the traits definition might be changed in order to
offer more flexibility.</p>
<p>However, the current separation between backend-agnostic and LLVM-specific code
has allowed the reuse of a significant part of the old <code>rustc_codegen_llvm</code>.
Here is the new LOC breakdown between backend-agnostic (BA) and LLVM for the
most important elements:</p>
<ul>
<li><code>back</code> folder: 3,800 (BA) vs 4,100 (LLVM);</li>
<li><code>mir</code> folder: 4,400 (BA) vs 0 (LLVM);</li>
<li><code>base.rs</code>: 1,100 (BA) vs 250 (LLVM);</li>
<li><code>builder.rs</code>: 1,400 (BA) vs 0 (LLVM);</li>
<li><code>common.rs</code>: 350 (BA) vs 350 (LLVM);</li>
</ul>
<p>The <code>debuginfo</code> folder has been left almost untouched by the splitting and is
specific to LLVM. Only its high-level features have been traitified.</p>
<p>The new <code>traits</code> folder has 1500 LOC only for trait definitions. Overall, the
27,000 LOC-sized old <code>rustc_codegen_llvm</code> code has been split into the new
18,500 LOC-sized new <code>rustc_codegen_llvm</code> and the 12,000 LOC-sized
<code>rustc_codegen_ssa</code>. We can say that this refactoring allowed the reuse of
approximately 10,000 LOC that would otherwise have had to be duplicated between
the multiple backends of <code>rustc</code>.</p>
<p>The refactored version of <code>rustc</code>'s backend introduced no regression over the
test suite nor in performance benchmark, which is in coherence with the nature
of the refactoring that used only compile-time parametricity (no trait
objects).</p>
<h1><a class="header" href="#implicit-caller-location" id="implicit-caller-location">Implicit Caller Location</a></h1>
<p>Approved in <a href="https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md">RFC 2091</a>, this feature enables the accurate reporting of caller location during panics
initiated from functions like <code>Option::unwrap</code>, <code>Result::expect</code>, and <code>Index::index</code>. This feature 
adds the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-track_caller-attribute"><code>#[track_caller]</code></a> attribute for functions, the 
<a href="https://doc.rust-lang.org/nightly/core/intrinsics/fn.caller_location.html"><code>caller_location</code></a> intrinsic, and the stabilization-friendly 
<a href="https://doc.rust-lang.org/nightly/core/panic/struct.Location.html#method.caller"><code>core::panic::Location::caller</code></a> wrapper.</p>
<h2><a class="header" href="#motivating-example" id="motivating-example">Motivating Example</a></h2>
<p>Take this example program:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let foo: Option&lt;()&gt; = None;
    foo.unwrap(); // this should produce a useful panic message!
}
</code></pre></pre>
<p>Prior to Rust 1.42, panics like this <code>unwrap()</code> printed a location in libcore:</p>
<pre><code>$ rustc +1.41.0 example.rs; example.exe
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',...core\macros\mod.rs:15:40
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>As of 1.42, we get a much more helpful message:</p>
<pre><code>$ rustc +1.42.0 example.rs; example.exe 
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', example.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>These error messages are achieved through a combination of changes to <code>panic!</code> internals to make use
of <code>core::panic::Location::caller</code> and a number of <code>#[track_caller]</code> annotations in the standard 
library which propagate caller information.</p>
<h2><a class="header" href="#reading-caller-location" id="reading-caller-location">Reading Caller Location</a></h2>
<p>Previously, <code>panic!</code> made use of the <code>file!()</code>, <code>line!()</code>, and <code>column!()</code> macros to construct a
<a href="https://doc.rust-lang.org/core/panic/struct.Location.html"><code>Location</code></a> pointing to where the panic occurred. These macros couldn't be given an overridden
location, so functions which intentionally invoked <code>panic!</code> couldn't provide their own location, 
hiding the actual source of error.</p>
<p>Internally, <code>panic!()</code> now calls <a href="https://doc.rust-lang.org/nightly/core/panic/struct.Location.html#method.caller"><code>core::panic::Location::caller()</code></a> to find out where it 
was expanded. This function is itself annotated with <code>#[track_caller]</code> and wraps the 
<a href="https://doc.rust-lang.org/nightly/core/intrinsics/fn.caller_location.html"><code>caller_location</code></a> compiler intrinsic implemented by rustc. This intrinsic is easiest 
explained in terms of how it works in a <code>const</code> context.</p>
<h2><a class="header" href="#caller-location-in-const" id="caller-location-in-const">Caller Location in <code>const</code></a></h2>
<p>There are two main phases to returning the caller location in a const context: walking up the stack
to find the right location and allocating a const value to return.</p>
<h3><a class="header" href="#finding-the-right-location" id="finding-the-right-location">Finding the right <code>Location</code></a></h3>
<p>In a const context we &quot;walk up the stack&quot; from where the intrinsic is invoked, stopping when we 
reach the first function call in the stack which does <em>not</em> have the attribute. This walk is in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/struct.InterpCx.html#method.find_closest_untracked_caller_location"><code>InterpCx::find_closest_untracked_caller_location()</code></a>.</p>
<p>Starting at the bottom, we iterate up over stack <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/struct.Frame.html"><code>Frame</code></a>s in the 
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/struct.InterpCx.html#structfield.stack"><code>InterpCx::stack</code></a>, calling
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.InstanceDef.html#method.requires_caller_location"><code>InstanceDef::requires_caller_location</code></a> on the 
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/struct.Frame.html#structfield.instance"><code>Instance</code>s from each <code>Frame</code></a>. We stop once we find one that returns <code>false</code> and
return the span of the <em>previous</em> frame which was the &quot;topmost&quot; tracked function.</p>
<h3><a class="header" href="#allocating-a-static-location" id="allocating-a-static-location">Allocating a static <code>Location</code></a></h3>
<p>Once we have a <code>Span</code>, we need to allocate static memory for the <code>Location</code>, which is performed by 
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html#method.const_caller_location"><code>TyCtxt::const_caller_location()</code></a> query. Internally this calls 
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/struct.InterpCx.html#method.alloc_caller_location"><code>InterpCx::alloc_caller_location()</code></a> and results in a unique
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/enum.MemoryKind.html#variant.CallerLocation">memory kind</a> (<code>MemoryKind::CallerLocation</code>). The SSA codegen backend is able
to emit code for these same values, and we use this code there as well.</p>
<p>Once our <code>Location</code> has been allocated in static memory, our intrinsic returns a reference to it.</p>
<h2><a class="header" href="#generating-code-for-track_caller-callees" id="generating-code-for-track_caller-callees">Generating code for <code>#[track_caller]</code> callees</a></h2>
<p>To generate efficient code for a tracked function and its callers, we need to provide the same 
behavior from the intrinsic's point of view without having a stack to walk up at runtime. We invert
the approach: as we grow the stack down we pass an additional argument to calls of tracked functions
rather than walking up the stack when the intrinsic is called. That additional argument can be
returned wherever the caller location is queried.</p>
<p>The argument we append is of type <code>&amp;'static core::panic::Location&lt;'staic&gt;</code>. A reference was chosen
to avoid unnecessary copying because a pointer is a third the size of 
<code>std::mem::size_of::&lt;core::panic::Location&gt;() == 24</code> at time of writing.</p>
<p>When generating a call to a function which is tracked, we pass the location argument the value of
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#method.get_caller_location"><code>FunctionCx::get_caller_location</code></a>.</p>
<p>If the calling function is tracked, <code>get_caller_location</code> returns the local in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#structfield.caller_location"><code>FunctionCx::caller_location</code></a> which was populated by the current caller's caller.
In these cases the intrinsic &quot;returns&quot; a reference which was actually provided in an argument to its
caller.</p>
<p>If the calling function is not tracked, <code>get_caller_location</code> allocates a <code>Location</code> static from
the current <code>Span</code> and returns a reference to that.</p>
<p>We more efficiently achieve the same behavior as a loop starting from the bottom by passing a single
<code>&amp;Location</code> value through the <code>caller_location</code> fields of multiple <code>FunctionCx</code>s as we grow the
stack downward.</p>
<h3><a class="header" href="#codegen-examples" id="codegen-examples">Codegen examples</a></h3>
<p>What does this transformation look like in practice? Take this example which uses the new feature:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(track_caller)]
use std::panic::Location;

#[track_caller]
fn print_caller() {
    println!(&quot;called from {}&quot;, Location::caller());
}

fn main() {
    print_caller();
}
</code></pre></pre>
<p>Here <code>print_caller()</code> appears to take no arguments, but we compile it to something like this:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(panic_internals)]
use std::panic::Location;

fn print_caller(caller: &amp;Location) {
    println!(&quot;called from {}&quot;, caller);
}

fn main() {
    print_caller(&amp;Location::internal_constructor(file!(), line!(), column!()));
}
</code></pre></pre>
<h3><a class="header" href="#dynamic-dispatch" id="dynamic-dispatch">Dynamic Dispatch</a></h3>
<p>In codegen contexts we have to modify the callee ABI to pass this information down the stack, but
the attribute expressly does <em>not</em> modify the type of the function. The ABI change must be
transparent to type checking and remain sound in all uses.</p>
<p>Direct calls to tracked functions will always know the full codegen flags for the callee and can
generate appropriate code. Indirect callers won't have this information and it's not encoded in
the type of the function pointer they call, so we generate a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.InstanceDef.html#variant.ReifyShim"><code>ReifyShim</code></a> around the function
whenever taking a pointer to it. This shim isn't able to report the actual location of the indirect
call (the function's definition site is reported instead), but it prevents miscompilation and is
probably the best we can do without modifying fully-stabilized type signatures.</p>
<blockquote>
<p><em>Note:</em> We always emit a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.InstanceDef.html#variant.ReifyShim"><code>ReifyShim</code></a> when taking a pointer to a tracked function. While the
constraint here is imposed by codegen contexts, we don't know during MIR construction of the shim
whether we'll be called in a const context (safe to ignore shim) or in a codegen context (unsafe 
to ignore shim). Even if we did know, the results from const and codegen contexts must agree.</p>
</blockquote>
<h2><a class="header" href="#the-attribute" id="the-attribute">The Attribute</a></h2>
<p>The <code>#[track_caller]</code> attribute is checked alongside other codegen attributes to ensure the 
function:</p>
<ul>
<li>has the <code>&quot;Rust&quot;</code> ABI (as opposed to e.g., <code>&quot;C&quot;</code>)</li>
<li>is not a foreign import (e.g., in an <code>extern {...}</code> block)</li>
<li>is not a closure</li>
<li>is not <code>#[naked]</code></li>
</ul>
<p>If the use is valid, we set <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/middle/codegen_fn_attrs/struct.CodegenFnAttrFlags.html#associatedconstant.TRACK_CALLER"><code>CodegenFnAttrsFlags::TRACK_CALLER</code></a>. This flag influences
the return value of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.InstanceDef.html#method.requires_caller_location"><code>InstanceDef::requires_caller_location</code></a> which is in turn
used in both const and codegen contexts to ensure correct propagation.</p>
<h3><a class="header" href="#traits" id="traits">Traits</a></h3>
<p>When applied to trait method implementations, the attribute works as it does for regular functions.</p>
<p>When applied to a trait method prototype, the attribute applies to all implementations of the 
method. When applied to a default trait method implementation, the attribute takes effect on
that implementation <em>and</em> any overrides.</p>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(track_caller)]

macro_rules! assert_tracked {
    () =&gt; {{
        let location = std::panic::Location::caller();
        assert_eq!(location.file(), file!());
        assert_ne!(location.line(), line!(), &quot;line should be outside this fn&quot;);
        println!(&quot;called at {}&quot;, location);
    }};
}

trait TrackedFourWays {
    /// All implementations inherit `#[track_caller]`.
    #[track_caller]
    fn blanket_tracked();

    /// Implementors can annotate themselves.
    fn local_tracked();

    /// This implementation is tracked (overrides are too).
    #[track_caller]
    fn default_tracked() {
        assert_tracked!();
    }

    /// Overrides of this implementation are tracked (it is too). 
    #[track_caller]
    fn default_tracked_to_override() {
        assert_tracked!();
    }
}

/// This impl uses the default impl for `default_tracked` and provides its own for 
/// `default_tracked_to_override`.
impl TrackedFourWays for () {
    fn blanket_tracked() {
        assert_tracked!();
    }

    #[track_caller]
    fn local_tracked() {
        assert_tracked!();
    }

    fn default_tracked_to_override() {
        assert_tracked!();
    }
}

fn main() {
    &lt;() as TrackedFourWays&gt;::blanket_tracked();
    &lt;() as TrackedFourWays&gt;::default_tracked();
    &lt;() as TrackedFourWays&gt;::default_tracked_to_override();
    &lt;() as TrackedFourWays&gt;::local_tracked();
}
</code></pre></pre>
<h2><a class="header" href="#backgroundhistory" id="backgroundhistory">Background/History</a></h2>
<p>Broadly speaking, this feature's goal is to improve common Rust error messages without breaking
stability guarantees, requiring modifications to end-user source, relying on platform-specific
debug-info, or preventing user-defined types from having the same error-reporting benefits.</p>
<p>Improving the output of these panics has been a goal of proposals since at least mid-2016 (see
<a href="https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md#non-viable-alternatives">non-viable alternatives</a> in the approved RFC for details). It took two more years until RFC 2091
was approved, much of its <a href="https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md#rationale">rationale</a> for this feature's design having been discovered through the
discussion around several earlier proposals.</p>
<p>The design in the original RFC limited itself to implementations that could be done inside the
compiler at the time without significant refactoring. However in the year and a half between the
approval of the RFC and the actual implementation work, a <a href="https://github.com/rust-lang/rust/issues/47809#issuecomment-443538059">revised design</a> was proposed and written
up on the tracking issue. During the course of implementing that, it was also discovered that an
implementation was possible without modifying the number of arguments in a function's MIR, which
would simplify later stages and unlock use in traits.</p>
<p>Because the RFC's implementation strategy could not readily support traits, the semantics were not 
originally specified. They have since been implemented following the path which seemed most correct
to the author and reviewers.</p>
<h1><a class="header" href="#profile-guided-optimization" id="profile-guided-optimization">Profile Guided Optimization</a></h1>
<p><code>rustc</code> supports doing profile-guided optimization (PGO).
This chapter describes what PGO is and how the support for it is
implemented in <code>rustc</code>.</p>
<h2><a class="header" href="#what-is-profiled-guided-optimization" id="what-is-profiled-guided-optimization">What Is Profiled-Guided Optimization?</a></h2>
<p>The basic concept of PGO is to collect data about the typical execution of
a program (e.g. which branches it is likely to take) and then use this data
to inform optimizations such as inlining, machine-code layout,
register allocation, etc.</p>
<p>There are different ways of collecting data about a program's execution.
One is to run the program inside a profiler (such as <code>perf</code>) and another
is to create an instrumented binary, that is, a binary that has data
collection built into it, and run that.
The latter usually provides more accurate data.</p>
<h2><a class="header" href="#how-is-pgo-implemented-in-rustc" id="how-is-pgo-implemented-in-rustc">How is PGO implemented in <code>rustc</code>?</a></h2>
<p><code>rustc</code> current PGO implementation relies entirely on LLVM.
LLVM actually <a href="https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization">supports multiple forms</a> of PGO:</p>
<ul>
<li>Sampling-based PGO where an external profiling tool like <code>perf</code> is used
to collect data about a program's execution.</li>
<li>GCOV-based profiling, where code coverage infrastructure is used to collect
profiling information.</li>
<li>Front-end based instrumentation, where the compiler front-end (e.g. Clang)
inserts instrumentation intrinsics into the LLVM IR it generates.</li>
<li>IR-level instrumentation, where LLVM inserts the instrumentation intrinsics
itself during optimization passes.</li>
</ul>
<p><code>rustc</code> supports only the last approach, IR-level instrumentation, mainly
because it is almost exclusively implemented in LLVM and needs little
maintenance on the Rust side. Fortunately, it is also the most modern approach,
yielding the best results.</p>
<p>So, we are dealing with an instrumentation-based approach, i.e. profiling data
is generated by a specially instrumented version of the program that's being
optimized. Instrumentation-based PGO has two components: a compile-time
component and run-time component, and one needs to understand the overall
workflow to see how they interact.</p>
<h3><a class="header" href="#overall-workflow" id="overall-workflow">Overall Workflow</a></h3>
<p>Generating a PGO-optimized program involves the following four steps:</p>
<ol>
<li>Compile the program with instrumentation enabled (e.g. <code>rustc -Cprofile-generate main.rs</code>)</li>
<li>Run the instrumented program (e.g. <code>./main</code>) which generates a <code>default-&lt;id&gt;.profraw</code> file</li>
<li>Convert the <code>.profraw</code> file into a <code>.profdata</code> file using LLVM's <code>llvm-profdata</code> tool.</li>
<li>Compile the program again, this time making use of the profiling data
(e.g. <code>rustc -Cprofile-use=merged.profdata main.rs</code>)</li>
</ol>
<h3><a class="header" href="#compile-time-aspects" id="compile-time-aspects">Compile-Time Aspects</a></h3>
<p>Depending on which step in the above workflow we are in, two different things
can happen at compile time:</p>
<h4><a class="header" href="#create-binaries-with-instrumentation" id="create-binaries-with-instrumentation">Create Binaries with Instrumentation</a></h4>
<p>As mentioned above, the profiling instrumentation is added by LLVM.
<code>rustc</code> instructs LLVM to do so <a href="https://github.com/rust-lang/rust/blob/1.34.1/src/rustllvm/PassWrapper.cpp#L412-L416">by setting the appropriate</a>
flags when creating LLVM <code>PassManager</code>s:</p>
<pre><code class="language-C">	// `PMBR` is an `LLVMPassManagerBuilderRef`
    unwrap(PMBR)-&gt;EnablePGOInstrGen = true;
    // Instrumented binaries have a default output path for the `.profraw` file
    // hard-coded into them:
    unwrap(PMBR)-&gt;PGOInstrGen = PGOGenPath;
</code></pre>
<p><code>rustc</code> also has to make sure that some of the symbols from LLVM's profiling
runtime are not removed <a href="https://github.com/rust-lang/rust/blob/1.34.1/src/librustc_codegen_ssa/back/symbol_export.rs#L212-L225">by marking the with the right export level</a>.</p>
<h4><a class="header" href="#compile-binaries-where-optimizations-make-use-of-profiling-data" id="compile-binaries-where-optimizations-make-use-of-profiling-data">Compile Binaries Where Optimizations Make Use Of Profiling Data</a></h4>
<p>In the final step of the workflow described above, the program is compiled
again, with the compiler using the gathered profiling data in order to drive
optimization decisions. <code>rustc</code> again leaves most of the work to LLVM here,
basically <a href="https://github.com/rust-lang/rust/blob/1.34.1/src/rustllvm/PassWrapper.cpp#L417-L420">just telling</a> the LLVM <code>PassManagerBuilder</code>
where the profiling data can be found:</p>
<pre><code class="language-C">	unwrap(PMBR)-&gt;PGOInstrUse = PGOUsePath;
</code></pre>
<p>LLVM does the rest (e.g. setting branch weights, marking functions with
<code>cold</code> or <code>inlinehint</code>, etc).</p>
<h3><a class="header" href="#runtime-aspects" id="runtime-aspects">Runtime Aspects</a></h3>
<p>Instrumentation-based approaches always also have a runtime component, i.e.
once we have an instrumented program, that program needs to be run in order
to generate profiling data, and collecting and persisting this profiling
data needs some infrastructure in place.</p>
<p>In the case of LLVM, these runtime components are implemented in
<a href="https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/profile">compiler-rt</a> and statically linked into any instrumented
binaries.
The <code>rustc</code> version of this can be found in <code>src/libprofiler_builtins</code> which
basically packs the C code from <code>compiler-rt</code> into a Rust crate.</p>
<p>In order for <code>libprofiler_builtins</code> to be built, <code>profiler = true</code> must be set
in <code>rustc</code>'s <code>config.toml</code>.</p>
<h2><a class="header" href="#testing-pgo" id="testing-pgo">Testing PGO</a></h2>
<p>Since the PGO workflow spans multiple compiler invocations most testing happens
in <a href="https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps">run-make tests</a> (the relevant tests have <code>pgo</code> in their name).
There is also a <a href="https://github.com/rust-lang/rust/blob/master/src/test/codegen/pgo-instrumentation.rs">codegen test</a> that checks that some expected
instrumentation artifacts show up in LLVM IR.</p>
<h2><a class="header" href="#additional-information" id="additional-information">Additional Information</a></h2>
<p>Clang's documentation contains a good overview on PGO in LLVM here:
https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization</p>
<h1><a class="header" href="#sanitizers-support" id="sanitizers-support">Sanitizers Support</a></h1>
<p>The rustc compiler contains support for following sanitizers:</p>
<ul>
<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a> a faster memory error detector. Can
detect out-of-bounds access to heap, stack, and globals, use after free, use
after return, double free, invalid free, memory leaks.</li>
<li><a href="https://clang.llvm.org/docs/LeakSanitizer.html">LeakSanitizer</a> a run-time memory leak detector.</li>
<li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a> a detector of uninitialized reads.</li>
<li><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a> a fast data race detector.</li>
</ul>
<h2><a class="header" href="#how-to-use-the-sanitizers" id="how-to-use-the-sanitizers">How to use the sanitizers?</a></h2>
<p>To enable a sanitizer compile with <code>-Zsanitizer=...</code> option, where value is one
of <code>address</code>, <code>leak</code>, <code>memory</code> or <code>thread</code>. For more details how to use
sanitizers please refer to <a href="https://doc.rust-lang.org/unstable-book/">the unstable book</a>.</p>
<h2><a class="header" href="#how-are-sanitizers-implemented-in-rustc" id="how-are-sanitizers-implemented-in-rustc">How are sanitizers implemented in rustc?</a></h2>
<p>The implementation of sanitizers relies almost entirely on LLVM. The rustc is
an integration point for LLVM compile time instrumentation passes and runtime
libraries. Highlight of the most important aspects of the implementation:</p>
<ul>
<li>
<p>The sanitizer runtime libraries are part of the <a href="https://github.com/llvm/llvm-project/tree/master/compiler-rt">compiler-rt</a> project, and
<a href="https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src/bootstrap/native.rs#L566-L624">will be built on supported targets</a> when enabled in <code>config.toml</code>:</p>
<pre><code class="language-toml">[build]
sanitizers = true
</code></pre>
<p>The runtimes are <a href="https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src/bootstrap/compile.rs#L270-L304">placed into target libdir</a>.</p>
</li>
<li>
<p>During LLVM code generation, the functions intended for instrumentation are
<a href="https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src/librustc_codegen_llvm/attributes.rs#L49-L72">marked</a> with appropriate LLVM attribute:
<code>SanitizeAddress</code>, <code>SanitizeMemory</code>, or <code>SanitizeThread</code>. By default all
functions are instrumented, but this behaviour can be changed with
<code>#[no_sanitize(...)]</code>.</p>
</li>
<li>
<p>The decision whether to perform instrumentation or not is possible only at a
function granularity. In the cases were those decision differ between
functions it might be necessary to inhibit inlining, both at <a href="https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src/librustc_mir/transform/inline.rs#L232-L252">MIR
level</a> and <a href="https://github.com/rust-lang/llvm-project/blob/9330ec5a4c1df5fc1fa62f993ed6a04da68cb040/llvm/include/llvm/IR/Attributes.td#L225-L241">LLVM level</a>.</p>
</li>
<li>
<p>The LLVM IR generated by rustc is instrumented by <a href="https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src/librustc_codegen_llvm/back/write.rs#L454-L475">dedicated LLVM
passes</a>, different for each sanitizer. Instrumentation
passes are invoked after optimization passes.</p>
</li>
<li>
<p>When producing an executable, the sanitizer specific runtime library is
<a href="https://github.com/rust-lang/rust/blob/a29424a2265411dda7d7446516ac5fd7499e2b55/src/librustc_codegen_ssa/back/link.rs#L748-L787">linked in</a>. The libraries are searched for in target libdir
relative to default system root, so that this process is not affected
by sysroot overrides used for example by cargo <code>-Zbuild-std</code> functionality.</p>
</li>
</ul>
<h2><a class="header" href="#additional-information-1" id="additional-information-1">Additional Information</a></h2>
<ul>
<li><a href="https://github.com/google/sanitizers/wiki/">Sanitizers project page</a></li>
<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/LeakSanitizer.html">LeakSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer in Clang</a></li>
</ul>
<h1><a class="header" href="#debugging-support-in-the-rust-compiler" id="debugging-support-in-the-rust-compiler">Debugging support in the Rust compiler</a></h1>
<p>This document explains the state of debugging tools support in the Rust compiler (rustc).
The document gives an overview of debugging tools like GDB, LLDB etc. and infrastructure
around Rust compiler to debug Rust code. If you want to learn how to debug the Rust compiler
itself, then you must see <a href="compiler-debugging.html">Debugging the Compiler</a> page.</p>
<p>The material is gathered from YouTube video <a href="https://www.youtube.com/watch?v=elBxMRSNYr4">Tom Tromey discusses debugging support in rustc</a>.</p>
<h2><a class="header" href="#preliminaries" id="preliminaries">Preliminaries</a></h2>
<h3><a class="header" href="#debuggers" id="debuggers">Debuggers</a></h3>
<p>According to Wikipedia</p>
<blockquote>
<p>A <a href="https://en.wikipedia.org/wiki/Debugger">debugger or debugging tool</a> is a computer program that is used to test and debug
other programs (the &quot;target&quot; program).</p>
</blockquote>
<p>Writing a debugger from scratch for a language requires a lot of work, especially if
debuggers have to be supported on various platforms. GDB and LLDB, however, can be
extended to support debugging a language. This is the path that Rust has chosen.
This document's main goal is to document the said debuggers support in Rust compiler.</p>
<h3><a class="header" href="#dwarf" id="dwarf">DWARF</a></h3>
<p>According to the <a href="http://dwarfstd.org">DWARF</a> standard website</p>
<blockquote>
<p>DWARF is a debugging file format used by many compilers and debuggers to support source level
debugging. It addresses the requirements of a number of procedural languages,
such as C, C++, and Fortran, and is designed to be extensible to other languages.
DWARF is architecture independent and applicable to any processor or operating system.
It is widely used on Unix, Linux and other operating systems,
as well as in stand-alone environments.</p>
</blockquote>
<p>DWARF reader is a program that consumes the DWARF format and creates debugger compatible output.
This program may live in the compiler itself.  DWARF uses a data structure called
Debugging Information Entry (DIE) which stores the information as &quot;tags&quot; to denote functions,
variables etc., e.g., <code>DW_TAG_variable</code>, <code>DW_TAG_pointer_type</code>, <code>DW_TAG_subprogram</code> etc.
You can also invent your own tags and attributes.</p>
<h2><a class="header" href="#supported-debuggers" id="supported-debuggers">Supported debuggers</a></h2>
<h3><a class="header" href="#gdb" id="gdb">GDB</a></h3>
<p>We have our own fork of GDB - <a href="https://github.com/rust-dev-tools/gdb">https://github.com/rust-dev-tools/gdb</a></p>
<h4><a class="header" href="#rust-expression-parser" id="rust-expression-parser">Rust expression parser</a></h4>
<p>To be able to show debug output we need an expression parser.
This (GDB) expression parser is written in <a href="https://www.gnu.org/software/bison/">Bison</a> and is only a subset of Rust expressions.
This means that this parser can parse only a subset of Rust expressions.
GDB parser was written from scratch and has no relation to any other parser.
For example, this parser is not related to Rustc's parser.</p>
<p>GDB has Rust like value and type output. It can print values and types in a way
that look like Rust syntax in the output. Or when you print a type as <a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_109.html">ptype</a> in GDB,
it also looks like Rust source code. Checkout the documentation in the <a href="https://sourceware.org/gdb/onlinedocs/gdb/Rust.html">manual for GDB/Rust</a>.</p>
<h4><a class="header" href="#parser-extensions" id="parser-extensions">Parser extensions</a></h4>
<p>Expression parser has a couple of extensions in it to facilitate features that you cannot do
with Rust. Some limitations are listed in the <a href="https://sourceware.org/gdb/onlinedocs/gdb/Rust.html">manual for GDB/Rust</a>. There is some special
code in the DWARF reader in GDB to support the extensions.</p>
<p>A couple of examples of DWARF reader support needed are as follows -</p>
<ol>
<li>
<p>Enum: Needed for support for enum types. The Rustc writes the information about enum into
DWARF and GDB reads the DWARF to understand where is the tag field or is there a tag
field or is the tag slot shared with non-zero optimization etc.</p>
</li>
<li>
<p>Dissect trait objects: DWARF extension where the trait object's description in the DWARF
also points to a stub description of the corresponding vtable which in turn points to the
concrete type for which this trait object exists. This means that you can do a <code>print *object</code>
for that trait object, and GDB will understand how to find the correct type of the payload in
the trait object.</p>
</li>
</ol>
<p><strong>TODO</strong>: Figure out if the following should be mentioned in the GDB-Rust document rather than
this guide page so there is no duplication. This is regarding the following comments:</p>
<p><a href="https://github.com/rust-lang/rustc-dev-guide/pull/316#discussion_r284027340">This comment by Tom</a></p>
<blockquote>
<p>gdb's Rust extensions and limitations are documented in the gdb manual:
https://sourceware.org/gdb/onlinedocs/gdb/Rust.html -- however, this neglects to mention that
gdb convenience variables and registers follow the gdb $ convention, and that the Rust parser
implements the gdb @ extension.</p>
</blockquote>
<p><a href="https://github.com/rust-lang/rustc-dev-guide/pull/316#discussion_r285401353">This question by Aman</a></p>
<blockquote>
<p>@tromey do you think we should mention this part in the GDB-Rust document rather than this
document so there is no duplication etc.?</p>
</blockquote>
<h4><a class="header" href="#developer-notes" id="developer-notes">Developer notes</a></h4>
<ul>
<li>This work is now upstream. Bugs can be reported in <a href="https://sourceware.org/bugzilla/">GDB Bugzilla</a>.</li>
</ul>
<h3><a class="header" href="#lldb" id="lldb">LLDB</a></h3>
<p>We have our own fork of LLDB - <a href="https://github.com/rust-lang/lldb">https://github.com/rust-lang/lldb</a></p>
<p>Fork of LLVM project - <a href="https://github.com/rust-lang/llvm-project">https://github.com/rust-lang/llvm-project</a></p>
<p>LLDB currently only works on macOS because of a dependency issue. This issue was easier to
solve for macOS as compared to Linux. However, Tom has a possible solution which can enable
us to ship LLDB everywhere.</p>
<h4><a class="header" href="#rust-expression-parser-1" id="rust-expression-parser-1">Rust expression parser</a></h4>
<p>This expression parser is written in C++. It is a type of <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">Recursive Descent parser</a>.
Implements slightly less of the Rust language than GDB. LLDB has Rust like value and type output.</p>
<h4><a class="header" href="#parser-extensions-1" id="parser-extensions-1">Parser extensions</a></h4>
<p>There is some special code in the DWARF reader in LLDB to support the extensions.
A couple of examples of DWARF reader support needed are as follows -</p>
<ol>
<li>Enum: Needed for support for enum types. The Rustc writes the information about
enum into DWARF and LLDB reads the DWARF to understand where is the tag field or
is there a tag field or is the tag slot shared with non-zero optimization etc.
In other words, it has enum support as well.</li>
</ol>
<h4><a class="header" href="#developer-notes-1" id="developer-notes-1">Developer notes</a></h4>
<ul>
<li>None of the LLDB work is upstream. This <a href="https://github.com/rust-lang/lldb/wiki">rust-lang/lldb wiki page</a> explains a few details.</li>
<li>The reason for forking LLDB is that LLDB recently removed all the other language plugins
due to lack of maintenance.</li>
<li>LLDB has a plugin architecture but that does not work for language support.</li>
<li>LLDB is available via Rust build (<code>rustup</code>).</li>
<li>GDB generally works better on Linux.</li>
</ul>
<h2><a class="header" href="#dwarf-and-rustc" id="dwarf-and-rustc">DWARF and Rustc</a></h2>
<p><a href="http://dwarfstd.org">DWARF</a> is the standard way compilers generate debugging information that debuggers read.
It is <em>the</em> debugging format on macOS and Linux. It is a multi-language, extensible format
and is mostly good enough for Rust's purposes. Hence, the current implementation reuses DWARF's
concepts. This is true even if some of the concepts in DWARF do not align with Rust
semantically because generally there can be some kind of mapping between the two.</p>
<p>We have some DWARF extensions that the Rust compiler emits and the debuggers understand that
are <em>not</em> in the DWARF standard.</p>
<ul>
<li>
<p>Rust compiler will emit DWARF for a virtual table, and this <code>vtable</code> object will have a
<code>DW_AT_containing_type</code> that points to the real type. This lets debuggers dissect a trait object
pointer to correctly find the payload. E.g., here's such a DIE, from a test case in the gdb
repository:</p>
<pre><code class="language-asm">&lt;1&gt;&lt;1a9&gt;: Abbrev Number: 3 (DW_TAG_structure_type)
   &lt;1aa&gt;   DW_AT_containing_type: &lt;0x1b4&gt;
   &lt;1ae&gt;   DW_AT_name        : (indirect string, offset: 0x23d): vtable
   &lt;1b2&gt;   DW_AT_byte_size   : 0
   &lt;1b3&gt;   DW_AT_alignment   : 8
</code></pre>
</li>
<li>
<p>The other extension is that the Rust compiler can emit a tagless discriminated union.
See <a href="http://dwarfstd.org/ShowIssue.php?issue=180517.2">DWARF feature request</a> for this item.</p>
</li>
</ul>
<h3><a class="header" href="#current-limitations-of-dwarf" id="current-limitations-of-dwarf">Current limitations of DWARF</a></h3>
<ul>
<li>Traits - require a bigger change than normal to DWARF, on how to represent Traits in DWARF.</li>
<li>DWARF provides no way to differentiate between Structs and Tuples. Rust compiler emits
fields with <code>__0</code> and debuggers look for a sequence of such names to overcome this limitation.
For example, in this case the debugger would look at a field via <code>x.__0</code> instead of <code>x.0</code>.
This is resolved via the Rust parser in the debugger so now you can do <code>x.0</code>.</li>
</ul>
<p>DWARF relies on debuggers to know some information about platform ABI.
Rust does not do that all the time.</p>
<h2><a class="header" href="#developer-notes-2" id="developer-notes-2">Developer notes</a></h2>
<p>This section is from the talk about certain aspects of development.</p>
<h2><a class="header" href="#what-is-missing" id="what-is-missing">What is missing</a></h2>
<h3><a class="header" href="#shipping-gdb-in-rustup" id="shipping-gdb-in-rustup">Shipping GDB in Rustup</a></h3>
<p>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/34457">https://github.com/rust-lang/rust/issues/34457</a></p>
<p>Shipping GDB requires change to Rustup delivery system. To manage Rustup build size and
times we need to build GDB separately, on its own and somehow provide the artifacts produced
to be included in the final build. However, if we can ship GDB with rustup, it will simplify
the development process by having compiler emit new debug info which can be readily consumed.</p>
<p>Main issue in achieving this is setting up dependencies. One such dependency is Python. That
is why we have our own fork of GDB because one of the drivers is patched on Rust's side to
check the correct version of Python (Python 2.7 in this case. <em>Note: Python3 is not chosen
for this purpose because Python's stable ABI is limited and is not sufficient for GDB's needs.
See <a href="https://docs.python.org/3/c-api/stable.html">https://docs.python.org/3/c-api/stable.html</a></em>).</p>
<p>This is to keep updates to debugger as fast as possible as we make changes to the debugging symbols.
In essence, to ship the debugger as soon as new debugging info is added. GDB only releases
every six months or so. However, the changes that are
not related to Rust itself should ideally be first merged to upstream eventually.</p>
<h3><a class="header" href="#code-signing-for-lldb-debug-server-on-macos" id="code-signing-for-lldb-debug-server-on-macos">Code signing for LLDB debug server on macOS</a></h3>
<p>According to Wikipedia, <a href="https://en.wikipedia.org/wiki/System_Integrity_Protection">System Integrity Protection</a> is</p>
<blockquote>
<p>System Integrity Protection (SIP, sometimes referred to as rootless) is a security feature
of Apple's macOS operating system introduced in OS X El Capitan. It comprises a number of
mechanisms that are enforced by the kernel. A centerpiece is the protection of system-owned
files and directories against modifications by processes without a specific &quot;entitlement&quot;,
even when executed by the root user or a user with root privileges (sudo).</p>
</blockquote>
<p>It prevents processes using <code>ptrace</code> syscall. If a process wants to use <code>ptrace</code> it has to be
code signed. The certificate that signs it has to be trusted on your machine.</p>
<p>See <a href="https://developer.apple.com/library/archive/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_11.html#//apple_ref/doc/uid/TP40016227-SW11">Apple developer documentation for System Integrity Protection</a>.</p>
<p>We may need to sign up with Apple and get the keys to do this signing. Tom has looked into if
Mozilla cannot do this because it is at the maximum number of
keys it is allowed to sign. Tom does not know if Mozilla could get more keys.</p>
<p>Alternatively, Tom suggests that maybe a Rust legal entity is needed to get the keys via Apple.
This problem is not technical in nature. If we had such a key we could sign GDB as well and
ship that.</p>
<h3><a class="header" href="#dwarf-and-traits" id="dwarf-and-traits">DWARF and Traits</a></h3>
<p>Rust traits are not emitted into DWARF at all. The impact of this is calling a method <code>x.method()</code>
does not work as is. The reason being that method is implemented by a trait, as opposed
to a type. That information is not present so finding trait methods is missing.</p>
<p>DWARF has a notion of interface types (possibly added for Java). Tom's idea was to use this
interface type as traits.</p>
<p>DWARF only deals with concrete names, not the reference types. So, a given implementation of a
trait for a type would be one of these interfaces (<code>DW_tag_interface</code> type). Also, the type for
which it is implemented would describe all the interfaces this type implements. This requires a
DWARF extension.</p>
<p>Issue on Github: <a href="https://github.com/rust-lang/rust/issues/33014">https://github.com/rust-lang/rust/issues/33014</a></p>
<h2><a class="header" href="#typical-process-for-a-debug-info-change-llvm" id="typical-process-for-a-debug-info-change-llvm">Typical process for a Debug Info change (LLVM)</a></h2>
<p>LLVM has Debug Info (DI) builders. This is the primary thing that Rust calls into.
This is why we need to change LLVM first because that is emitted first and not DWARF directly.
This is a kind of metadata that you construct and hand-off to LLVM. For the Rustc/LLVM hand-off
some LLVM DI builder methods are called to construct representation of a type.</p>
<p>The steps of this process are as follows -</p>
<ol>
<li>
<p>LLVM needs changing.</p>
<p>LLVM does not emit Interface types at all, so this needs to be implemented in the LLVM first.</p>
<p>Get sign off on LLVM maintainers that this is a good idea.</p>
</li>
<li>
<p>Change the DWARF extension.</p>
</li>
<li>
<p>Update the debuggers.</p>
<p>Update DWARF readers, expression evaluators.</p>
</li>
<li>
<p>Update Rust compiler.</p>
<p>Change it to emit this new information.</p>
</li>
</ol>
<h3><a class="header" href="#procedural-macro-stepping" id="procedural-macro-stepping">Procedural macro stepping</a></h3>
<p>A deeply profound question is that how do you actually debug a procedural macro?
What is the location you emit for a macro expansion? Consider some of the following cases -</p>
<ul>
<li>You can emit location of the invocation of the macro.</li>
<li>You can emit the location of the definition of the macro.</li>
<li>You can emit locations of the content of the macro.</li>
</ul>
<p>RFC: <a href="https://github.com/rust-lang/rfcs/pull/2117">https://github.com/rust-lang/rfcs/pull/2117</a></p>
<p>Focus is to let macros decide what to do. This can be achieved by having some kind of attribute
that lets the macro tell the compiler where the line marker should be. This affects where you
set the breakpoints and what happens when you step it.</p>
<h2><a class="header" href="#source-file-checksums-in-debug-info" id="source-file-checksums-in-debug-info">Source file checksums in debug info</a></h2>
<p>Both DWARF and CodeView (PDB) support embedding a cryptographic hash of each source file that
contributed to the associated binary.</p>
<p>The cryptographic hash can be used by a debugger to verify that the source file matches the
executable. If the source file does not match, the debugger can provide a warning to the user.</p>
<p>The hash can also be used to prove that a given source file has not been modified since it was
used to compile an executable. Because MD5 and SHA1 both have demonstrated vulnerabilities,
using SHA256 is recommended for this application.</p>
<p>The Rust compiler stores the hash for each source file in the corresponding <code>SourceFile</code> in
the <code>SourceMap</code>. The hashes of input files to external crates are stored in <code>rlib</code> metadata.</p>
<p>A default hashing algorithm is set in the target specification. This allows the target to
specify the best hash available, since not all targets support all hash algorithms.</p>
<p>The hashing algorithm for a target can also be overridden with the <code>-Z source-file-checksum=</code>
command-line option.</p>
<h4><a class="header" href="#dwarf-5" id="dwarf-5">DWARF 5</a></h4>
<p>DWARF version 5 supports embedding an MD5 hash to validate the source file version in use.
DWARF 5 - Section 6.2.4.1 opcode DW_LNCT_MD5</p>
<h4><a class="header" href="#llvm" id="llvm">LLVM</a></h4>
<p>LLVM IR supports MD5 and SHA1 (and SHA256 in LLVM 11+) source file checksums in the DIFile node.</p>
<p><a href="https://llvm.org/docs/LangRef.html#difile">LLVM DIFile documentation</a></p>
<h4><a class="header" href="#microsoft-visual-c-compiler-zh-option" id="microsoft-visual-c-compiler-zh-option">Microsoft Visual C++ Compiler /ZH option</a></h4>
<p>The MSVC compiler supports embedding MD5, SHA1, or SHA256 hashes in the PDB using the <code>/ZH</code>
compiler option.</p>
<p><a href="https://docs.microsoft.com/en-us/cpp/build/reference/zh">MSVC /ZH documentation</a></p>
<h4><a class="header" href="#clang" id="clang">Clang</a></h4>
<p>Clang always embeds an MD5 checksum, though this does not appear in documentation.</p>
<h2><a class="header" href="#future-work" id="future-work">Future work</a></h2>
<h4><a class="header" href="#name-mangling-changes" id="name-mangling-changes">Name mangling changes</a></h4>
<ul>
<li>New demangler in <code>libiberty</code> (gcc source tree).</li>
<li>New demangler in LLVM or LLDB.</li>
</ul>
<p><strong>TODO</strong>: Check the location of the demangler source.
<a href="https://github.com/rust-lang/rustc-dev-guide/pull/316#discussion_r283062536">Question on Github</a>.</p>
<h4><a class="header" href="#reuse-rust-compiler-for-expressions" id="reuse-rust-compiler-for-expressions">Reuse Rust compiler for expressions</a></h4>
<p>This is an important idea because debuggers by and large do not try to implement type
inference. You need to be much more explicit when you type into the debugger than your
actual source code. So, you cannot just copy and paste an expression from your source
code to debugger and expect the same answer but this would be nice. This can be helped
by using compiler.</p>
<p>It is certainly doable but it is a large project. You certainly need a bridge to the
debugger because the debugger alone has access to the memory. Both GDB (gcc) and LLDB (clang)
have this feature. LLDB uses Clang to compile code to JIT and GDB can do the same with GCC.</p>
<p>Both debuggers expression evaluation implement both a superset and a subset of Rust.
They implement just the expression language but they also add some extensions like GDB has
convenience variables. Therefore, if you are taking this route then you not only need
to do this bridge but may have to add some mode to let the compiler understand some extensions.</p>
<h1><a class="header" href="#appendix-b-background-topics" id="appendix-b-background-topics">Appendix B: Background topics</a></h1>
<p>This section covers a numbers of common compiler terms that arise in
this guide. We try to give the general definition while providing some
Rust-specific context.</p>
<p><a name="cfg"></a></p>
<h2><a class="header" href="#what-is-a-control-flow-graph" id="what-is-a-control-flow-graph">What is a control-flow graph?</a></h2>
<p>A control-flow graph is a common term from compilers. If you've ever
used a flow-chart, then the concept of a control-flow graph will be
pretty familiar to you. It's a representation of your program that
exposes the underlying control flow in a very clear way.</p>
<p>A control-flow graph is structured as a set of <strong>basic blocks</strong>
connected by edges. The key idea of a basic block is that it is a set
of statements that execute &quot;together&quot; – that is, whenever you branch
to a basic block, you start at the first statement and then execute
all the remainder. Only at the end of the block is there the
possibility of branching to more than one place (in MIR, we call that
final statement the <strong>terminator</strong>):</p>
<pre><code class="language-mir">bb0: {
    statement0;
    statement1;
    statement2;
    ...
    terminator;
}
</code></pre>
<p>Many expressions that you are used to in Rust compile down to multiple
basic blocks. For example, consider an if statement:</p>
<pre><code class="language-rust ignore">a = 1;
if some_variable {
    b = 1;
} else {
    c = 1;
}
d = 1;
</code></pre>
<p>This would compile into four basic blocks:</p>
<pre><code class="language-mir">BB0: {
    a = 1;
    if some_variable { goto BB1 } else { goto BB2 }
}

BB1: {
    b = 1;
    goto BB3;
}

BB2: {
    c = 1;
    goto BB3;
}

BB3: {
    d = 1;
    ...;
}
</code></pre>
<p>When using a control-flow graph, a loop simply appears as a cycle in
the graph, and the <code>break</code> keyword translates into a path out of that
cycle.</p>
<p><a name="dataflow"></a></p>
<h2><a class="header" href="#what-is-a-dataflow-analysis" id="what-is-a-dataflow-analysis">What is a dataflow analysis?</a></h2>
<p><a href="https://cs.au.dk/%7Eamoeller/spa/"><em>Static Program Analysis</em></a> by Anders Møller
and Michael I. Schwartzbach is an incredible resource!</p>
<p><em>to be written</em></p>
<p><a name="quantified"></a></p>
<h2><a class="header" href="#what-is-universally-quantified-what-about-existentially-quantified" id="what-is-universally-quantified-what-about-existentially-quantified">What is &quot;universally quantified&quot;? What about &quot;existentially quantified&quot;?</a></h2>
<p><em>to be written</em></p>
<p><a name="variance"></a></p>
<h2><a class="header" href="#what-is-co--and-contra-variance" id="what-is-co--and-contra-variance">What is co- and contra-variance?</a></h2>
<p>Check out the subtyping chapter from the
<a href="https://doc.rust-lang.org/nomicon/subtyping.html">Rust Nomicon</a>.</p>
<p>See the <a href="appendix/../variance.html">variance</a> chapter of this guide for more info on how
the type checker handles variance.</p>
<p><a name="free-vs-bound"></a></p>
<h2><a class="header" href="#what-is-a-free-region-or-a-free-variable-what-about-bound-region" id="what-is-a-free-region-or-a-free-variable-what-about-bound-region">What is a &quot;free region&quot; or a &quot;free variable&quot;? What about &quot;bound region&quot;?</a></h2>
<p>Let's describe the concepts of free vs bound in terms of program
variables, since that's the thing we're most familiar with.</p>
<ul>
<li>Consider this expression, which creates a closure: <code>|a, b| a + b</code>. Here, the <code>a</code> and <code>b</code> in <code>a + b</code> refer to the arguments
that the closure will be given when it is called. We say that the
<code>a</code> and <code>b</code> there are <strong>bound</strong> to the closure, and that the closure
signature <code>|a, b|</code> is a <strong>binder</strong> for the names <code>a</code> and <code>b</code>
(because any references to <code>a</code> or <code>b</code> within refer to the variables
that it introduces).</li>
<li>Consider this expression: <code>a + b</code>. In this expression, <code>a</code> and <code>b</code>
refer to local variables that are defined <em>outside</em> of the
expression. We say that those variables <strong>appear free</strong> in the
expression (i.e., they are <strong>free</strong>, not <strong>bound</strong> (tied up)).</li>
</ul>
<p>So there you have it: a variable &quot;appears free&quot; in some
expression/statement/whatever if it refers to something defined
outside of that expressions/statement/whatever. Equivalently, we can
then refer to the &quot;free variables&quot; of an expression – which is just
the set of variables that &quot;appear free&quot;.</p>
<p>So what does this have to do with regions? Well, we can apply the
analogous concept to type and regions. For example, in the type <code>&amp;'a u32</code>, <code>'a</code> appears free.  But in the type <code>for&lt;'a&gt; fn(&amp;'a u32)</code>, it
does not.</p>
<h1><a class="header" href="#further-reading-about-compilers" id="further-reading-about-compilers">Further Reading About Compilers</a></h1>
<blockquote>
<p>Thanks to <code>mem</code>, <code>scottmcm</code>, and <code>Levi</code> on the official Discord for the
recommendations, and to <code>tinaun</code> for posting a link to a <a href="https://twitter.com/graydon_pub/status/1039615569132118016">twitter thread from
Graydon Hoare</a>
which had some more recommendations!</p>
<p>Other sources: https://gcc.gnu.org/wiki/ListOfCompilerBooks</p>
<p>If you have other suggestions, please feel free to open an issue or PR.</p>
</blockquote>
<h2><a class="header" href="#books" id="books">Books</a></h2>
<ul>
<li><a href="https://www.cis.upenn.edu/%7Ebcpierce/tapl/">Types and Programming Languages</a></li>
<li><a href="https://www.cs.rochester.edu/%7Escott/pragmatics/">Programming Language Pragmatics</a></li>
<li><a href="https://www.cs.cmu.edu/%7Erwh/pfpl/2nded.pdf">Practical Foundations for Programming Languages</a></li>
<li><a href="https://www.amazon.com/dp/9332518661/ref=cm_sw_r_other_apa_1tUSBb5VHAVA1">Compilers: Principles, Techniques, and Tools, 2nd Edition</a></li>
<li><a href="https://www.cs.kent.ac.uk/people/staff/rej/gcbook/">Garbage Collection: Algorithms for Automatic Dynamic Memory Management</a></li>
<li><a href="https://linker.iecc.com/">Linkers and Loaders</a></li>
<li><a href="https://www.goodreads.com/book/show/887908.Advanced_Compiler_Design_and_Implementation">Advanced Compiler Design and Implementation</a></li>
<li><a href="https://www.goodreads.com/book/show/2063103.Building_an_Optimizing_Compiler">Building an Optimizing Compiler</a></li>
<li><a href="http://www.craftinginterpreters.com/">Crafting Interpreters</a></li>
</ul>
<h2><a class="header" href="#courses" id="courses">Courses</a></h2>
<ul>
<li><a href="https://www.cs.uoregon.edu/research/summerschool/archives.html">University of Oregon Programming Languages Summer School archive</a></li>
</ul>
<h2><a class="header" href="#wikis" id="wikis">Wikis</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type">Wikipedia</a></li>
<li><a href="https://esolangs.org/wiki/Main_Page">Esoteric Programming Languages</a></li>
<li><a href="https://plato.stanford.edu/index.html">Stanford Encyclopedia of Philosophy</a></li>
<li><a href="https://ncatlab.org/nlab/show/HomePage">nLab</a></li>
</ul>
<h2><a class="header" href="#misc-papers-and-blog-posts" id="misc-papers-and-blog-posts">Misc Papers and Blog Posts</a></h2>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.118.6683&amp;rep=rep1&amp;type=pdf">Programming in Martin-Löf's Type Theory</a></li>
<li><a href="https://www.cl.cam.ac.uk/%7Esd601/papers/mlsub-preprint.pdf">Polymorphism, Subtyping, and Type Inference in MLsub</a></li>
</ul>
<h1><a class="header" href="#appendix-c-glossary" id="appendix-c-glossary">Appendix C: Glossary</a></h1>
<table><thead><tr><th>Term</th><th>Meaning</th></tr></thead><tbody>
<tr><td>arena/arena allocation <div id="arena"/></td><td>An <em>arena</em> is a large memory buffer from which other memory allocations are made. This style of allocation is called <em>arena allocation</em>. See <a href="appendix/../memory.html">this chapter</a> for more info.</td></tr>
<tr><td>AST <div id="ast"/></td><td>The abstract syntax tree produced by the <code>rustc_ast</code> crate; reflects user syntax very closely.</td></tr>
<tr><td>binder <div id="binder"/></td><td>A &quot;binder&quot; is a place where a variable or type is declared; for example, the <code>&lt;T&gt;</code> is a binder for the generic type parameter <code>T</code> in <code>fn foo&lt;T&gt;(..)</code>, and |<code>a</code>|<code> ...</code> is a binder for the parameter <code>a</code>. See <a href="appendix/./background.html#free-vs-bound">the background chapter for more</a>.</td></tr>
<tr><td>BodyId &lt;div id=&quot;body-id&quot;/</td><td>An identifier that refers to a specific body (definition of a function or constant) in the crate. See <a href="appendix/../hir.html#identifiers-in-the-hir">the HIR chapter for more</a>.</td></tr>
<tr><td>bound variable <div id="bound-var"/></td><td>A &quot;bound variable&quot; is one that is declared within an expression/term. For example, the variable <code>a</code> is bound within the closure expression |<code>a</code>|<code> a * 2</code>. See <a href="appendix/./background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>codegen <div id="codegen"/></td><td>The code to translate MIR into LLVM IR.</td></tr>
<tr><td>codegen unit <div id="codegen-unit"/></td><td>When we produce LLVM IR, we group the Rust code into a number of codegen units (sometimes abbreviated as CGUs). Each of these units is processed by LLVM independently from one another, enabling parallelism. They are also the unit of incremental re-use. (<a href="appendix/../backend/codegen.html">see more</a>)</td></tr>
<tr><td>completeness <div id="completeness"/></td><td>A technical term in type theory, it means that every type-safe program also type-checks. Having both soundness and completeness is very hard, and usually soundness is more important. (see &quot;soundness&quot;).</td></tr>
<tr><td>control-flow graph <div id="cfg"/></td><td>A representation of the control-flow of a program; see <a href="appendix/./background.html#cfg">the background chapter for more</a></td></tr>
<tr><td>CTFE <div id="ctfe"/></td><td>Short for Compile-Time Function Evaluation, this is the ability of the compiler to evaluate <code>const fn</code>s at compile time. This is part of the compiler's constant evaluation system. (<a href="appendix/../const-eval.html">see more</a>)</td></tr>
<tr><td>cx <div id="cx"/></td><td>We tend to use &quot;cx&quot; as an abbreviation for context. See also <code>tcx</code>, <code>infcx</code>, etc.</td></tr>
<tr><td>DAG <div id="dag"/></td><td>A directed acyclic graph is used during compilation to keep track of dependencies between queries. (<a href="appendix/../queries/incremental-compilation.html">see more</a>)</td></tr>
<tr><td>data-flow analysis <div id="data-flow"/></td><td>A static analysis that figures out what properties are true at each point in the control-flow of a program; see <a href="appendix/./background.html#dataflow">the background chapter for more</a>.</td></tr>
<tr><td>DefId <div id="def-id"/></td><td>An index identifying a definition (see <code>librustc_middle/hir/def_id.rs</code>). Uniquely identifies a <code>DefPath</code>. See <a href="appendix/../hir.html#identifiers-in-the-hir">the HIR chapter for more</a>.</td></tr>
<tr><td>Double pointer <div id="double-ptr"/></td><td>A pointer with additional metadata. See &quot;fat pointer&quot; for more.</td></tr>
<tr><td>drop glue <div id="drop-glue"/></td><td>(internal) compiler-generated instructions that handle calling the destructors (<code>Drop</code>) for data types.</td></tr>
<tr><td>DST <div id="dst"/></td><td>Short for Dynamically-Sized Type, this is a type for which the compiler cannot statically know the size in memory (e.g. <code>str</code> or <code>[u8]</code>). Such types don't implement <code>Sized</code> and cannot be allocated on the stack. They can only occur as the last field in a struct. They can only be used behind a pointer (e.g. <code>&amp;str</code> or <code>&amp;[u8]</code>).</td></tr>
<tr><td>early-bound lifetime <div id="ebl"/></td><td>A lifetime region that is substituted at its definition site. Bound in an item's <code>Generics</code> and substituted using a <code>Substs</code>. Contrast with <strong>late-bound lifetime</strong>. (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.RegionKind.html#bound-regions">see more</a>)</td></tr>
<tr><td>empty type <div id="empty-type"/></td><td>see &quot;uninhabited type&quot;.</td></tr>
<tr><td>Fat pointer <div id="fat-ptr"/></td><td>A two word value carrying the address of some value, along with some further information necessary to put the value to use. Rust includes two kinds of &quot;fat pointers&quot;: references to slices, and trait objects. A reference to a slice carries the starting address of the slice and its length. A trait object carries a value's address and a pointer to the trait's implementation appropriate to that value. &quot;Fat pointers&quot; are also known as &quot;wide pointers&quot;, and &quot;double pointers&quot;.</td></tr>
<tr><td>free variable <div id="free-var"/></td><td>A &quot;free variable&quot; is one that is not bound within an expression or term; see <a href="appendix/./background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>generics <div id="generics"/></td><td>The set of generic type parameters defined on a type or item.</td></tr>
<tr><td>HIR <div id="hir"/></td><td>The High-level IR, created by lowering and desugaring the AST. (<a href="appendix/../hir.html">see more</a>)</td></tr>
<tr><td>HirId <div id="hir-id"/></td><td>Identifies a particular node in the HIR by combining a def-id with an &quot;intra-definition offset&quot;. See <a href="appendix/../hir.html#identifiers-in-the-hir">the HIR chapter for more</a>.</td></tr>
<tr><td>HIR Map <div id="hir-map"/></td><td>The HIR map, accessible via tcx.hir, allows you to quickly navigate the HIR and convert between various forms of identifiers.</td></tr>
<tr><td>ICE <div id="ice"/></td><td>Short for internal compiler error, this is when the compiler crashes.</td></tr>
<tr><td>ICH <div id="ich"/></td><td>Short for incremental compilation hash, these are used as fingerprints for things such as HIR and crate metadata, to check if changes have been made. This is useful in incremental compilation to see if part of a crate has changed and should be recompiled.</td></tr>
<tr><td>infcx <div id="infcx"/></td><td>The inference context (see <code>librustc_middle/infer</code>)</td></tr>
<tr><td>inference variable <div id="inf-var"/></td><td>When doing type or region inference, an &quot;inference variable&quot; is a kind of special type/region that represents what you are trying to infer. Think of X in algebra. For example, if we are trying to infer the type of a variable in a program, we create an inference variable to represent that unknown type.</td></tr>
<tr><td>intern <div id="intern"/></td><td>Interning refers to storing certain frequently-used constant data, such as strings, and then referring to the data by an identifier (e.g. a <code>Symbol</code>) rather than the data itself, to reduce memory usage and number of allocations. See <a href="appendix/../memory.html">this chapter</a> for more info.</td></tr>
<tr><td>intrinsic <div id="intrinsic"/></td><td>Intrinsics are special functions that are implemented in the compiler itself but exposed (often unstably) to users. They do magical and dangerous things. (See <a href="https://doc.rust-lang.org/std/intrinsics/index.html"><code>std::intrinsics</code></a>)</td></tr>
<tr><td>IR <div id="ir"/></td><td>Short for Intermediate Representation, a general term in compilers. During compilation, the code is transformed from raw source (ASCII text) to various IRs. In Rust, these are primarily HIR, MIR, and LLVM IR. Each IR is well-suited for some set of computations. For example, MIR is well-suited for the borrow checker, and LLVM IR is well-suited for codegen because LLVM accepts it.</td></tr>
<tr><td>IRLO <div id="irlo"/></td><td><code>IRLO</code> or <code>irlo</code> is sometimes used as an abbreviation for <a href="https://internals.rust-lang.org">internals.rust-lang.org</a>.</td></tr>
<tr><td>item <div id="item"/></td><td>A kind of &quot;definition&quot; in the language, such as a static, const, use statement, module, struct, etc. Concretely, this corresponds to the <code>Item</code> type.</td></tr>
<tr><td>lang item <div id="lang-item"/></td><td>Items that represent concepts intrinsic to the language itself, such as special built-in traits like <code>Sync</code> and <code>Send</code>; or traits representing operations such as <code>Add</code>; or functions that are called by the compiler. (<a href="https://doc.rust-lang.org/1.9.0/book/lang-items.html">see more</a>)</td></tr>
<tr><td>late-bound lifetime <div id="lbl"/></td><td>A lifetime region that is substituted at its call site. Bound in a HRTB and substituted by specific functions in the compiler, such as <code>liberate_late_bound_regions</code>. Contrast with <strong>early-bound lifetime</strong>. (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.RegionKind.html#bound-regions">see more</a>)</td></tr>
<tr><td>local crate <div id="local-crate"/></td><td>The crate currently being compiled.</td></tr>
<tr><td>LTO <div id="lto"/></td><td>Short for Link-Time Optimizations, this is a set of optimizations offered by LLVM that occur just before the final binary is linked. These include optimizations like removing functions that are never used in the final program, for example. <em>ThinLTO</em> is a variant of LTO that aims to be a bit more scalable and efficient, but possibly sacrifices some optimizations. You may also read issues in the Rust repo about &quot;FatLTO&quot;, which is the loving nickname given to non-Thin LTO. LLVM documentation: <a href="https://llvm.org/docs/LinkTimeOptimization.html">here</a> and <a href="https://clang.llvm.org/docs/ThinLTO.html">here</a>.</td></tr>
<tr><td><a href="https://llvm.org/">LLVM</a> <div id="llvm"/></td><td>(actually not an acronym :P) an open-source compiler backend. It accepts LLVM IR and outputs native binaries. Various languages (e.g. Rust) can then implement a compiler front-end that outputs LLVM IR and use LLVM to compile to all the platforms LLVM supports.</td></tr>
<tr><td>memoization <div id="memoization"/></td><td>The process of storing the results of (pure) computations (such as pure function calls) to avoid having to repeat them in the future. This is typically a trade-off between execution speed and memory usage.</td></tr>
<tr><td>MIR <div id="mir"/></td><td>The Mid-level IR that is created after type-checking for use by borrowck and codegen. (<a href="appendix/../mir/index.html">see more</a>)</td></tr>
<tr><td>miri <div id="miri"/></td><td>An interpreter for MIR used for constant evaluation. (<a href="appendix/../miri.html">see more</a>)</td></tr>
<tr><td>monomorphization <div id="mono"/></td><td>The process of taking generic implementations of types and functions and instantiating them with concrete types. For example, in the code we might have <code>Vec&lt;T&gt;</code>, but in the final executable, we will have a copy of the <code>Vec</code> code for every concrete type used in the program (e.g. a copy for <code>Vec&lt;usize&gt;</code>, a copy for <code>Vec&lt;MyStruct&gt;</code>, etc).</td></tr>
<tr><td>normalize <div id="normalize"/></td><td>A general term for converting to a more canonical form, but in the case of rustc typically refers to <a href="appendix/../traits/goals-and-clauses.html#normalizeprojection---type">associated type normalization</a>.</td></tr>
<tr><td>newtype <div id="newtype"/></td><td>A wrapper around some other type (e.g., <code>struct Foo(T)</code> is a &quot;newtype&quot; for <code>T</code>). This is commonly used in Rust to give a stronger type for indices.</td></tr>
<tr><td>NLL <div id="nll"/></td><td>Short for <a href="appendix/../borrow_check/region_inference.html">non-lexical lifetimes</a>, this is an extension to Rust's borrowing system to make it be based on the control-flow graph.</td></tr>
<tr><td>node-id or NodeId <div id="node-id"/></td><td>An index identifying a particular node in the AST or HIR; gradually being phased out and replaced with <code>HirId</code>. See <a href="appendix/../hir.html#identifiers-in-the-hir">the HIR chapter for more</a>.</td></tr>
<tr><td>obligation <div id="obligation"/></td><td>Something that must be proven by the trait system. (<a href="appendix/../traits/resolution.html">see more</a>)</td></tr>
<tr><td>placeholder <div id="placeholder"/></td><td><strong>NOTE: skolemization is deprecated by placeholder</strong> a way of handling subtyping around &quot;for-all&quot; types (e.g., <code>for&lt;'a&gt; fn(&amp;'a u32)</code>) as well as solving higher-ranked trait bounds (e.g., <code>for&lt;'a&gt; T: Trait&lt;'a&gt;</code>). See <a href="appendix/../borrow_check/region_inference/placeholders_and_universes.html">the chapter on placeholder and universes</a> for more details.</td></tr>
<tr><td>point <div id="point"/></td><td>Used in the NLL analysis to refer to some particular location in the MIR; typically used to refer to a node in the control-flow graph.</td></tr>
<tr><td>polymorphize <div id="polymorphize"/></td><td>An optimization that avoids unnecessary monomorphisation. (<a href="appendix/../backend/monomorph.html#polymorphization">see more</a>)</td></tr>
<tr><td>projection <div id="projection"/></td><td>A general term for a &quot;relative path&quot;, e.g. <code>x.f</code> is a &quot;field projection&quot;, and <code>T::Item</code> is an <a href="appendix/../traits/goals-and-clauses.html#trait-ref">&quot;associated type projection&quot;</a>.</td></tr>
<tr><td>promoted constants <div id="pc"/></td><td>Constants extracted from a function and lifted to static scope; see <a href="appendix/../mir/index.html#promoted">this section</a> for more details.</td></tr>
<tr><td>provider <div id="provider"/></td><td>The function that executes a query. (<a href="appendix/../query.html">see more</a>)</td></tr>
<tr><td>quantified <div id="quantified"/></td><td>In math or logic, existential and universal quantification are used to ask questions like &quot;is there any type T for which is true?&quot; or &quot;is this true for all types T?&quot;; see <a href="appendix/./background.html#quantified">the background chapter for more</a>.</td></tr>
<tr><td>query <div id="query"/></td><td>Perhaps some sub-computation during compilation. (<a href="appendix/../query.html">see more</a>)</td></tr>
<tr><td>region <div id="region"/></td><td>Another term for &quot;lifetime&quot; often used in the literature and in the borrow checker.</td></tr>
<tr><td>rib <div id="rib"/></td><td>A data structure in the name resolver that keeps track of a single scope for names. (<a href="appendix/../name-resolution.html">see more</a>)</td></tr>
<tr><td>sess <div id="sess"/></td><td>The compiler session, which stores global data used throughout compilation</td></tr>
<tr><td>side tables <div id="side-tables"/></td><td>Because the AST and HIR are immutable once created, we often carry extra information about them in the form of hashtables, indexed by the id of a particular node.</td></tr>
<tr><td>sigil <div id="sigil"/></td><td>Like a keyword but composed entirely of non-alphanumeric tokens. For example, <code>&amp;</code> is a sigil for references.</td></tr>
<tr><td>soundness <div id="soundness"/></td><td>A technical term in type theory. Roughly, if a type system is sound, then a program that type-checks is type-safe. That is, one can never (in safe rust) force a value into a variable of the wrong type. (see &quot;completeness&quot;).</td></tr>
<tr><td>span <div id="span"/></td><td>A location in the user's source code, used for error reporting primarily. These are like a file-name/line-number/column tuple on steroids: they carry a start/end point, and also track macro expansions and compiler desugaring. All while being packed into a few bytes (really, it's an index into a table). See the Span datatype for more.</td></tr>
<tr><td>substs <div id="substs"/></td><td>The substitutions for a given generic type or item (e.g. the <code>i32</code>, <code>u32</code> in <code>HashMap&lt;i32, u32&gt;</code>).</td></tr>
<tr><td>tcx <div id="tcx"/></td><td>The &quot;typing context&quot;, main data structure of the compiler. (<a href="appendix/../ty.html">see more</a>)</td></tr>
<tr><td>'tcx <div id="lifetime-tcx"/></td><td>The lifetime of the allocation arena. (<a href="appendix/../ty.html">see more</a>)</td></tr>
<tr><td>token <div id="token"/></td><td>The smallest unit of parsing. Tokens are produced after lexing (<a href="appendix/../the-parser.html">see more</a>).</td></tr>
<tr><td><a href="https://llvm.org/docs/LangRef.html#thread-local-storage-models">TLS</a> <div id="tls"/></td><td>Thread-Local Storage. Variables may be defined so that each thread has its own copy (rather than all threads sharing the variable). This has some interactions with LLVM. Not all platforms support TLS.</td></tr>
<tr><td>trait reference <div id="trait-ref"/></td><td>The name of a trait along with a suitable set of input type/lifetimes. (<a href="appendix/../traits/goals-and-clauses.html#trait-ref">see more</a>)</td></tr>
<tr><td>trans <div id="trans"/></td><td>The code to translate MIR into LLVM IR. Renamed to codegen.</td></tr>
<tr><td>ty <div id="ty"/></td><td>The internal representation of a type. (<a href="appendix/../ty.html">see more</a>)</td></tr>
<tr><td>UFCS <div id="ufcs"/></td><td>Short for Universal Function Call Syntax, this is an unambiguous syntax for calling a method. (<a href="appendix/../type-checking.html">see more</a>)</td></tr>
<tr><td>uninhabited type <div id="ut"/></td><td>A type which has <em>no</em> values. This is not the same as a ZST, which has exactly 1 value. An example of an uninhabited type is <code>enum Foo {}</code>, which has no variants, and so, can never be created. The compiler can treat code that deals with uninhabited types as dead code, since there is no such value to be manipulated. <code>!</code> (the never type) is an uninhabited type. Uninhabited types are also called &quot;empty types&quot;.</td></tr>
<tr><td>upvar <div id="upvar"/></td><td>A variable captured by a closure from outside the closure.</td></tr>
<tr><td>variance <div id="variance"/></td><td>Determines how changes to a generic type/lifetime parameter affect subtyping; for example, if <code>T</code> is a subtype of <code>U</code>, then <code>Vec&lt;T&gt;</code> is a subtype <code>Vec&lt;U&gt;</code> because <code>Vec</code> is <em>covariant</em> in its generic parameter. See <a href="appendix/./background.html#variance">the background chapter</a> for a more general explanation. See the <a href="appendix/../variance.html">variance chapter</a> for an explanation of how type checking handles variance.</td></tr>
<tr><td>Wide pointer <div id="wide-ptr"/></td><td>A pointer with additional metadata. See &quot;fat pointer&quot; for more.</td></tr>
<tr><td>ZST <div id="zst"/></td><td>Zero-Sized Type. A type whose values have size 0 bytes. Since <code>2^0 = 1</code>, such types can have exactly one value. For example, <code>()</code> (unit) is a ZST. <code>struct Foo;</code> is also a ZST. The compiler can do some nice optimizations around ZSTs.</td></tr>
</tbody></table>
<h1><a class="header" href="#appendix-d-code-index" id="appendix-d-code-index">Appendix D: Code Index</a></h1>
<p>rustc has a lot of important data structures. This is an attempt to give some
guidance on where to learn more about some of the key data structures of the
compiler.</p>
<table><thead><tr><th>Item</th><th>Kind</th><th>Short description</th><th>Chapter</th><th>Declaration</th></tr></thead><tbody>
<tr><td><code>BodyId</code></td><td>struct</td><td>One of four types of HIR node identifiers</td><td><a href="appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.BodyId.html">src/librustc_hir/hir.rs</a></td></tr>
<tr><td><code>Compiler</code></td><td>struct</td><td>Represents a compiler session and can be used to drive a compilation.</td><td><a href="appendix/../rustc-driver.html">The Rustc Driver and Interface</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Compiler.html">src/librustc_interface/interface.rs</a></td></tr>
<tr><td><code>ast::Crate</code></td><td>struct</td><td>A syntax-level representation of a parsed crate</td><td><a href="appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/struct.Crate.html">src/librustc_ast/ast.rs</a></td></tr>
<tr><td><code>rustc_hir::Crate</code></td><td>struct</td><td>A more abstract, compiler-friendly form of a crate's AST</td><td><a href="appendix/../hir.html">The Hir</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Crate.html">src/librustc_hir/hir.rs</a></td></tr>
<tr><td><code>DefId</code></td><td>struct</td><td>One of four types of HIR node identifiers</td><td><a href="appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html">src/librustc_hir/def_id.rs</a></td></tr>
<tr><td><code>DiagnosticBuilder</code></td><td>struct</td><td>A struct for building up compiler diagnostics, such as errors or lints</td><td><a href="appendix/../diagnostics.html">Emitting Diagnostics</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html">src/librustc_errors/diagnostic_builder.rs</a></td></tr>
<tr><td><code>DocContext</code></td><td>struct</td><td>A state container used by rustdoc when crawling through a crate to gather its documentation</td><td><a href="appendix/../rustdoc.html">Rustdoc</a></td><td><a href="https://github.com/rust-lang/rust/blob/master/src/librustdoc/core.rs">src/librustdoc/core.rs</a></td></tr>
<tr><td><code>HirId</code></td><td>struct</td><td>One of four types of HIR node identifiers</td><td><a href="appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/hir_id/struct.HirId.html">src/librustc_hir/hir_id.rs</a></td></tr>
<tr><td><code>NodeId</code></td><td>struct</td><td>One of four types of HIR node identifiers. Being phased out</td><td><a href="appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/node_id/struct.NodeId.html">src/librustc_ast/ast.rs</a></td></tr>
<tr><td><code>P</code></td><td>struct</td><td>An owned immutable smart pointer. By contrast, <code>&amp;T</code> is not owned, and <code>Box&lt;T&gt;</code> is not immutable.</td><td>None</td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ptr/struct.P.html">src/librustc_ast/ptr.rs</a></td></tr>
<tr><td><code>ParamEnv</code></td><td>struct</td><td>Information about generic parameters or <code>Self</code>, useful for working with associated or generic items</td><td><a href="appendix/../param_env.html">Parameter Environment</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.ParamEnv.html">src/librustc_middle/ty/mod.rs</a></td></tr>
<tr><td><code>ParseSess</code></td><td>struct</td><td>This struct contains information about a parsing session</td><td><a href="appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.ParseSess.html">src/librustc_session/parse/parse.rs</a></td></tr>
<tr><td><code>Query</code></td><td>struct</td><td>Represents the result of query to the <code>Compiler</code> interface and allows stealing, borrowing, and returning the results of compiler passes.</td><td><a href="appendix/../rustc-driver.html">The Rustc Driver and Interface</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/queries/struct.Query.html">src/librustc_interface/queries.rs</a></td></tr>
<tr><td><code>Rib</code></td><td>struct</td><td>Represents a single scope of names</td><td><a href="appendix/../name-resolution.html">Name resolution</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/late/struct.Rib.html">src/librustc_resolve/lib.rs</a></td></tr>
<tr><td><code>Session</code></td><td>struct</td><td>The data associated with a compilation session</td><td><a href="appendix/../the-parser.html">The parser</a>, <a href="appendix/../rustc-driver.html">The Rustc Driver and Interface</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/struct.Session.html">src/librustc_middle/session/mod.html</a></td></tr>
<tr><td><code>SourceFile</code></td><td>struct</td><td>Part of the <code>SourceMap</code>. Maps AST nodes to their source code for a single source file. Was previously called FileMap</td><td><a href="appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.SourceFile.html">src/librustc_span/lib.rs</a></td></tr>
<tr><td><code>SourceMap</code></td><td>struct</td><td>Maps AST nodes to their source code. It is composed of <code>SourceFile</code>s. Was previously called CodeMap</td><td><a href="appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/source_map/struct.SourceMap.html">src/librustc_span/source_map.rs</a></td></tr>
<tr><td><code>Span</code></td><td>struct</td><td>A location in the user's source code, used for error reporting primarily</td><td><a href="appendix/../diagnostics.html">Emitting Diagnostics</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html">src/librustc_span/span_encoding.rs</a></td></tr>
<tr><td><code>StringReader</code></td><td>struct</td><td>This is the lexer used during parsing. It consumes characters from the raw source code being compiled and produces a series of tokens for use by the rest of the parser</td><td><a href="appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/lexer/struct.StringReader.html">src/librustc_parse/lexer/mod.rs</a></td></tr>
<tr><td><code>rustc_ast::token_stream::TokenStream</code></td><td>struct</td><td>An abstract sequence of tokens, organized into <code>TokenTree</code>s</td><td><a href="appendix/../the-parser.html">The parser</a>, <a href="appendix/../macro-expansion.html">Macro expansion</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/tokenstream/struct.TokenStream.html">src/librustc_ast/tokenstream.rs</a></td></tr>
<tr><td><code>TraitDef</code></td><td>struct</td><td>This struct contains a trait's definition with type information</td><td><a href="appendix/../ty.html">The <code>ty</code> modules</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/trait_def/struct.TraitDef.html">src/librustc_middle/ty/trait_def.rs</a></td></tr>
<tr><td><code>TraitRef</code></td><td>struct</td><td>The combination of a trait and its input types (e.g. <code>P0: Trait&lt;P1...Pn&gt;</code>)</td><td><a href="appendix/../traits/goals-and-clauses.html#domain-goals">Trait Solving: Goals and Clauses</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TraitRef.html">src/librustc_middle/ty/sty.rs</a></td></tr>
<tr><td><code>Ty&lt;'tcx&gt;</code></td><td>struct</td><td>This is the internal representation of a type used for type checking</td><td><a href="appendix/../type-checking.html">Type checking</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Ty.html">src/librustc_middle/ty/mod.rs</a></td></tr>
<tr><td><code>TyCtxt&lt;'tcx&gt;</code></td><td>struct</td><td>The &quot;typing context&quot;. This is the central data structure in the compiler. It is the context that you use to perform all manner of queries</td><td><a href="appendix/../ty.html">The <code>ty</code> modules</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html">src/librustc_middle/ty/context.rs</a></td></tr>
</tbody></table>
<h1><a class="header" href="#compiler-lecture-series" id="compiler-lecture-series">Compiler Lecture Series</a></h1>
<p>These are videos where various experts explain different parts of the compiler:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=elBxMRSNYr4">Tom Tromey discusses debugging support in rustc</a></li>
<li><a href="https://www.youtube.com/watch?v=_muY4HjSqVw">How Salsa Works (2019.01)</a></li>
<li><a href="https://www.youtube.com/watch?v=i_IhACacPRY">Salsa In More Depth (2019.01)</a></li>
<li><a href="https://www.youtube.com/watch?v=Xr-rBqLr-G4">RLS 2.0, Salsa, and Name Resolution</a></li>
<li><a href="https://www.youtube.com/watch?v=9OIA7DTFQWU">Cranelift</a></li>
<li><a href="https://www.youtube.com/watch?v=ANKBNiSWyfc">Rust analyzer guide</a></li>
<li><a href="https://www.youtube.com/watch?v=DGAuLWdCCAI">Rust analyzer syntax trees</a></li>
<li><a href="https://www.youtube.com/watch?v=Lmp3P9WNL8o">rust-analyzer type-checker overview by flodiebold</a></li>
<li><a href="https://www.youtube.com/watch?v=5Pm2C1YXrvM">oli-obk on miri and constant evaluation</a></li>
<li><a href="https://www.youtube.com/watch?v=i5KdU0ieb_A">Polonius-rustc walkthrough</a></li>
<li><a href="https://www.youtube.com/watch?v=MBWtbDifPeU">rustc-chalk integration overview</a></li>
<li><a href="https://www.youtube.com/watch?v=rZqS4bLPL24">Coherence in Chalk by Sunjay Varma - Bay Area Rust Meetup</a></li>
<li><a href="https://www.youtube.com/watch?v=Ny2928cGDoM">How the chalk-engine crate works</a></li>
<li><a href="https://www.youtube.com/watch?v=hmV66tB79LM">How the chalk-engine crate works 2</a></li>
<li><a href="https://www.youtube.com/watch?v=UTXOptVMuIc">RFC #2229 Disjoint Field Capture plan</a></li>
<li><a href="https://www.youtube.com/watch?v=fMopdkn5-Xw">closures and upvar capture</a></li>
<li><a href="https://www.youtube.com/watch?v=pLmVhSB-z4s">blitzerr closure upvar tys</a></li>
<li><a href="https://www.youtube.com/watch?v=2QCuNtISoYc">Convert Closure Upvar Representation to Tuples with blitzerr</a></li>
<li><a href="https://www.youtube.com/watch?v=xe2_whJWBC0">async-await implementation plans</a></li>
<li><a href="https://www.youtube.com/watch?v=hlOxfkUDLPQ">async-await region inferencer</a></li>
<li><a href="https://www.youtube.com/watch?v=iV1Z0xYXkck">Universes and Lifetimes</a></li>
<li><a href="https://www.youtube.com/watch?v=c01TsOsr3-c">Representing types in rustc</a></li>
<li><a href="https://www.youtube.com/watch?v=ilv9V-328HI">Polonius WG: Initialization and move tracking</a></li>
</ul>
<h1><a class="header" href="#rust-bibliography" id="rust-bibliography">Rust Bibliography</a></h1>
<p>This is a reading list of material relevant to Rust. It includes prior
research that has - at one time or another - influenced the design of
Rust, as well as publications about Rust.</p>
<h2><a class="header" href="#type-system" id="type-system">Type system</a></h2>
<ul>
<li><a href="https://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
<li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/75277.75283">Making ad-hoc polymorphism less ad hoc</a></li>
<li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
<li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
<li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
<li><a href="http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
<li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
<li><a href="http://www.cs.ucla.edu/%7Epalsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
</ul>
<h2><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h2>
<ul>
<li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
<li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
<li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
<li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
<li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
<li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
<li><a href="https://web.archive.org/web/20190904045322/http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation</li>
<li><a href="http://www.stanford.edu/%7Eouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
<li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
<li><a href="https://web.njit.edu/%7Edingxn/papers/BWS.pdf">Balanced work stealing for time-sharing multicores</a></li>
<li><a href="http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
<li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
<li><a href="https://aturon.github.io/academic/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
<li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Epoch-based reclamation</a>.</li>
</ul>
<h2><a class="header" href="#others" id="others">Others</a></h2>
<ul>
<li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
</ul>
<h2><a class="header" href="#papers-about-rust" id="papers-about-rust">Papers <em>about</em> Rust</a></h2>
<ul>
<li><a href="https://ieeexplore.ieee.org/document/6650903">GPU Programming in Rust: Implementing High Level Abstractions in a Systems
Level
Language</a>.
Early GPU work by Eric Holk.</li>
<li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old
idea</a>
<ul>
<li>not exactly about Rust, but by nmatsakis</li>
</ul>
</li>
<li><a href="http://dada.cs.washington.edu/research/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming
Language</a>.
Early formalization of a subset of the type system, by Eric Reed.</li>
<li><a href="http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using
Rust</a>. By Lars Bergstrom.</li>
<li><a href="https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in
Rust</a>. Undergrad
paper by Michael Sproul.</li>
<li><a href="https://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in
Rust</a>. Undergrad paper by Alex
Light.</li>
<li><a href="https://github.com/1wilkens/thesis-ba">Evaluation of performance and productivity metrics of potential programming languages in the HPC environment</a>.
Bachelor's thesis by Florian Wilkens. Compares C, Go and Rust.</li>
<li><a href="http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library
in Rust</a>. By
Geoffroy Couprie, research for VLC.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate
Representation</a>. An
experimental IR implemented in Impala, a Rust-like language.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil
Codes</a>. Another
paper using Impala.</li>
<li><a href="http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf">Parallelization in Rust with fork-join and
friends</a>. Linus
Farnstrand's master's thesis.</li>
<li><a href="http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">Session Types for
Rust</a>. Philip
Munksgaard's master's thesis. Research for Servo.</li>
<li><a href="http://amitlevy.com/papers/tock-plos2015.pdf">Ownership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.</a></li>
<li><a href="https://raw.githubusercontent.com/Gankro/thesis/master/thesis.pdf">You can't spell trust without Rust</a>. Alexis Beingessner's master's thesis.</li>
<li><a href="http://bioinformatics.oxfordjournals.org/content/early/2015/10/06/bioinformatics.btv573">Rust-Bio: a fast and safe bioinformatics library</a>. Johannes Köster</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.704.1768">Safe, Correct, and Fast Low-Level Networking</a>. Robert Clipsham's master's thesis.</li>
<li><a href="http://hdl.handle.net/2429/55609">Formalizing Rust traits</a>. Jonatan Milewski's master's thesis.</li>
<li><a href="http://users.cecs.anu.edu.au/%7Esteveb/downloads/pdf/rust-ismm-2016.pdf">Rust as a Language for High Performance GC Implementation</a></li>
<li><a href="https://github.com/Kha/electrolysis">Simple Verification of Rust Programs via Functional Purification</a>. Sebastian Ullrich's master's thesis.</li>
<li><a href="http://spw17.langsec.org/papers/chifflier-parsing-in-2017.pdf">Writing parsers like it is 2017</a> Pierre Chifflier and Geoffroy Couprie for the Langsec Workshop</li>
<li><a href="https://www.tockos.org/assets/papers/rust-kernel-apsys2017.pdf">The Case for Writing a Kernel in Rust</a></li>
<li><a href="https://plv.mpi-sws.org/rustbelt/popl18/">RustBelt: Securing the Foundations of the Rust Programming Language</a></li>
</ul>
<h1><a class="header" href="#humor-in-rust" id="humor-in-rust">Humor in Rust</a></h1>
<p>What's a project without a sense of humor? And frankly some of these are
enlightening?</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/weird-exprs.rs">Weird exprs test</a></li>
<li><a href="http://fitzgeraldnick.com/2018/12/13/rust-raps.html">Ferris Rap</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/53645#issue-210543221">The Genesis of Generic Germination</a></li>
<li><a href="https://github.com/rust-lang/rust/blob/79d8a0fcefa5134db2a94739b1d18daa01fc6e9f/src/test/ui/bastion-of-the-turbofish.rs">The Bastion of the Turbofish test</a></li>
<li><a href="https://users.rust-lang.org/t/rust-koans/2408">Rust Koans</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0ab2bd6a9d722e0f05a95e2a5dcf89cc"><code>break rust;</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/nomicon/">The Nomicon Intro</a></li>
<li><a href="https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/rustc-ty.20naming.20bikeshed.20.2F.20punfest.20(was.3A.20design.20meeting.202.2E.2E.2E/near/189906455"><code>rustc-ty</code> renaming punfest</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
